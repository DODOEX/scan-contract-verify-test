{
  "language": "Solidity",
  "sources": {
    "contracts/CrowdPooling/impl/CP.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {CPVesting} from \"./CPVesting.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {IPermissionManager} from \"../../lib/PermissionManager.sol\";\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\n\n/**\n * @title DODO CrowdPooling\n * @author DODO Breeder\n *\n * @notice CrowdPooling initialization\n */\ncontract CP is CPVesting {\n    using SafeMath for uint256;\n\n    receive() external payable {\n        require(_INITIALIZED_ == false, \"WE_NOT_SAVE_ETH_AFTER_INIT\");\n    }\n\n    function init(\n        address[] calldata addressList,\n        uint256[] calldata timeLine,\n        uint256[] calldata valueList,\n        bool[] calldata switches //0 isOverCapStop 1 isOpenTWAP\n    ) external {\n        /*\n        Address List\n        0. owner\n        1. maintainer\n        2. baseToken\n        3. quoteToken\n        4. permissionManager\n        5. feeRateModel\n        6. poolFactory\n      */\n\n        require(addressList.length == 7, \"LIST_LENGTH_WRONG\");\n\n        initOwner(addressList[0]);\n        _MAINTAINER_ = addressList[1];\n        _BASE_TOKEN_ = IERC20(addressList[2]);\n        _QUOTE_TOKEN_ = IERC20(addressList[3]);\n        _BIDDER_PERMISSION_ = IPermissionManager(addressList[4]);\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(addressList[5]);\n        _POOL_FACTORY_ = addressList[6];\n\n        /*\n        Time Line\n        0. phase bid starttime\n        1. phase bid duration\n        2. phase calm duration\n        3. freeze duration\n        4. vesting duration\n        5. claim freeze duration\n        6. claim vesting duration\n        */\n\n        require(timeLine.length == 7, \"LIST_LENGTH_WRONG\");\n\n        _PHASE_BID_STARTTIME_ = timeLine[0];\n        _PHASE_BID_ENDTIME_ = _PHASE_BID_STARTTIME_.add(timeLine[1]);\n        _PHASE_CALM_ENDTIME_ = _PHASE_BID_ENDTIME_.add(timeLine[2]);\n\n        _FREEZE_DURATION_ = timeLine[3];\n        _VESTING_DURATION_ = timeLine[4];\n        _TOKEN_CLAIM_DURATION_ = timeLine[5];\n        _TOKEN_VESTING_DURATION_ = timeLine[6];\n        require(block.timestamp <= _PHASE_BID_STARTTIME_, \"TIMELINE_WRONG\");\n\n        /*\n        Value List\n        0. pool quote cap\n        1. k\n        2. i\n        3. lp cliff rate\n        4. base token cliff rate\n        5. lp fee rate\n        */\n\n        require(valueList.length == 6, \"LIST_LENGTH_WRONG\");\n\n        _POOL_QUOTE_CAP_ = valueList[0];\n        _K_ = valueList[1];\n        _I_ = valueList[2];\n        _CLIFF_RATE_ = valueList[3];\n        _TOKEN_CLIFF_RATE_ = valueList[4];\n        _POOL_FEE_RATE_ = valueList[5];\n\n        require(_I_ > 0 && _I_ <= 1e36, \"I_VALUE_WRONG\");\n        require(_K_ <= 1e18, \"K_VALUE_WRONG\");\n        require(_CLIFF_RATE_ <= 1e18, \"CLIFF_RATE_WRONG\");\n        require(_TOKEN_CLIFF_RATE_ <= 1e18, \"TOKEN_CLIFF_RATE_WRONG\");\n\n        _TOTAL_BASE_ = _BASE_TOKEN_.balanceOf(address(this));\n\n        require(switches.length == 2, \"SWITCHES_LENGTH_WRONG\");\n\n        _IS_OVERCAP_STOP = switches[0];\n        _IS_OPEN_TWAP_ = switches[1];\n\n        require(address(this).balance == _SETTEL_FUND_, \"SETTLE_FUND_NOT_MATCH\");\n    }\n\n    // ============ Version Control ============\n\n    function version() virtual external pure returns (string memory) {\n        return \"CP 2.0.0\";\n    }\n\n    \n    // ============= View =================\n    function getCpInfoHelper(address user) external view returns (\n        bool isSettled,\n        uint256 settledTime,\n        uint256 claimableBaseToken,\n        uint256 claimedBaseToken,\n        bool isClaimedQuoteToken,\n        uint256 claimableQuoteToken,\n        address pool,\n        uint256 claimableLpToken,\n        uint256 myShares,\n        bool isOverCapStop\n    ) {\n        isSettled = _SETTLED_;\n        settledTime = _SETTLED_TIME_;\n        if(_SETTLED_ && block.timestamp >= _SETTLED_TIME_.add(_TOKEN_CLAIM_DURATION_)) {\n            claimableBaseToken = getClaimableBaseToken(user);\n            claimedBaseToken = _CLAIMED_BASE_TOKEN_[user];\n        }else {\n            claimableBaseToken = 0;\n            claimedBaseToken = 0;\n        }\n\n        if(_SETTLED_) {\n            if(_CLAIMED_QUOTE_[msg.sender]) {\n                isClaimedQuoteToken = true;\n                claimableQuoteToken = 0;\n            } else {\n                isClaimedQuoteToken = false;\n                claimableQuoteToken = _UNUSED_QUOTE_.mul(_SHARES_[user]).div(_TOTAL_SHARES_);\n            }\n        } else {\n            isClaimedQuoteToken = false;\n            claimableQuoteToken = 0;\n        }\n\n        pool = _POOL_;\n\n        if(_SETTLED_ && block.timestamp >= _SETTLED_TIME_.add(_FREEZE_DURATION_)) {\n            if(user == _OWNER_) {\n                claimableLpToken = getClaimableLPToken();\n            }else {\n                claimableLpToken = 0;\n            }\n        }else {\n            claimableLpToken = 0;\n        }\n\n        myShares = _SHARES_[user];\n\n        isOverCapStop = _IS_OVERCAP_STOP;\n    }\n}\n"
    },
    "contracts/CrowdPooling/impl/CPFunding.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {IDVM} from \"../../DODOVendingMachine/intf/IDVM.sol\";\nimport {IDVMFactory} from \"../../Factory/DVMFactory.sol\";\nimport {CPStorage} from \"./CPStorage.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\ncontract CPFunding is CPStorage {\n    using SafeERC20 for IERC20;\n    \n    // ============ Events ============\n    \n    event Bid(address to, uint256 amount, uint256 fee);\n    event Cancel(address to,uint256 amount);\n    event Settle();\n\n    // ============ BID & CALM PHASE ============\n    \n    modifier isBidderAllow(address bidder) {\n        require(_BIDDER_PERMISSION_.isAllowed(bidder), \"BIDDER_NOT_ALLOWED\");\n        if(_IS_OVERCAP_STOP) {\n            require(_QUOTE_TOKEN_.balanceOf(address(this)) <= _POOL_QUOTE_CAP_, \"ALREADY_OVER_CAP\");\n        }\n        _;\n    }\n\n    function bid(address to) external isNotForceStop phaseBid preventReentrant isBidderAllow(to) {\n        uint256 input = _getQuoteInput();\n        uint256 mtFee = DecimalMath.mulFloor(input, _MT_FEE_RATE_MODEL_.getFeeRate(to));\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n        _mintShares(to, input.sub(mtFee));\n        _sync();\n        emit Bid(to, input, mtFee);\n    }\n\n    function cancel(address to, uint256 amount, bytes calldata data) external phaseBidOrCalm preventReentrant {\n        require(_SHARES_[msg.sender] >= amount, \"SHARES_NOT_ENOUGH\");\n        _burnShares(msg.sender, amount);\n        _transferQuoteOut(to, amount);\n        _sync();\n\n        if(data.length > 0){\n            IDODOCallee(to).CPCancelCall(msg.sender,amount,data);\n        }\n\n        emit Cancel(msg.sender,amount);\n    }\n\n    function _mintShares(address to, uint256 amount) internal {\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        _TOTAL_SHARES_ = _TOTAL_SHARES_.add(amount);\n    }\n\n    function _burnShares(address from, uint256 amount) internal {\n        _SHARES_[from] = _SHARES_[from].sub(amount);\n        _TOTAL_SHARES_ = _TOTAL_SHARES_.sub(amount);\n    }\n\n    // ============ SETTLEMENT ============\n\n    function settle() external isNotForceStop phaseSettlement preventReentrant {\n        _settle();\n\n        (uint256 poolBase, uint256 poolQuote, uint256 poolI, uint256 unUsedBase, uint256 unUsedQuote) = getSettleResult();\n        _UNUSED_BASE_ = unUsedBase;\n        _UNUSED_QUOTE_ = unUsedQuote;\n\n        address _poolBaseToken;\n        address _poolQuoteToken;\n\n        if (_UNUSED_BASE_ > poolBase) {\n            _poolBaseToken = address(_QUOTE_TOKEN_);\n            _poolQuoteToken = address(_BASE_TOKEN_);\n        } else {\n            _poolBaseToken = address(_BASE_TOKEN_);\n            _poolQuoteToken = address(_QUOTE_TOKEN_);\n        }\n\n        _POOL_ = IDVMFactory(_POOL_FACTORY_).createDODOVendingMachine(\n            _poolBaseToken,\n            _poolQuoteToken,\n            _POOL_FEE_RATE_,\n            poolI,\n            DecimalMath.ONE,\n            _IS_OPEN_TWAP_\n        );\n\n        uint256 avgPrice = unUsedBase == 0 ? _I_ : DecimalMath.divCeil(poolQuote, unUsedBase);\n        _AVG_SETTLED_PRICE_ = avgPrice;\n\n        _transferBaseOut(_POOL_, poolBase);\n        _transferQuoteOut(_POOL_, poolQuote);\n\n        (_TOTAL_LP_AMOUNT_, ,) = IDVM(_POOL_).buyShares(address(this));\n\n        (bool success, ) = payable(msg.sender).call{value: _SETTEL_FUND_}(\"\");\n        require(success, \"ETH_TRANSFER_FAILED\");\n        emit Settle();\n    }\n\n    // in case something wrong with base token contract\n    function emergencySettle() external isNotForceStop phaseSettlement preventReentrant {\n        require(block.timestamp >= _PHASE_CALM_ENDTIME_.add(_SETTLEMENT_EXPIRE_), \"NOT_EMERGENCY\");\n        _settle();\n        _UNUSED_QUOTE_ = _QUOTE_TOKEN_.balanceOf(address(this));\n    }\n\n    function _settle() internal {\n        require(!_SETTLED_, \"ALREADY_SETTLED\");\n        _SETTLED_ = true;\n        _SETTLED_TIME_ = block.timestamp;\n    }\n\n    // ============ Pricing ============\n\n    function getSettleResult() public view returns (uint256 poolBase, uint256 poolQuote, uint256 poolI, uint256 unUsedBase, uint256 unUsedQuote) {\n        poolQuote = _QUOTE_TOKEN_.balanceOf(address(this));\n        if (poolQuote > _POOL_QUOTE_CAP_) {\n            poolQuote = _POOL_QUOTE_CAP_;\n        }\n        (uint256 soldBase,) = PMMPricing.sellQuoteToken(_getPMMState(), poolQuote);\n        poolBase = _TOTAL_BASE_.sub(soldBase);\n\n        unUsedQuote = _QUOTE_TOKEN_.balanceOf(address(this)).sub(poolQuote);\n        unUsedBase = _BASE_TOKEN_.balanceOf(address(this)).sub(poolBase);\n\n        // Try to make midPrice equal to avgPrice\n        // k=1, If quote and base are not balanced, one side must be cut off\n        // DVM truncated quote, but if more quote than base entering the pool, we need set the quote to the base\n\n        // m = avgPrice\n        // i = m (1-quote/(m*base))\n        // if quote = m*base i = 1\n        // if quote > m*base reverse\n        uint256 avgPrice = unUsedBase == 0 ? _I_ : DecimalMath.divCeil(poolQuote, unUsedBase);\n        uint256 baseDepth = DecimalMath.mulFloor(avgPrice, poolBase);\n\n        if (poolQuote == 0) {\n            // ask side only DVM\n            poolI = _I_;\n        } else if (unUsedBase== poolBase) {\n            // standard bonding curve\n            poolI = 1;\n        } else if (unUsedBase < poolBase) {\n            // poolI up round\n            uint256 ratio = DecimalMath.ONE.sub(DecimalMath.divFloor(poolQuote, baseDepth));\n            poolI = avgPrice.mul(ratio).mul(ratio).divCeil(DecimalMath.ONE2);\n        } else if (unUsedBase > poolBase) {\n            // poolI down round\n            uint256 ratio = DecimalMath.ONE.sub(DecimalMath.divCeil(baseDepth, poolQuote));\n            poolI = ratio.mul(ratio).div(avgPrice);\n        }\n    }\n\n    function _getPMMState() internal view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _TOTAL_BASE_;\n        state.Q = 0;\n        state.B0 = state.B;\n        state.Q0 = 0;\n        state.R = PMMPricing.RState.ONE;\n    }\n\n    function getExpectedAvgPrice() external view returns (uint256) {\n        require(!_SETTLED_, \"ALREADY_SETTLED\");\n        (uint256 poolBase, uint256 poolQuote, , , ) = getSettleResult();\n        return DecimalMath.divCeil(poolQuote, _BASE_TOKEN_.balanceOf(address(this)).sub(poolBase));\n    }\n\n    // ============ Asset In ============\n\n    function _getQuoteInput() internal view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(_QUOTE_RESERVE_);\n    }\n\n    // ============ Set States ============\n\n    function _sync() internal {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = quoteBalance;\n        }\n    }\n\n    // ============ Asset Out ============\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function getShares(address user) external view returns (uint256) {\n        return _SHARES_[user];\n    }\n}\n"
    },
    "contracts/CrowdPooling/impl/CPStorage.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\nimport {IPermissionManager} from \"../../lib/PermissionManager.sol\";\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\n\ncontract CPStorage is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    // ============ Constant ============\n    \n    uint256 internal constant _SETTLEMENT_EXPIRE_ = 86400 * 7;\n    uint256 internal constant _SETTEL_FUND_ = 200 finney;\n    bool public _IS_OPEN_TWAP_ = false;\n    bool public _IS_OVERCAP_STOP = false;\n\n    bool public _FORCE_STOP_ = false;\n\n    // ============ Timeline ============\n\n    uint256 public _PHASE_BID_STARTTIME_;\n    uint256 public _PHASE_BID_ENDTIME_;\n    uint256 public _PHASE_CALM_ENDTIME_;\n    uint256 public _SETTLED_TIME_;\n    bool public _SETTLED_;\n\n    // ============ Core Address ============\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    // ============ Distribution Parameters ============\n\n    uint256 public _TOTAL_BASE_;\n    uint256 public _POOL_QUOTE_CAP_;\n\n    // ============ Settlement ============\n\n    uint256 public _QUOTE_RESERVE_;\n\n    uint256 public _UNUSED_BASE_;\n    uint256 public _UNUSED_QUOTE_;\n\n    uint256 public _TOTAL_SHARES_;\n    mapping(address => uint256) internal _SHARES_;\n    mapping(address => bool) public _CLAIMED_QUOTE_;\n\n    address public _POOL_FACTORY_;\n    address public _POOL_;\n    uint256 public _POOL_FEE_RATE_;\n    uint256 public _AVG_SETTLED_PRICE_;\n\n    // ============ Advanced Control ============\n\n    address public _MAINTAINER_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    IPermissionManager public _BIDDER_PERMISSION_;\n\n    // ============ PMM Parameters ============\n\n    uint256 public _K_;\n    uint256 public _I_;\n\n    // ============ LP Token Vesting && Claim Params ============\n\n    uint256 public _TOTAL_LP_AMOUNT_;\n    uint256 public _FREEZE_DURATION_;\n    uint256 public _VESTING_DURATION_;\n    uint256 public _CLIFF_RATE_;\n\n    uint256 public _TOKEN_CLAIM_DURATION_;\n    uint256 public _TOKEN_VESTING_DURATION_;\n    uint256 public _TOKEN_CLIFF_RATE_;\n    mapping(address => uint256) public _CLAIMED_BASE_TOKEN_;\n\n    // ============ Modifiers ============\n    modifier isNotForceStop() {\n        require(!_FORCE_STOP_, \"FORCE_STOP\");\n        _;\n    }\n\n    modifier phaseBid() {\n        require(\n            block.timestamp >= _PHASE_BID_STARTTIME_ && block.timestamp < _PHASE_BID_ENDTIME_,\n            \"NOT_PHASE_BID\"\n        );\n        _;\n    }\n\n    modifier phaseCalm() {\n        require(\n            block.timestamp >= _PHASE_BID_ENDTIME_ && block.timestamp < _PHASE_CALM_ENDTIME_,\n            \"NOT_PHASE_CALM\"\n        );\n        _;\n    }\n\n    modifier phaseBidOrCalm() {\n        require(\n            block.timestamp >= _PHASE_BID_STARTTIME_ && block.timestamp < _PHASE_CALM_ENDTIME_,\n            \"NOT_PHASE_BID_OR_CALM\"\n        );\n        _;\n    }\n\n    modifier phaseSettlement() {\n        require(block.timestamp >= _PHASE_CALM_ENDTIME_, \"NOT_PHASE_EXE\");\n        _;\n    }\n\n    modifier phaseVesting() {\n        require(_SETTLED_, \"NOT_VESTING\");\n        _;\n    }\n\n    function forceStop() external onlyOwner {\n        require(block.timestamp < _PHASE_BID_STARTTIME_, \"CP_ALREADY_STARTED\");\n        _FORCE_STOP_ = true;\n        _TOTAL_BASE_ = 0;\n        uint256 baseAmount = _BASE_TOKEN_.balanceOf(address(this));\n        _BASE_TOKEN_.transfer(_OWNER_, baseAmount);\n    }\n}\n"
    },
    "contracts/CrowdPooling/impl/CPVesting.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {Ownable} from \"../../lib/Ownable.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {CPFunding} from \"./CPFunding.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\n/**\n * @title CPVesting\n * @author DODO Breeder\n *\n * @notice Lock Token and release it linearly\n */\n\ncontract CPVesting is CPFunding {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n    \n    event ClaimBaseToken(address user, uint256 baseAmount);\n    event ClaimQuoteToken(address user, uint256 quoteAmount);\n    event ClaimLP(uint256 amount);\n\n\n    // ================ Modifiers ================\n\n    modifier afterSettlement() {\n        require(_SETTLED_, \"NOT_SETTLED\");\n        _;\n    }\n\n    modifier afterFreeze() {\n        require(_SETTLED_ && block.timestamp >= _SETTLED_TIME_.add(_FREEZE_DURATION_), \"FREEZED\");\n        _;\n    }\n\n    modifier afterClaimFreeze() {\n        require(_SETTLED_ && block.timestamp >= _SETTLED_TIME_.add(_TOKEN_CLAIM_DURATION_), \"CLAIM_FREEZED\");\n        _;\n    }\n\n    // ============ Bidder Functions ============\n\n    function bidderClaim(address to, bytes calldata data) external {\n        if(_SETTLED_) {\n            _claimQuoteToken(to, data);\n        }\n\n        if(_SETTLED_ && block.timestamp >= _SETTLED_TIME_.add(_TOKEN_CLAIM_DURATION_)) {\n            _claimBaseToken(to);\n        }\n    }\n\n    function _claimQuoteToken(address to,bytes calldata data) internal {\n        // require(!_CLAIMED_QUOTE_[msg.sender], \"ALREADY_CLAIMED_FUND\");\n        if(_CLAIMED_QUOTE_[msg.sender]) return;\n\n        _CLAIMED_QUOTE_[msg.sender] = true;\n\n\t\tuint256 quoteAmount = _UNUSED_QUOTE_.mul(_SHARES_[msg.sender]).div(_TOTAL_SHARES_);\n\n        _transferQuoteOut(to, quoteAmount);\n\n\t\tif(data.length>0){\n\t\t\tIDODOCallee(to).CPClaimBidCall(msg.sender,0,quoteAmount,data);\n\t\t}\n\n        emit ClaimQuoteToken(msg.sender, quoteAmount);\n    }\n\n    function _claimBaseToken(address to) internal {\n        uint256 claimableBaseAmount = getClaimableBaseToken(msg.sender);\n        _CLAIMED_BASE_TOKEN_[msg.sender] = _CLAIMED_BASE_TOKEN_[msg.sender].add(claimableBaseAmount);\n        _transferBaseOut(to, claimableBaseAmount);\n        emit ClaimBaseToken(msg.sender, claimableBaseAmount);\n    }\n\n    function getClaimableBaseToken(address user) public view afterClaimFreeze returns (uint256) {\n        uint256 baseTotalAmount = _UNUSED_BASE_.mul(_SHARES_[user]).div(_TOTAL_SHARES_);\n\n        uint256 remainingBaseToken = DecimalMath.mulFloor(\n            getRemainingBaseTokenRatio(block.timestamp),\n            baseTotalAmount\n        );\n        return baseTotalAmount.sub(remainingBaseToken).sub(_CLAIMED_BASE_TOKEN_[user]);\n    }\n\n    function getRemainingBaseTokenRatio(uint256 timestamp) public view afterClaimFreeze returns (uint256) {\n        uint256 timePast = timestamp.sub(_SETTLED_TIME_.add(_TOKEN_CLAIM_DURATION_));\n        if (timePast < _TOKEN_VESTING_DURATION_) {\n            uint256 remainingTime = _TOKEN_VESTING_DURATION_.sub(timePast);\n            return DecimalMath.ONE.sub(_TOKEN_CLIFF_RATE_).mul(remainingTime).div(_TOKEN_VESTING_DURATION_);\n        } else {\n            return 0;\n        }\n    }\n\n    // ============ Owner Functions ============\n\n    function claimLPToken() external onlyOwner afterFreeze {\n        uint256 lpAmount = getClaimableLPToken();\n        IERC20(_POOL_).safeTransfer(_OWNER_, lpAmount);\n        emit ClaimLP(lpAmount);\n    }\n\n    function getClaimableLPToken() public view afterFreeze returns (uint256) {\n        uint256 remainingLPToken = DecimalMath.mulFloor(\n            getRemainingLPRatio(block.timestamp),\n            _TOTAL_LP_AMOUNT_\n        );\n        return IERC20(_POOL_).balanceOf(address(this)).sub(remainingLPToken);\n    }\n\n    function getRemainingLPRatio(uint256 timestamp) public view afterFreeze returns (uint256) {\n        uint256 timePast = timestamp.sub(_SETTLED_TIME_.add(_FREEZE_DURATION_));\n        if (timePast < _VESTING_DURATION_) {\n            uint256 remainingTime = _VESTING_DURATION_.sub(timePast);\n            return DecimalMath.ONE.sub(_CLIFF_RATE_).mul(remainingTime).div(_VESTING_DURATION_);\n        } else {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/CrowdPooling/intf/ICP.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface ICP {\n    function init(\n        address[] calldata addressList,\n        uint256[] calldata timeLine,\n        uint256[] calldata valueList,\n        bool[] calldata switches\n    ) external;\n\n    function bid(address to) external;\n\n    function cancel(address assetTo, uint256 amount) external;\n\n    function settle() external;\n\n    function emergencySettle() external;\n\n    function claimLPToken() external;\n}\n"
    },
    "contracts/DODOFee/FeeRateDIP3Impl.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {IERC20} from \"../intf/IERC20.sol\";\nimport {SafeMath} from \"../lib/SafeMath.sol\";\n\ninterface ICrowdPooling {\n    function _QUOTE_RESERVE_() external view returns (uint256);\n    function getShares(address user) external view returns (uint256);\n    function _OWNER_() external returns (address);\n}\n\ninterface IFee {\n    function getUserFee(address user) external view returns (uint256);\n}\n\ninterface IQuota {\n    function getUserQuota(address user) external view returns (int);\n}\n\ninterface IPoolHeartBeat {\n    function isPoolHeartBeatLive(address pool) external view returns(bool);\n}\n\ninterface IPool {\n    function version() external pure returns (string memory);\n    function _LP_FEE_RATE_() external view returns (uint256);\n    function _BASE_RESERVE_() external view returns (uint);\n    function _QUOTE_RESERVE_() external view returns (uint);\n    function _K_() external view returns (uint);\n}\n\ncontract FeeRateDIP3Impl is InitializableOwnable {\n    using SafeMath for uint256;\n\n    // ============ Storage  ============\n\n    uint256 public _LP_MT_RATIO_ = 25;\n\n    struct CPPoolInfo {\n        address quoteToken;\n        int globalQuota;\n        address feeAddr;\n        address quotaAddr;\n    }\n\n    mapping(address => CPPoolInfo) public cpPools;\n    mapping(address => uint256) public specPoolList;\n    mapping (address => bool) public isAdminListed;\n    address public poolHeartBeat;\n\n    // ============ Events =============\n    event AddAdmin(address admin);\n    event RemoveAdmin(address admin);\n\n    // ============ Ownable Functions ============\n    \n    function addCpPoolInfo(address cpPool, address quoteToken, int globalQuota, address feeAddr, address quotaAddr) external {\n        require(isAdminListed[msg.sender], \"ACCESS_DENIED\");\n        CPPoolInfo memory cpPoolInfo =  CPPoolInfo({\n            quoteToken: quoteToken,\n            feeAddr: feeAddr,\n            quotaAddr: quotaAddr,\n            globalQuota: globalQuota\n        });\n        cpPools[cpPool] = cpPoolInfo;\n    }\n\n    function setCpPoolInfo(address cpPool, address quoteToken, int globalQuota, address feeAddr, address quotaAddr) external onlyOwner {\n        cpPools[cpPool].quoteToken = quoteToken;\n        cpPools[cpPool].feeAddr = feeAddr;\n        cpPools[cpPool].quotaAddr = quotaAddr;\n        cpPools[cpPool].globalQuota = globalQuota;\n    }\n\n    function setLpMtRatio(uint256 newLpMtRatio) external onlyOwner {\n        _LP_MT_RATIO_ = newLpMtRatio;\n    }\n\n\n    function setSpecPoolList (address poolAddr, uint256 mtFeeRate) public onlyOwner {\n        specPoolList[poolAddr] = mtFeeRate;\n    }\n\n    function addAdminList (address userAddr) external onlyOwner {\n        isAdminListed[userAddr] = true;\n        emit AddAdmin(userAddr);\n    }\n\n    function removeAdminList (address userAddr) external onlyOwner {\n        isAdminListed[userAddr] = false;\n        emit RemoveAdmin(userAddr);\n    }\n\n    function setPoolHeartBeat (address newPoolHeartBeat) public onlyOwner {\n        poolHeartBeat = newPoolHeartBeat;\n    }\n\n    // ============ Pool Owner Functions ============\n\n    function setCpPoolQuotaAddr(address cpPool, address quotaAddr) external {\n        require(msg.sender == ICrowdPooling(cpPool)._OWNER_(), \"NOT OWNER OF POOL\");\n        cpPools[cpPool].quotaAddr = quotaAddr;\n    }\n\n    // ============ View Functions ============\n\n    function getFeeRate(address pool, address user) external view returns (uint256) {\n        try IPool(pool).version() returns (string memory poolVersion) {\n            bytes32 hashPoolVersion = keccak256(abi.encodePacked(poolVersion));\n            if(_kjudge(hashPoolVersion)) {\n                uint k = IPool(pool)._K_();\n                uint baseReserve = IPool(pool)._BASE_RESERVE_();\n                uint quoteReserve = IPool(pool)._QUOTE_RESERVE_();\n                require(!(k==0 && (baseReserve ==0 || quoteReserve == 0)), \"KJUDGE_ERROR\");\n            }\n\n            if (poolHeartBeat != address(0) && !IPoolHeartBeat(poolHeartBeat).isPoolHeartBeatLive(pool)) {\n                return 10**18 - IPool(pool)._LP_FEE_RATE_() - 1;\n            }\n\n            if(specPoolList[pool] != 0) {\n                return specPoolList[pool];\n            }\n\n            if(_cp(hashPoolVersion)) {\n                CPPoolInfo memory cpPoolInfo = cpPools[pool];\n                address quoteToken = cpPoolInfo.quoteToken;\n                if(quoteToken == address(0)) {\n                    return 0;\n                }else {\n                    uint256 userInput = IERC20(quoteToken).balanceOf(pool).sub(ICrowdPooling(pool)._QUOTE_RESERVE_());\n                    uint256 userStake = ICrowdPooling(pool).getShares(user);\n                    address feeAddr = cpPoolInfo.feeAddr;\n                    address quotaAddr = cpPoolInfo.quotaAddr;\n                    int curQuota = cpPoolInfo.globalQuota;\n                    if(quotaAddr != address(0))\n                        curQuota = IQuota(quotaAddr).getUserQuota(user);\n\n                    require(curQuota == -1 || (curQuota != -1 && int(userInput.add(userStake)) <= curQuota), \"DODOFeeImpl: EXCEED_YOUR_QUOTA\");\n\n                    if(feeAddr == address(0)) {\n                        return 0;\n                    } else {\n                        return IFee(feeAddr).getUserFee(user);\n                    }\n                }\n            } else if(_dip3dvm(hashPoolVersion) || _dip3dsp(hashPoolVersion)) {\n                uint256 lpFeeRate = IPool(pool)._LP_FEE_RATE_();\n                uint256 mtFeeRate = lpFeeRate.mul(_LP_MT_RATIO_).div(100);\n                if(lpFeeRate.add(mtFeeRate) >= 10**18) {\n                    return 0;\n                } else {\n                    return mtFeeRate;\n                }\n            } else {\n                return 0;\n            }\n        } catch (bytes memory) {\n            return 0;\n        }\n    }\n\n    function getCPInfoByUser(address pool, address user) external view returns (bool isHaveCap, int curQuota, uint256 userFee) {\n        CPPoolInfo memory cpPoolInfo = cpPools[pool];\n        if(cpPoolInfo.quoteToken == address(0)) {\n            isHaveCap = false;\n            curQuota = -1;\n            userFee = 0;\n        }else {\n            address quotaAddr = cpPoolInfo.quotaAddr;\n            curQuota = cpPoolInfo.globalQuota;\n            if(quotaAddr != address(0))\n                curQuota = IQuota(quotaAddr).getUserQuota(user);\n        \n            if(curQuota == -1) {\n                isHaveCap = false;\n            }else {\n                isHaveCap = true;\n                uint256 userStake = ICrowdPooling(pool).getShares(user);\n                if(uint256(curQuota) >= userStake) {\n                    curQuota = int(uint256(curQuota).sub(userStake));\n                }else {\n                    curQuota = 0;\n                }\n            }\n\n            address feeAddr = cpPoolInfo.feeAddr;\n            if(feeAddr == address(0)) {\n                userFee =  0;\n            } else {\n                userFee = IFee(feeAddr).getUserFee(user);\n            }\n        }\n    }\n\n    function _cp(bytes32 _hashPoolVersion) internal pure returns (bool) {\n        return (_hashPoolVersion == keccak256(abi.encodePacked(\"CP 1.0.0\")) || _hashPoolVersion == keccak256(abi.encodePacked(\"CP 2.0.0\")));\n    }\n\n    function _dip3dvm(bytes32 _hashPoolVersion) internal pure returns (bool){\n        return (_hashPoolVersion == keccak256(abi.encodePacked(\"DVM 1.0.2\")) || _hashPoolVersion == keccak256(abi.encodePacked(\"DVM 1.0.3\")));\n    }\n\n    function _dip3dsp(bytes32 _hashPoolVersion) internal pure returns (bool){\n        return (_hashPoolVersion == keccak256(abi.encodePacked(\"DSP 1.0.1\")) || _hashPoolVersion == keccak256(abi.encodePacked(\"DSP 1.0.2\")));\n    }\n\n    function _kjudge(bytes32 _hashPoolVersion) internal pure returns (bool) {\n        return (_hashPoolVersion == keccak256(abi.encodePacked(\"DVM 1.0.2\")) || _hashPoolVersion == keccak256(abi.encodePacked(\"DSP 1.0.1\")) || _hashPoolVersion == keccak256(abi.encodePacked(\"DPP 1.0.0\")) || _hashPoolVersion == keccak256(abi.encodePacked(\"DPP Advanced 1.0.0\")));\n    }\n\n    function version() virtual external pure returns (string memory) {\n        return \"1.2.0\";\n    }\n}\n"
    },
    "contracts/DODOFee/PoolHeartBeat.sol": {
      "content": "/*\n\n    Copyright 2022 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\n\n\ncontract PoolHeartBeat is InitializableOwnable {\n\n    struct heartBeat {\n        uint256 lastHeartBeat;\n        uint256 maxInterval;\n    }\n    \n    mapping(address => address) public poolHeartBeatManager; // pool => heartbeat manager\n    mapping(address => heartBeat) public beats; // heartbeat manager => heartbeat\n\n    function isPoolHeartBeatLive(address pool) external view returns(bool) {\n        if(poolHeartBeatManager[pool]==address(0)) {\n            return true;\n        }\n        heartBeat memory beat = beats[poolHeartBeatManager[pool]];\n        return block.timestamp - beat.lastHeartBeat < beat.maxInterval;\n    }\n\n    function triggerBeat() external {\n        heartBeat storage beat = beats[msg.sender];\n        beat.lastHeartBeat = block.timestamp;\n    }\n\n    function setBeatInterval(uint256 interval) external {\n        heartBeat storage beat = beats[msg.sender];\n        beat.maxInterval = interval;\n    }\n\n    function bindPoolHeartBeat(address[] memory pools, address manager) external onlyOwner {\n        for(uint256 i=0; i<pools.length; i++) {\n            poolHeartBeatManager[pools[i]] = manager;\n        }\n    }\n}"
    },
    "contracts/DODOFee/UserQuota.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\n\ninterface IQuota {\n    function getUserQuota(address user) external view returns (int);\n}\n\ncontract UserQuota is InitializableOwnable, IQuota {\n\n    mapping(address => uint256) public userQuota;\n    \n    event SetQuota(address user, uint256 amount);\n\n    function setUserQuota(address[] memory users, uint256[] memory quotas) external onlyOwner {\n        require(users.length == quotas.length, \"PARAMS_LENGTH_NOT_MATCH\");\n        for(uint256 i = 0; i< users.length; i++) {\n            require(users[i] != address(0), \"USER_INVALID\");\n            userQuota[users[i]] = quotas[i];\n            emit SetQuota(users[i],quotas[i]);\n        }\n    }\n\n    function getUserQuota(address user) override external view returns (int) {\n        return int(userQuota[user]);\n    }\n}"
    },
    "contracts/DODOPrivatePool/impl/DPP.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {DPPTrader} from \"./DPPTrader.sol\";\n\n/**\n * @title DODO PrivatePool\n * @author DODO Breeder\n *\n * @notice DODOPrivatePool initialization\n */\ncontract DPP is DPPTrader {\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        bool isOpenTWAP\n    ) external {\n        initOwner(owner);\n\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        _MAINTAINER_ = maintainer;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        \n        require(lpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(k <= 1e18, \"K_OUT_OF_RANGE\");\n        require(i > 0 && i <= 1e36, \"I_OUT_OF_RANGE\");\n        _LP_FEE_RATE_ = uint64(lpFeeRate);\n        _K_ = uint64(k);\n        _I_ = uint128(i);\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n        \n        _resetTargetAndReserve();\n    }\n\n    // ============ Version Control ============\n\n    function version() virtual external pure returns (string memory) {\n        return \"DPP 1.0.0\";\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPAdmin.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDPP} from \"../intf/IDPP.sol\";\nimport {IDODOApproveProxy} from \"../../SmartRoute/DODOApproveProxy.sol\";\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\n\n/**\n * @title DPPAdmin\n * @author DODO Breeder\n *\n * @notice Admin of DODOPrivatePool\n */\ncontract DPPAdmin is InitializableOwnable {\n    address public _DPP_;\n    address public _OPERATOR_;\n    address public _DODO_APPROVE_PROXY_;\n    uint256 public _FREEZE_TIMESTAMP_;\n\n\n    modifier notFreezed() {\n        require(block.timestamp >= _FREEZE_TIMESTAMP_, \"ADMIN_FREEZED\");\n        _;\n    }\n\n    function init(\n        address owner,\n        address dpp,\n        address operator,\n        address dodoApproveProxy\n    ) external {\n        initOwner(owner);\n        _DPP_ = dpp;\n        _OPERATOR_ = operator;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    function sync() external notFreezed onlyOwner {\n        IDPP(_DPP_).ratioSync();\n    }\n\n    function setFreezeTimestamp(uint256 timestamp) external notFreezed onlyOwner {\n        _FREEZE_TIMESTAMP_ = timestamp;\n    }\n\n    function setOperator(address newOperator) external notFreezed onlyOwner {\n        _OPERATOR_ = newOperator;\n    }\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external notFreezed onlyOwner {\n        IDPP(_DPP_).retrieve(to, token, amount);\n    }\n\n    function reset(\n        address operator,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external notFreezed returns (bool) {\n        require(\n            msg.sender == _OWNER_ ||\n                (IDODOApproveProxy(_DODO_APPROVE_PROXY_).isAllowedProxy(msg.sender) &&\n                    operator == _OPERATOR_),\n            \"RESET FORBIDDEN！\"\n        );\n        return\n            IDPP(_DPP_).reset(\n                msg.sender,\n                newLpFeeRate,\n                newI,\n                newK,\n                baseOutAmount,\n                quoteOutAmount,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n    // ============ Admin Version Control ============\n\n    function version() external pure returns (string memory) {\n        return \"DPPAdmin 1.0.0\"; // 1.0.0\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPAdvanced/DPPAdvanced.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DPP} from \"../DPP.sol\";\n\n/**\n * @title DODO PrivatePool\n * @author DODO Breeder\n *\n * @notice Advanced DODOPrivatePool\n */\ncontract DPPAdvanced is DPP {\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _I_ = uint128(newI);\n        return true;\n    }\n\n\n    // ============ Version Control ============\n\n    function version() override external pure returns (string memory) {\n        return \"DPP Advanced 1.0.0\";\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPAdvanced/DPPAdvancedAdmin.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDPP} from \"../../intf/IDPP.sol\";\nimport {IDODOApproveProxy} from \"../../../SmartRoute/DODOApproveProxy.sol\";\nimport {InitializableOwnable} from \"../../../lib/InitializableOwnable.sol\";\n\n/**\n * @title DPPAdmin\n * @author DODO Breeder\n *\n * @notice Admin of Advanced DODOPrivatePool\n */\ncontract DPPAdvancedAdmin is InitializableOwnable {\n    address public _DPP_;\n    address public _OPERATOR_;\n    address public _DODO_APPROVE_PROXY_;\n    uint256 public _FREEZE_TIMESTAMP_;\n\n\n    modifier notFreezed() {\n        require(block.timestamp >= _FREEZE_TIMESTAMP_, \"ADMIN_FREEZED\");\n        _;\n    }\n\n    function init(\n        address owner,\n        address dpp,\n        address operator,\n        address dodoApproveProxy\n    ) external {\n        initOwner(owner);\n        _DPP_ = dpp;\n        _OPERATOR_ = operator;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    function sync() external notFreezed onlyOwner {\n        IDPP(_DPP_).ratioSync();\n    }\n\n    function setFreezeTimestamp(uint256 timestamp) external notFreezed onlyOwner {\n        _FREEZE_TIMESTAMP_ = timestamp;\n    }\n\n    function setOperator(address newOperator) external notFreezed onlyOwner {\n        _OPERATOR_ = newOperator;\n    }\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external notFreezed onlyOwner {\n        IDPP(_DPP_).retrieve(to, token, amount);\n    }\n\n    function tuneParameters(\n        address operator,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external notFreezed returns (bool) {\n        require(\n            msg.sender == _OWNER_ ||\n                (IDODOApproveProxy(_DODO_APPROVE_PROXY_).isAllowedProxy(msg.sender) &&\n                    operator == _OPERATOR_),\n            \"TUNEPARAMS FORBIDDEN！\"\n        );\n        return\n            IDPP(_DPP_).tuneParameters(\n                newLpFeeRate,\n                newI,\n                newK,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n    function tunePrice(\n        address operator,\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external notFreezed returns (bool) {\n        require(\n            msg.sender == _OWNER_ ||\n                (IDODOApproveProxy(_DODO_APPROVE_PROXY_).isAllowedProxy(msg.sender) &&\n                    operator == _OPERATOR_),\n            \"TUNEPRICE FORBIDDEN！\"\n        );\n        return\n            IDPP(_DPP_).tunePrice(\n                newI,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n    function reset(\n        address operator,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external notFreezed returns (bool) {\n        require(\n            msg.sender == _OWNER_ ||\n                (IDODOApproveProxy(_DODO_APPROVE_PROXY_).isAllowedProxy(msg.sender) &&\n                    operator == _OPERATOR_),\n            \"RESET FORBIDDEN！\"\n        );\n        return\n            IDPP(_DPP_).reset(\n                msg.sender,\n                newLpFeeRate,\n                newI,\n                newK,\n                baseOutAmount,\n                quoteOutAmount,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n    // ============ Admin Version Control ============\n\n    function version() external pure returns (string memory) {\n        return \"DPPAdvanced Admin 1.0.0\"; // 1.0.0\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPOracle/DPPOracle.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IFeeRateModel} from \"../../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../../intf/IERC20.sol\";\nimport {DPPTrader} from \"./DPPTrader.sol\";\n\n/**\n * @title DODO PrivatePool\n * @author DODO Breeder\n *\n * @notice DODOPrivatePool with oracle price\n */\ncontract DPPOracle is DPPTrader {\n\n    event EnableOracle();\n    event DisableOracle(uint256 newI);\n    event ChangeOracle(address indexed oracle);\n\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        address o,\n        bool isOpenTWAP,\n        bool isOracleEnabled\n    ) external {\n        initOwner(owner);\n\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        _MAINTAINER_ = maintainer;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        \n        require(lpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(k <= 1e18, \"K_OUT_OF_RANGE\");\n        require(i > 0 && i <= 1e36, \"I_OUT_OF_RANGE\");\n        require(o !=  address(0), \"INVALID_ORACLE\");\n\n        _LP_FEE_RATE_ = uint64(lpFeeRate);\n        _K_ = uint64(k);\n        _I_ = uint128(i);\n        _O_ = o;\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        _IS_ORACLE_ENABLED = isOracleEnabled;\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n        \n        _resetTargetAndReserve();\n    }\n\n    function changeOracle(address newOracle) public preventReentrant onlyOwner {\n        require(newOracle !=  address(0), \"INVALID_ORACLE\");\n        _O_ = newOracle;\n        emit ChangeOracle(newOracle);\n    }\n\n    function enableOracle() public preventReentrant onlyOwner {\n        _IS_ORACLE_ENABLED = true;\n        emit EnableOracle();\n    }\n\n    function disableOracle(uint256 newI) public preventReentrant onlyOwner {\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _I_ = uint128(newI);\n        _IS_ORACLE_ENABLED = false;\n        emit DisableOracle(newI);\n    }\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _I_ = uint128(newI);\n        return true;\n    }\n\n\n    // ============ Version Control ============\n\n    function version() external pure returns (string memory) {\n        return \"DPP Oracle 1.1.0\";\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPOracle/DPPOracleAdmin.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDPPOracle} from \"../../intf/IDPPOracle.sol\";\nimport {IDODOApproveProxy} from \"../../../SmartRoute/DODOApproveProxy.sol\";\nimport {InitializableOwnable} from \"../../../lib/InitializableOwnable.sol\";\n\n/**\n * @title DPPOracleAdmin\n * @author DODO Breeder\n *\n * @notice Admin of Oracle DODOPrivatePool\n */\ncontract DPPOracleAdmin is InitializableOwnable {\n    address public _DPP_;\n    address public _OPERATOR_;\n    address public _DODO_APPROVE_PROXY_;\n    uint256 public _FREEZE_TIMESTAMP_;\n\n\n    modifier notFreezed() {\n        require(block.timestamp >= _FREEZE_TIMESTAMP_, \"ADMIN_FREEZED\");\n        _;\n    }\n\n    function init(\n        address owner,\n        address dpp,\n        address operator,\n        address dodoApproveProxy\n    ) external {\n        initOwner(owner);\n        _DPP_ = dpp;\n        _OPERATOR_ = operator;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    function sync() external notFreezed onlyOwner {\n        IDPPOracle(_DPP_).ratioSync();\n    }\n\n    function setFreezeTimestamp(uint256 timestamp) external notFreezed onlyOwner {\n        _FREEZE_TIMESTAMP_ = timestamp;\n    }\n\n    function setOperator(address newOperator) external notFreezed onlyOwner {\n        _OPERATOR_ = newOperator;\n    }\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external notFreezed onlyOwner {\n        IDPPOracle(_DPP_).retrieve(to, token, amount);\n    }\n\n    function changeOracle(address newOracle) external onlyOwner notFreezed {\n        IDPPOracle(_DPP_).changeOracle(newOracle);\n    }\n\n    function enableOracle() external onlyOwner notFreezed {\n        IDPPOracle(_DPP_).enableOracle(); \n    }\n\n    function disableOracle(uint256 newI) external onlyOwner notFreezed {\n        IDPPOracle(_DPP_).disableOracle(newI); \n    }\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external onlyOwner notFreezed returns (bool) {\n        return\n            IDPPOracle(_DPP_).tuneParameters(\n                newLpFeeRate,\n                newI,\n                newK,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external onlyOwner notFreezed returns (bool) {\n        return\n            IDPPOracle(_DPP_).tunePrice(\n                newI,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n\n    function reset(\n        address operator,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external notFreezed returns (bool) {\n        require(\n            msg.sender == _OWNER_ ||\n                (IDODOApproveProxy(_DODO_APPROVE_PROXY_).isAllowedProxy(msg.sender) &&\n                    operator == _OPERATOR_),\n            \"RESET FORBIDDEN！\"\n        ); // only allow owner directly call or operator call via DODODppProxy\n        return\n            IDPPOracle(_DPP_).reset(\n                msg.sender, //only support asset transfer to msg.sender (_OWNER_ or allowed proxy)\n                newLpFeeRate,\n                newI,\n                newK,\n                baseOutAmount,\n                quoteOutAmount,\n                minBaseReserve,\n                minQuoteReserve\n            );\n    }\n\n    // ============ Admin Version Control ============\n\n    function version() external pure returns (string memory) {\n        return \"DPPOracle Admin 1.1.1\";\n    }\n}"
    },
    "contracts/DODOPrivatePool/impl/DPPOracle/DPPStorage.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../../../lib/InitializableOwnable.sol\";\nimport {SafeMath} from \"../../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../../lib/DecimalMath.sol\";\nimport {ReentrancyGuard} from \"../../../lib/ReentrancyGuard.sol\";\nimport {IFeeRateModel} from \"../../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../../intf/IERC20.sol\";\nimport {PMMPricing} from \"../../../lib/PMMPricing.sol\";\nimport {IOracle} from \"../../intf/IOracle.sol\";\n\ncontract DPPStorage is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bool public _IS_OPEN_TWAP_ = false;\n    bool public _IS_ORACLE_ENABLED = true;\n\n    // ============ Core Address ============\n\n    address public _MAINTAINER_;\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n\n    // ============ Variables for Pricing ============\n\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    \n    uint64 public _LP_FEE_RATE_;\n    uint64 public _K_;\n    uint128 public _I_;\n    address public _O_;\n\n    // ============ Helper Functions ============\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        if (_IS_ORACLE_ENABLED) {\n            state.i = IOracle(_O_).prices(address(_BASE_TOKEN_));\n        } else {\n            state.i = _I_;\n        }\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_;\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() \n        external \n        view \n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPOracle/DPPTrader.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DPPVault} from \"./DPPVault.sol\";\nimport {SafeMath} from \"../../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../../lib/PMMPricing.sol\";\nimport {IDODOCallee} from \"../../../intf/IDODOCallee.sol\";\nimport {IOracle} from \"../../intf/IOracle.sol\";\n\ncontract DPPTrader is DPPVault {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(\n        address borrower,\n        address assetTo,\n        uint256 baseAmount,\n        uint256 quoteAmount\n    );\n\n    event RChange(PMMPricing.RState newRState);\n\n\n    // ============ Trade Functions ============\n\n    function sellBase(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveQuoteAmount)\n    {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n        \n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\n            _BASE_TARGET_ = uint112(newBaseTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit DODOSwap(\n            address(_BASE_TOKEN_),\n            address(_QUOTE_TOKEN_),\n            baseInput,\n            receiveQuoteAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function sellQuote(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveBaseAmount)\n    {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\n            tx.origin,\n            quoteInput\n        );\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MAINTAINER_, mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit DODOSwap(\n            address(_QUOTE_TOKEN_),\n            address(_BASE_TOKEN_),\n            quoteInput,\n            receiveBaseAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address _assetTo,\n        bytes calldata data\n    ) external preventReentrant {\n        address assetTo = _assetTo;\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0)\n            IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        require(\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n            \"FLASH_LOAN_FAILED\"\n        );\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n            (\n                uint256 receiveBaseAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newQuoteTarget\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferBaseOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n            (\n                uint256 receiveQuoteAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newBaseTarget\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferQuoteOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\n                _BASE_TARGET_ = uint112(newBaseTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n        \n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n\n    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\n            .sub(mtFee);\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\n            .sub(mtFee);\n        newQuoteTarget = state.Q0;\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPOracle/DPPVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DPPStorage} from \"./DPPStorage.sol\";\nimport {IERC20} from \"../../../intf/IERC20.sol\";\nimport {IDODOCallee} from \"../../../intf/IDODOCallee.sol\";\nimport {SafeMath} from \"../../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../../lib/DecimalMath.sol\";\nimport {SafeERC20} from \"../../../lib/SafeERC20.sol\";\nimport {PMMPricing} from \"../../../lib/PMMPricing.sol\";\n\ncontract DPPVault is DPPStorage {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n\n    event LpFeeRateChange(uint256 newLpFeeRate);\n\n    // ============ View Functions ============\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user)\n        external\n        view\n        returns (uint256 lpFeeRate, uint256 mtFeeRate)\n    {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\n    }\n\n    // ============ Get Input ============\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\n    }\n\n    // ============ TWAP UPDATE ===========\n    \n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n        }\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    // ============ Set Status ============\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\n        _BASE_RESERVE_ = uint112(baseReserve);\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        \n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _resetTargetAndReserve() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n        \n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function ratioSync() external preventReentrant onlyOwner {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).mul(baseBalance).div(uint256(_BASE_RESERVE_)));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).mul(quoteBalance).div(uint256(_QUOTE_RESERVE_)));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n        _resetTargetAndReserve();\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n    // ============ Asset Out ============\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function retrieve(\n        address to,\n        address token,\n        uint256 amount\n    ) external preventReentrant onlyOwner {\n        require(token != address(_BASE_TOKEN_) && token != address(_QUOTE_TOKEN_), \"USE_RESET\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPOracle/WooOracleAdapter.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IOracle} from \"../../intf/IOracle.sol\";\n\ninterface IWooracle {\n    function timestamp() external view returns (uint256);\n    function isFeasible(address base) external view returns (bool);\n    function getPrice(address base) external view returns (uint256);\n    function price(address base) external view returns (uint256 priceNow, bool feasible);\n}\n\ncontract WooOracleAdapter is IOracle {\n    IWooracle public oracle;\n\n    constructor(address oracleAddress) public {\n        oracle = IWooracle(oracleAddress);\n    }\n\n    function getPrice(address base) external override view returns (uint256 latestPrice,bool isValid,bool isStale,uint256 timestamp) {\n        latestPrice = oracle.getPrice(base);\n        isValid = oracle.isFeasible(base);\n        isStale = !isValid;\n        timestamp = oracle.timestamp();\n        return (latestPrice, isValid, isStale, timestamp);\n    }    \n\n    function prices(address base) external override view returns (uint256) {\n        require(oracle.isFeasible(base), \"ORACLE NOT FEASIBLE\");\n        return oracle.getPrice(base);\n    }\n    \n    function isFeasible(address base) external override view returns (bool) {\n        return oracle.isFeasible(base);\n    }\n}"
    },
    "contracts/DODOPrivatePool/impl/DPPStorage.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\n\ncontract DPPStorage is InitializableOwnable, ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bool public _IS_OPEN_TWAP_ = false;\n\n    // ============ Core Address ============\n\n    address public _MAINTAINER_;\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n\n    // ============ Variables for Pricing ============\n\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    \n    uint64 public _LP_FEE_RATE_;\n    uint64 public _K_;\n    uint128 public _I_;\n\n    // ============ Helper Functions ============\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_;\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() \n        external \n        view \n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPTrader.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DPPVault} from \"./DPPVault.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\ncontract DPPTrader is DPPVault {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(\n        address borrower,\n        address assetTo,\n        uint256 baseAmount,\n        uint256 quoteAmount\n    );\n\n    event RChange(PMMPricing.RState newRState);\n\n    // ============ Trade Functions ============\n\n    function sellBase(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveQuoteAmount)\n    {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n        \n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\n            _BASE_TARGET_ = uint112(newBaseTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit DODOSwap(\n            address(_BASE_TOKEN_),\n            address(_QUOTE_TOKEN_),\n            baseInput,\n            receiveQuoteAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function sellQuote(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveBaseAmount)\n    {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\n            tx.origin,\n            quoteInput\n        );\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MAINTAINER_, mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit DODOSwap(\n            address(_QUOTE_TOKEN_),\n            address(_BASE_TOKEN_),\n            quoteInput,\n            receiveBaseAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external preventReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0)\n            IDODOCallee(assetTo).DPPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        require(\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n            \"FLASH_LOAN_FAILED\"\n        );\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n            (\n                uint256 receiveBaseAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newQuoteTarget\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferBaseOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newQuoteTarget <= uint112(-1),\"OVERFLOW\");\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n            (\n                uint256 receiveQuoteAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newBaseTarget\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferQuoteOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newBaseTarget <= uint112(-1),\"OVERFLOW\");\n                _BASE_TARGET_ = uint112(newBaseTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n        \n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n\n    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\n            .sub(mtFee);\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\n            .sub(mtFee);\n        newQuoteTarget = state.Q0;\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/impl/DPPVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DPPStorage} from \"./DPPStorage.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\n\ncontract DPPVault is DPPStorage {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n\n    event LpFeeRateChange(uint256 newLpFeeRate);\n\n    // ============ View Functions ============\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user)\n        external\n        view\n        returns (uint256 lpFeeRate, uint256 mtFeeRate)\n    {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\n    }\n\n    // ============ Get Input ============\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\n    }\n\n    // ============ TWAP UPDATE ===========\n    \n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n        }\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    // ============ Set Status ============\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\n        _BASE_RESERVE_ = uint112(baseReserve);\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        \n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _resetTargetAndReserve() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n        \n        _BASE_RESERVE_ = uint112(baseBalance);\n        _QUOTE_RESERVE_ = uint112(quoteBalance);\n        _BASE_TARGET_ = uint112(baseBalance);\n        _QUOTE_TARGET_ = uint112(quoteBalance);\n        _RState_ = uint32(PMMPricing.RState.ONE);\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function ratioSync() external preventReentrant onlyOwner {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).mul(baseBalance).div(uint256(_BASE_RESERVE_)));\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).mul(quoteBalance).div(uint256(_QUOTE_RESERVE_)));\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) public preventReentrant onlyOwner returns (bool) {\n        require(\n            _BASE_RESERVE_ >= minBaseReserve && _QUOTE_RESERVE_ >= minQuoteReserve,\n            \"RESERVE_AMOUNT_IS_NOT_ENOUGH\"\n        );\n        require(newLpFeeRate <= 1e18, \"LP_FEE_RATE_OUT_OF_RANGE\");\n        require(newK <= 1e18, \"K_OUT_OF_RANGE\");\n        require(newI > 0 && newI <= 1e36, \"I_OUT_OF_RANGE\");\n        _LP_FEE_RATE_ = uint64(newLpFeeRate);\n        _K_ = uint64(newK);\n        _I_ = uint128(newI);\n        _transferBaseOut(assetTo, baseOutAmount);\n        _transferQuoteOut(assetTo, quoteOutAmount);\n        _resetTargetAndReserve();\n        emit LpFeeRateChange(newLpFeeRate);\n        return true;\n    }\n\n    // ============ Asset Out ============\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function retrieve(\n        address to,\n        address token,\n        uint256 amount\n    ) external preventReentrant onlyOwner {\n        require(token != address(_BASE_TOKEN_) && token != address(_QUOTE_TOKEN_), \"USE_RESET\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/DODOPrivatePool/intf/IDPP.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDPP {\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        bool isOpenTWAP\n    ) external;\n\n    function _MT_FEE_RATE_MODEL_() external returns (address);\n\n    //=========== admin ==========\n    function ratioSync() external;\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external;\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    //========== advanced ========\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n}\n"
    },
    "contracts/DODOPrivatePool/intf/IDPPAdmin.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDPPAdmin {\n    function init(address owner, address dpp,address operator, address dodoSmartApprove) external;\n}"
    },
    "contracts/DODOPrivatePool/intf/IDPPOracle.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDPPOracle {\n    function init(\n        address owner,\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 k,\n        uint256 i,\n        address o,\n        bool isOpenTWAP,\n        bool isOracleEnabled\n    ) external;\n\n    function _MT_FEE_RATE_MODEL_() external returns (address);\n\n    //=========== admin ==========\n    function ratioSync() external;\n\n    function retrieve(\n        address payable to,\n        address token,\n        uint256 amount\n    ) external;\n\n    function reset(\n        address assetTo,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n\n    function tuneParameters(\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function tunePrice(\n        uint256 newI,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool);\n\n    function changeOracle(address newOracle) external;\n\n    function enableOracle() external;\n\n    function disableOracle(uint256 newI) external;\n}\n"
    },
    "contracts/DODOPrivatePool/intf/IOracle.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\ninterface IOracle {\n    function getPrice(address base) external view returns (uint256 latestPrice,bool isValid,bool isStale,uint256 timestamp);    \n\n    function prices(address base) external view returns (uint256);\n    \n    function isFeasible(address base) external view returns (bool); \n}\n"
    },
    "contracts/DODOStablePool/impl/DSP.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {DSPTrader} from \"./DSPTrader.sol\";\nimport {DSPFunding} from \"./DSPFunding.sol\";\nimport {DSPVault} from \"./DSPVault.sol\";\n\n/**\n * @title DODO StablePool\n * @author DODO Breeder\n *\n * @notice DODOStablePool initialization\n */\ncontract DSP is DSPTrader, DSPFunding {\n    function init(\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external {\n        require(!_DSP_INITIALIZED_, \"DSP_INITIALIZED\");\n        _DSP_INITIALIZED_ = true;\n        \n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        require(i > 0 && i <= 10**36);\n        _I_ = i;\n\n        require(k <= 10**18);\n        _K_ = k;\n\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _MAINTAINER_ = maintainer;\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        if (isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n\n        string memory connect = \"_\";\n        string memory suffix = \"DLP\";\n\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\n        symbol = \"DLP\";\n        decimals = _BASE_TOKEN_.decimals();\n\n        // ============================== Permit ====================================\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        // ==========================================================================\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n\n    // ============ Version Control ============\n\n    function version() external pure returns (string memory) {\n        return \"DSP 1.0.1\";\n    }\n}\n"
    },
    "contracts/DODOStablePool/impl/DSPFunding.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DSPVault} from \"./DSPVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\ncontract DSPFunding is DSPVault {\n    // ============ Events ============\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n\n    // ============ Buy & Sell Shares ============\n\n    // buy shares [round down]\n    function buyShares(address to)\n        external\n        preventReentrant\n        returns (\n            uint256 shares,\n            uint256 baseInput,\n            uint256 quoteInput\n        )\n    {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        baseInput = baseBalance.sub(baseReserve);\n        quoteInput = quoteBalance.sub(quoteReserve);\n        require(baseInput > 0, \"NO_BASE_INPUT\");\n\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n        // But May Happen，reserve >0 But totalSupply = 0\n        if (totalSupply == 0) {\n            // case 1. initial supply\n            require(quoteBalance > 0, \"ZERO_QUOTE_AMOUNT\");\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\n                ? DecimalMath.divFloor(quoteBalance, _I_)\n                : baseBalance;\n            _BASE_TARGET_ = uint112(shares);\n            _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\n            require(shares > 2001, \"MINT_AMOUNT_NOT_ENOUGH\");\n            require(_QUOTE_TARGET_ > 0, \"QUOTE_TARGET_IS_ZERO\");\n            _mint(address(0), 1001);\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).add(DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)));\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).add(DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)));\n        }\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n        emit BuyShares(to, shares, _SHARES_[to]);\n    }\n\n    // sell shares [round down]\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external preventReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\n        require(shareAmount <= _SHARES_[msg.sender], \"DLP_NOT_ENOUGH\");\n        require(to != address(this), \"SELL_BACK_NOT_ALLOWED\");\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 totalShares = totalSupply;\n\n        baseAmount = baseBalance.mul(shareAmount).div(totalShares);\n        quoteAmount = quoteBalance.mul(shareAmount).div(totalShares);\n\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_).sub(uint256(_BASE_TARGET_).mul(shareAmount).divCeil(totalShares)));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_).sub(uint256(_QUOTE_TARGET_).mul(shareAmount).divCeil(totalShares)));\n\n        require(\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\n            \"WITHDRAW_NOT_ENOUGH\"\n        );\n\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        if (data.length > 0) {\n            //Same as DVM \n            IDODOCallee(to).DVMSellShareCall(\n                msg.sender,\n                shareAmount,\n                baseAmount,\n                quoteAmount,\n                data\n            );\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\n    }\n}\n"
    },
    "contracts/DODOStablePool/impl/DSPStorage.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DODOMath} from \"../../lib/DODOMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\n\ncontract DSPStorage is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bool internal _DSP_INITIALIZED_;\n    bool public _IS_OPEN_TWAP_ = false;\n    \n    // ============ Core Address ============\n\n    address public _MAINTAINER_;\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n    \n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    uint32 public _RState_;\n\n    // ============ Shares (ERC20) ============\n\n    string public symbol;\n    uint8 public decimals;\n    string public name;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) internal _SHARES_;\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\n\n    // ================= Permit ======================\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    // ============ Variables for Pricing ============\n\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n\n    uint256 public _LP_FEE_RATE_;\n    uint256 public _K_;\n    uint256 public _I_;\n\n    // ============ Helper Functions ============\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall()\n        external\n        view\n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n}\n"
    },
    "contracts/DODOStablePool/impl/DSPTrader.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DSPVault} from \"./DSPVault.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\ncontract DSPTrader is DSPVault {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n\n    event RChange(PMMPricing.RState newRState);\n\n    // ============ Trade Functions ============\n\n    function sellBase(address to) external preventReentrant returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newBaseTarget <= uint112(-1), \"OVERFLOW\");\n            _BASE_TARGET_ = uint112(newBaseTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit DODOSwap(\n            address(_BASE_TOKEN_),\n            address(_QUOTE_TOKEN_),\n            baseInput,\n            receiveQuoteAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function sellQuote(address to) external preventReentrant returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\n            tx.origin,\n            quoteInput\n        );\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MAINTAINER_, mtFee);\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newQuoteTarget <= uint112(-1), \"OVERFLOW\");\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit DODOSwap(\n            address(_QUOTE_TOKEN_),\n            address(_BASE_TOKEN_),\n            quoteInput,\n            receiveBaseAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external preventReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0)\n            IDODOCallee(assetTo).DSPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n\n        // no input -> pure loss\n        require(\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n            \"FLASH_LOAN_FAILED\"\n        );\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n            (\n                uint256 receiveBaseAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newQuoteTarget\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\n            require(\n                uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount,\n                \"FLASH_LOAN_FAILED\"\n            );\n\n            _transferBaseOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newQuoteTarget <= uint112(-1), \"OVERFLOW\");\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n            (\n                uint256 receiveQuoteAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newBaseTarget\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\n            require(\n                uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount,\n                \"FLASH_LOAN_FAILED\"\n            );\n\n            _transferQuoteOut(_MAINTAINER_, mtFee);\n            if (_RState_ != uint32(newRState)) {\n                require(newBaseTarget <= uint112(-1), \"OVERFLOW\");\n                _BASE_TARGET_ = uint112(newBaseTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n\n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n\n    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\n            .sub(mtFee);\n        newBaseTarget = state.B0;\n    }\n\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\n            .sub(mtFee);\n        newQuoteTarget = state.Q0;\n    }\n}\n"
    },
    "contracts/DODOStablePool/impl/DSPVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {DSPStorage} from \"./DSPStorage.sol\";\n\ncontract DSPVault is DSPStorage {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event Mint(address indexed user, uint256 value);\n\n    event Burn(address indexed user, uint256 value);\n\n    // ============ View Functions ============\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user)\n        external\n        view\n        returns (uint256 lpFeeRate, uint256 mtFeeRate)\n    {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\n    }\n\n    // ============ Asset In ============\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\n    }\n\n    // ============ TWAP UPDATE ===========\n\n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n        }\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    // ============ Set States ============\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\n        _BASE_RESERVE_ = uint112(baseReserve);\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\n\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if (_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function sync() external preventReentrant {\n        _sync();\n    }\n\n    function correctRState() public {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_<_BASE_TARGET_) {\n          _RState_ = uint32(PMMPricing.RState.ONE);\n          _BASE_TARGET_ = _BASE_RESERVE_;\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_<_QUOTE_TARGET_) {\n          _RState_ = uint32(PMMPricing.RState.ONE);\n          _BASE_TARGET_ = _BASE_RESERVE_;\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    // ============ Asset Out ============\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    // ============ Shares (ERC20) ============\n\n    /**\n     * @dev transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        _SHARES_[msg.sender] = _SHARES_[msg.sender].sub(amount);\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the the balance of.\n     * @return balance An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        return _SHARES_[owner];\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param amount uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        _SHARES_[from] = _SHARES_[from].sub(amount);\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        _ALLOWED_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _ALLOWED_[owner][spender];\n    }\n\n    function _mint(address user, uint256 value) internal {\n        require(value > 1000, \"MINT_AMOUNT_NOT_ENOUGH\");\n        _SHARES_[user] = _SHARES_[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        _SHARES_[user] = _SHARES_[user].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n\n    // ============================ Permit ======================================\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"DODO_DSP_LP: EXPIRED\");\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"DODO_DSP_LP: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/DODOStablePool/intf/IDSP.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDSP {\n    function init(\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external;\n\n    function _BASE_TOKEN_() external view returns (address);\n\n    function _QUOTE_TOKEN_() external view returns (address);\n\n    function _I_() external view returns (uint256);\n\n    function _MT_FEE_RATE_MODEL_() external view returns (address);\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\n\n    function sellBase(address to) external returns (uint256);\n\n    function sellQuote(address to) external returns (uint256);\n\n    function buyShares(address to) external returns (uint256,uint256,uint256);\n}\n"
    },
    "contracts/DODOToken/DODOMine.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from \"../lib/Ownable.sol\";\nimport {DecimalMath} from \"../lib/DecimalMath.sol\";\nimport {SafeERC20} from \"../lib/SafeERC20.sol\";\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {IERC20} from \"../intf/IERC20.sol\";\nimport {IDODORewardVault, DODORewardVault} from \"./DODORewardVault.sol\";\n\ncontract DODOMine is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // Info of each user.\n    struct UserInfo {\n        uint256 amount; // How many LP tokens the user has provided.\n        uint256 rewardDebt; // Reward debt. See explanation below.\n        //\n        // We do some fancy math here. Basically, any point in time, the amount of DODOs\n        // entitled to a user but is pending to be distributed is:\n        //\n        //   pending reward = (user.amount * pool.accDODOPerShare) - user.rewardDebt\n        //\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\n        //   1. The pool's `accDODOPerShare` (and `lastRewardBlock`) gets updated.\n        //   2. User receives the pending reward sent to his/her address.\n        //   3. User's `amount` gets updated.\n        //   4. User's `rewardDebt` gets updated.\n    }\n\n    // Info of each pool.\n    struct PoolInfo {\n        address lpToken; // Address of LP token contract.\n        uint256 allocPoint; // How many allocation points assigned to this pool. DODOs to distribute per block.\n        uint256 lastRewardBlock; // Last block number that DODOs distribution occurs.\n        uint256 accDODOPerShare; // Accumulated DODOs per share, times 1e12. See below.\n    }\n\n    address public dodoRewardVault;\n    uint256 public dodoPerBlock;\n\n    // Info of each pool.\n    PoolInfo[] public poolInfos;\n    mapping(address => uint256) public lpTokenRegistry;\n\n    // Info of each user that stakes LP tokens.\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\n    mapping(address => uint256) public realizedReward;\n\n    // Total allocation points. Must be the sum of all allocation points in all pools.\n    uint256 public totalAllocPoint = 0;\n    // The block number when DODO mining starts.\n    uint256 public startBlock;\n\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\n    event Claim(address indexed user, uint256 amount);\n\n    constructor(address _dodoToken, uint256 _startBlock) public {\n        dodoRewardVault = address(new DODORewardVault(_dodoToken));\n        startBlock = _startBlock;\n    }\n\n    // ============ Modifiers ============\n\n    modifier lpTokenExist(address lpToken) {\n        require(lpTokenRegistry[lpToken] > 0, \"LP Token Not Exist\");\n        _;\n    }\n\n    modifier lpTokenNotExist(address lpToken) {\n        require(lpTokenRegistry[lpToken] == 0, \"LP Token Already Exist\");\n        _;\n    }\n\n    // ============ Helper ============\n\n    function poolLength() external view returns (uint256) {\n        return poolInfos.length;\n    }\n\n    function getPid(address _lpToken) public view lpTokenExist(_lpToken) returns (uint256) {\n        return lpTokenRegistry[_lpToken] - 1;\n    }\n\n    function getUserLpBalance(address _lpToken, address _user) public view returns (uint256) {\n        uint256 pid = getPid(_lpToken);\n        return userInfo[pid][_user].amount;\n    }\n\n    // ============ Ownable ============\n\n    function addLpToken(\n        address _lpToken,\n        uint256 _allocPoint,\n        bool _withUpdate\n    ) public lpTokenNotExist(_lpToken) onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\n        poolInfos.push(\n            PoolInfo({\n                lpToken: _lpToken,\n                allocPoint: _allocPoint,\n                lastRewardBlock: lastRewardBlock,\n                accDODOPerShare: 0\n            })\n        );\n        lpTokenRegistry[_lpToken] = poolInfos.length;\n    }\n\n    function setLpToken(\n        address _lpToken,\n        uint256 _allocPoint,\n        bool _withUpdate\n    ) public onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        uint256 pid = getPid(_lpToken);\n        totalAllocPoint = totalAllocPoint.sub(poolInfos[pid].allocPoint).add(_allocPoint);\n        poolInfos[pid].allocPoint = _allocPoint;\n    }\n\n    function setReward(uint256 _dodoPerBlock, bool _withUpdate) external onlyOwner {\n        if (_withUpdate) {\n            massUpdatePools();\n        }\n        dodoPerBlock = _dodoPerBlock;\n    }\n\n    // ============ View Rewards ============\n\n    function getPendingReward(address _lpToken, address _user) external view returns (uint256) {\n        uint256 pid = getPid(_lpToken);\n        PoolInfo storage pool = poolInfos[pid];\n        UserInfo storage user = userInfo[pid][_user];\n        uint256 accDODOPerShare = pool.accDODOPerShare;\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n        if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n            uint256 DODOReward = block\n                .number\n                .sub(pool.lastRewardBlock)\n                .mul(dodoPerBlock)\n                .mul(pool.allocPoint)\n                .div(totalAllocPoint);\n            accDODOPerShare = accDODOPerShare.add(DecimalMath.divFloor(DODOReward, lpSupply));\n        }\n        return DecimalMath.mulFloor(user.amount, accDODOPerShare).sub(user.rewardDebt);\n    }\n\n    function getAllPendingReward(address _user) external view returns (uint256) {\n        uint256 length = poolInfos.length;\n        uint256 totalReward = 0;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            if (userInfo[pid][_user].amount == 0 || poolInfos[pid].allocPoint == 0) {\n                continue; // save gas\n            }\n            PoolInfo storage pool = poolInfos[pid];\n            UserInfo storage user = userInfo[pid][_user];\n            uint256 accDODOPerShare = pool.accDODOPerShare;\n            uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n            if (block.number > pool.lastRewardBlock && lpSupply != 0) {\n                uint256 DODOReward = block\n                    .number\n                    .sub(pool.lastRewardBlock)\n                    .mul(dodoPerBlock)\n                    .mul(pool.allocPoint)\n                    .div(totalAllocPoint);\n                accDODOPerShare = accDODOPerShare.add(DecimalMath.divFloor(DODOReward, lpSupply));\n            }\n            totalReward = totalReward.add(\n                DecimalMath.mulFloor(user.amount, accDODOPerShare).sub(user.rewardDebt)\n            );\n        }\n        return totalReward;\n    }\n\n    function getRealizedReward(address _user) external view returns (uint256) {\n        return realizedReward[_user];\n    }\n\n    function getDlpMiningSpeed(address _lpToken) external view returns (uint256) {\n        uint256 pid = getPid(_lpToken);\n        PoolInfo storage pool = poolInfos[pid];\n        return dodoPerBlock.mul(pool.allocPoint).div(totalAllocPoint);\n    }\n\n    // ============ Update Pools ============\n\n    // Update reward vairables for all pools. Be careful of gas spending!\n    function massUpdatePools() public {\n        uint256 length = poolInfos.length;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            updatePool(pid);\n        }\n    }\n\n    // Update reward variables of the given pool to be up-to-date.\n    function updatePool(uint256 _pid) public {\n        PoolInfo storage pool = poolInfos[_pid];\n        if (block.number <= pool.lastRewardBlock) {\n            return;\n        }\n        uint256 lpSupply = IERC20(pool.lpToken).balanceOf(address(this));\n        if (lpSupply == 0) {\n            pool.lastRewardBlock = block.number;\n            return;\n        }\n        uint256 DODOReward = block\n            .number\n            .sub(pool.lastRewardBlock)\n            .mul(dodoPerBlock)\n            .mul(pool.allocPoint)\n            .div(totalAllocPoint);\n        pool.accDODOPerShare = pool.accDODOPerShare.add(DecimalMath.divFloor(DODOReward, lpSupply));\n        pool.lastRewardBlock = block.number;\n    }\n\n    // ============ Deposit & Withdraw & Claim ============\n    // Deposit & withdraw will also trigger claim\n\n    function deposit(address _lpToken, uint256 _amount) public {\n        uint256 pid = getPid(_lpToken);\n        PoolInfo storage pool = poolInfos[pid];\n        UserInfo storage user = userInfo[pid][msg.sender];\n        updatePool(pid);\n        if (user.amount > 0) {\n            uint256 pending = DecimalMath.mulFloor(user.amount, pool.accDODOPerShare).sub(\n                user.rewardDebt\n            );\n            safeDODOTransfer(msg.sender, pending);\n        }\n        IERC20(pool.lpToken).safeTransferFrom(address(msg.sender), address(this), _amount);\n        user.amount = user.amount.add(_amount);\n        user.rewardDebt = DecimalMath.mulFloor(user.amount, pool.accDODOPerShare);\n        emit Deposit(msg.sender, pid, _amount);\n    }\n\n    function withdraw(address _lpToken, uint256 _amount) public {\n        uint256 pid = getPid(_lpToken);\n        PoolInfo storage pool = poolInfos[pid];\n        UserInfo storage user = userInfo[pid][msg.sender];\n        require(user.amount >= _amount, \"withdraw too much\");\n        updatePool(pid);\n        uint256 pending = DecimalMath.mulFloor(user.amount, pool.accDODOPerShare).sub(\n            user.rewardDebt\n        );\n        safeDODOTransfer(msg.sender, pending);\n        user.amount = user.amount.sub(_amount);\n        user.rewardDebt = DecimalMath.mulFloor(user.amount, pool.accDODOPerShare);\n        IERC20(pool.lpToken).safeTransfer(address(msg.sender), _amount);\n        emit Withdraw(msg.sender, pid, _amount);\n    }\n\n    function withdrawAll(address _lpToken) public {\n        uint256 balance = getUserLpBalance(_lpToken, msg.sender);\n        withdraw(_lpToken, balance);\n    }\n\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\n    function emergencyWithdraw(address _lpToken) public {\n        uint256 pid = getPid(_lpToken);\n        PoolInfo storage pool = poolInfos[pid];\n        UserInfo storage user = userInfo[pid][msg.sender];\n        IERC20(pool.lpToken).safeTransfer(address(msg.sender), user.amount);\n        user.amount = 0;\n        user.rewardDebt = 0;\n    }\n\n    function claim(address _lpToken) public {\n        uint256 pid = getPid(_lpToken);\n        if (userInfo[pid][msg.sender].amount == 0 || poolInfos[pid].allocPoint == 0) {\n            return; // save gas\n        }\n        PoolInfo storage pool = poolInfos[pid];\n        UserInfo storage user = userInfo[pid][msg.sender];\n        updatePool(pid);\n        uint256 pending = DecimalMath.mulFloor(user.amount, pool.accDODOPerShare).sub(\n            user.rewardDebt\n        );\n        user.rewardDebt = DecimalMath.mulFloor(user.amount, pool.accDODOPerShare);\n        safeDODOTransfer(msg.sender, pending);\n    }\n\n    function claimAll() public {\n        uint256 length = poolInfos.length;\n        uint256 pending = 0;\n        for (uint256 pid = 0; pid < length; ++pid) {\n            if (userInfo[pid][msg.sender].amount == 0 || poolInfos[pid].allocPoint == 0) {\n                continue; // save gas\n            }\n            PoolInfo storage pool = poolInfos[pid];\n            UserInfo storage user = userInfo[pid][msg.sender];\n            updatePool(pid);\n            pending = pending.add(\n                DecimalMath.mulFloor(user.amount, pool.accDODOPerShare).sub(user.rewardDebt)\n            );\n            user.rewardDebt = DecimalMath.mulFloor(user.amount, pool.accDODOPerShare);\n        }\n        safeDODOTransfer(msg.sender, pending);\n    }\n\n    // Safe DODO transfer function\n    function safeDODOTransfer(address _to, uint256 _amount) internal {\n        IDODORewardVault(dodoRewardVault).reward(_to, _amount);\n        realizedReward[_to] = realizedReward[_to].add(_amount);\n        emit Claim(_to, _amount);\n    }\n}\n"
    },
    "contracts/DODOToken/DODOMineV2/BaseMine.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\nimport {IRewardVault, RewardVault} from \"./RewardVault.sol\";\n\ncontract BaseMine is InitializableOwnable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    struct RewardTokenInfo {\n        address rewardToken;\n        uint256 startBlock;\n        uint256 endBlock;\n        address rewardVault;\n        uint256 rewardPerBlock;\n        uint256 accRewardPerShare;\n        uint256 lastRewardBlock;\n        mapping(address => uint256) userRewardPerSharePaid;\n        mapping(address => uint256) userRewards;\n    }\n\n    RewardTokenInfo[] public rewardTokenInfos;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    // ============ Event =============\n\n    event Claim(uint256 indexed i, address indexed user, uint256 reward);\n    event UpdateReward(uint256 indexed i, uint256 rewardPerBlock);\n    event UpdateEndBlock(uint256 indexed i, uint256 endBlock);\n    event NewRewardToken(uint256 indexed i, address rewardToken);\n    event RemoveRewardToken(address rewardToken);\n    event WithdrawLeftOver(address owner, uint256 i);\n\n    // ============ View  ============\n\n    function getPendingReward(address user, uint256 i) public view returns (uint256) {\n        require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 accRewardPerShare = rt.accRewardPerShare;\n        if (rt.lastRewardBlock != block.number) {\n            accRewardPerShare = _getAccRewardPerShare(i);\n        }\n        return\n            DecimalMath.mulFloor(\n                balanceOf(user), \n                accRewardPerShare.sub(rt.userRewardPerSharePaid[user])\n            ).add(rt.userRewards[user]);\n    }\n\n    function getPendingRewardByToken(address user, address rewardToken) external view returns (uint256) {\n        return getPendingReward(user, getIdByRewardToken(rewardToken));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function getRewardTokenById(uint256 i) external view returns (address) {\n        require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        return rt.rewardToken;\n    }\n\n    function getIdByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return i;\n            }\n        }\n        require(false, \"DODOMineV2: TOKEN_NOT_FOUND\");\n    }\n\n    function getRewardNum() external view returns(uint256) {\n        return rewardTokenInfos.length;\n    }\n\n    // ============ Claim ============\n\n    function claimReward(uint256 i) public {\n        require(i<rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\");\n        _updateReward(msg.sender, i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 reward = rt.userRewards[msg.sender];\n        if (reward > 0) {\n            rt.userRewards[msg.sender] = 0;\n            IRewardVault(rt.rewardVault).reward(msg.sender, reward);\n            emit Claim(i, msg.sender, reward);\n        }\n    }\n\n    function claimAllRewards() external {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            claimReward(i);\n        }\n    }\n\n    // =============== Ownable  ================\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external onlyOwner {\n        require(rewardToken != address(0), \"DODOMineV2: TOKEN_INVALID\");\n        require(startBlock > block.number, \"DODOMineV2: START_BLOCK_INVALID\");\n        require(endBlock > startBlock, \"DODOMineV2: DURATION_INVALID\");\n\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                rewardToken != rewardTokenInfos[i].rewardToken,\n                \"DODOMineV2: TOKEN_ALREADY_ADDED\"\n            );\n        }\n\n        RewardTokenInfo storage rt = rewardTokenInfos.push();\n        rt.rewardToken = rewardToken;\n        rt.startBlock = startBlock;\n        rt.endBlock = endBlock;\n        rt.rewardPerBlock = rewardPerBlock;\n        rt.rewardVault = address(new RewardVault(rewardToken));\n\n        emit NewRewardToken(len, rewardToken);\n    }\n\n    function removeRewardToken(address rewardToken) external onlyOwner {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                if(i != len - 1) {\n                    rewardTokenInfos[i] = rewardTokenInfos[len - 1];\n                }\n                rewardTokenInfos.pop();\n                emit RemoveRewardToken(rewardToken);\n                break;\n            }\n        }\n    }\n\n    function setEndBlock(uint256 i, uint256 newEndBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n\n        require(block.number < newEndBlock, \"DODOMineV2: END_BLOCK_INVALID\");\n        require(block.number > rt.startBlock, \"DODOMineV2: NOT_START\");\n        require(block.number < rt.endBlock, \"DODOMineV2: ALREADY_CLOSE\");\n\n        rt.endBlock = newEndBlock;\n        emit UpdateEndBlock(i, newEndBlock);\n    }\n\n    function setReward(uint256 i, uint256 newRewardPerBlock)\n        external\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        \n        require(block.number < rt.endBlock, \"DODOMineV2: ALREADY_CLOSE\");\n\n        rt.rewardPerBlock = newRewardPerBlock;\n        emit UpdateReward(i, newRewardPerBlock);\n    }\n\n    function withdrawLeftOver(uint256 i, uint256 amount) external onlyOwner {\n        require(i < rewardTokenInfos.length, \"DODOMineV2: REWARD_ID_NOT_FOUND\");\n        \n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        require(block.number > rt.endBlock, \"DODOMineV2: MINING_NOT_FINISHED\");\n\n        IRewardVault(rt.rewardVault).withdrawLeftOver(msg.sender,amount);\n\n        emit WithdrawLeftOver(msg.sender, i);\n    }\n\n\n    // ============ Internal  ============\n\n    function _updateReward(address user, uint256 i) internal {\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        if (rt.lastRewardBlock != block.number){\n            rt.accRewardPerShare = _getAccRewardPerShare(i);\n            rt.lastRewardBlock = block.number;\n        }\n        if (user != address(0)) {\n            rt.userRewards[user] = getPendingReward(user, i);\n            rt.userRewardPerSharePaid[user] = rt.accRewardPerShare;\n        }\n    }\n\n    function _updateAllReward(address user) internal {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            _updateReward(user, i);\n        }\n    }\n\n    function _getUnrewardBlockNum(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (block.number < rt.startBlock || rt.lastRewardBlock > rt.endBlock) {\n            return 0;\n        }\n        uint256 start = rt.lastRewardBlock < rt.startBlock ? rt.startBlock : rt.lastRewardBlock;\n        uint256 end = rt.endBlock < block.number ? rt.endBlock : block.number;\n        return end.sub(start);\n    }\n\n    function _getAccRewardPerShare(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (totalSupply() == 0) {\n            return rt.accRewardPerShare;\n        }\n        return\n            rt.accRewardPerShare.add(\n                DecimalMath.divFloor(_getUnrewardBlockNum(i).mul(rt.rewardPerBlock), totalSupply())\n            );\n    }\n\n}\n"
    },
    "contracts/DODOToken/DODOMineV2/ERC20Mine.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {BaseMine} from \"./BaseMine.sol\";\n\ncontract ERC20Mine is BaseMine {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    address public _TOKEN_;\n\n    function init(address owner, address token) external {\n        super.initOwner(owner);\n        _TOKEN_ = token;\n    }\n\n    // ============ Event  ============\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n\n    // ============ Deposit && Withdraw && Exit ============\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"DODOMineV2: CANNOT_DEPOSIT_ZERO\");\n\n        _updateAllReward(msg.sender);\n\n        uint256 erc20OriginBalance = IERC20(_TOKEN_).balanceOf(address(this));\n        IERC20(_TOKEN_).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 actualStakeAmount = IERC20(_TOKEN_).balanceOf(address(this)).sub(erc20OriginBalance);\n        \n        _totalSupply = _totalSupply.add(actualStakeAmount);\n        _balances[msg.sender] = _balances[msg.sender].add(actualStakeAmount);\n\n        emit Deposit(msg.sender, actualStakeAmount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"DODOMineV2: CANNOT_WITHDRAW_ZERO\");\n\n        _updateAllReward(msg.sender);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        IERC20(_TOKEN_).safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n}\n"
    },
    "contracts/DODOToken/DODOMineV2/RewardVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {Ownable} from \"../../lib/Ownable.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\n\n\ninterface IRewardVault {\n    function reward(address to, uint256 amount) external;\n    function withdrawLeftOver(address to, uint256 amount) external; \n}\n\ncontract RewardVault is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public rewardToken;\n\n    constructor(address _rewardToken) public {\n        rewardToken = _rewardToken;\n    }\n\n    function reward(address to, uint256 amount) external onlyOwner {\n        IERC20(rewardToken).safeTransfer(to, amount);\n    }\n\n    function withdrawLeftOver(address to,uint256 amount) external onlyOwner {\n        uint256 leftover = IERC20(rewardToken).balanceOf(address(this));\n        require(amount <= leftover, \"VAULT_NOT_ENOUGH\");\n        IERC20(rewardToken).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/DODOToken/DODOMineV2/vDODOMine.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {BaseMine} from \"./BaseMine.sol\";\n\ninterface IVDODOToken {\n    function availableBalanceOf(address account) external view returns (uint256);\n}\n\ncontract vDODOMine is BaseMine {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n    address public _vDODO_TOKEN_;\n\n    function init(address owner, address vDODOToken) external {\n        super.initOwner(owner);\n        _vDODO_TOKEN_ = vDODOToken;\n    }\n\n    // ============ Event =============\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event SyncBalance();\n\n    // ============ Deposit && Withdraw && Exit ============\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"DODOMineV2: CANNOT_DEPOSIT_ZERO\");\n        require(\n            amount <= IVDODOToken(_vDODO_TOKEN_).availableBalanceOf(msg.sender),\n            \"DODOMineV2: vDODO_NOT_ENOUGH\"\n        );\n        _updateAllReward(msg.sender);\n        _totalSupply = _totalSupply.add(amount);\n        _balances[msg.sender] = _balances[msg.sender].add(amount);\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"DODOMineV2: CANNOT_WITHDRAW_ZERO\");\n        require(amount <= _balances[msg.sender], \"DODOMineV2: WITHDRAW_BALANCE_NOT_ENOUGH\");\n        _updateAllReward(msg.sender);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function syncBalance(address[] calldata userList) external {\n        for (uint256 i = 0; i < userList.length; ++i) {\n            address user = userList[i];\n            uint256 curBalance = balanceOf(user);\n            uint256 vDODOBalance = IERC20(_vDODO_TOKEN_).balanceOf(user);\n            if (curBalance > vDODOBalance) {\n                _updateAllReward(user);\n                _totalSupply = _totalSupply.add(vDODOBalance).sub(curBalance);\n                _balances[user] = vDODOBalance;\n            }\n        }\n        emit SyncBalance();\n    }\n\n    // ============ View  ============\n\n    function getLockedvDODO(address account) external view returns (uint256) {\n        return balanceOf(account);\n    }\n}\n"
    },
    "contracts/DODOToken/DODOMineV3/BaseMine.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\nimport {IRewardVault, RewardVault} from \"./RewardVault.sol\";\n\ncontract BaseMine is InitializableOwnable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    struct RewardTokenInfo {\n        address rewardToken;\n        uint256 startBlock;\n        uint256 endBlock;\n        address rewardVault;\n        uint256 rewardPerBlock;\n        uint256 accRewardPerShare;\n        uint256 lastRewardBlock;\n        uint256 workThroughReward;\n        uint256 lastFlagBlock;\n        mapping(address => uint256) userRewardPerSharePaid;\n        mapping(address => uint256) userRewards;\n    }\n\n    RewardTokenInfo[] public rewardTokenInfos;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n\n    // ============ Event =============\n\n    event Claim(uint256 indexed i, address indexed user, uint256 reward);\n    event UpdateReward(uint256 indexed i, uint256 rewardPerBlock);\n    event UpdateEndBlock(uint256 indexed i, uint256 endBlock);\n    event NewRewardToken(uint256 indexed i, address rewardToken);\n    event RemoveRewardToken(address rewardToken);\n    event WithdrawLeftOver(address owner, uint256 i);\n\n    // ============ View  ============\n\n    function getPendingReward(address user, uint256 i) public view returns (uint256) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 accRewardPerShare = rt.accRewardPerShare;\n        if (rt.lastRewardBlock != block.number) {\n            accRewardPerShare = _getAccRewardPerShare(i);\n        }\n        return\n            DecimalMath.mulFloor(\n                balanceOf(user), \n                accRewardPerShare.sub(rt.userRewardPerSharePaid[user])\n            ).add(rt.userRewards[user]);\n    }\n\n    function getPendingRewardByToken(address user, address rewardToken) external view returns (uint256) {\n        return getPendingReward(user, getIdByRewardToken(rewardToken));\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address user) public view returns (uint256) {\n        return _balances[user];\n    }\n\n    function getRewardTokenById(uint256 i) external view returns (address) {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        return rt.rewardToken;\n    }\n\n    function getIdByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return i;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getRewardNum() external view returns(uint256) {\n        return rewardTokenInfos.length;\n    }\n\n    function getVaultByRewardToken(address rewardToken) public view returns(address) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                return rewardTokenInfos[i].rewardVault;\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    function getVaultDebtByRewardToken(address rewardToken) public view returns(uint256) {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (rewardToken == rewardTokenInfos[i].rewardToken) {\n                uint256 totalDepositReward = IRewardVault(rewardTokenInfos[i].rewardVault)._TOTAL_REWARD_();\n                uint256 gap = rewardTokenInfos[i].endBlock.sub(rewardTokenInfos[i].lastFlagBlock);\n                uint256 totalReward = rewardTokenInfos[i].workThroughReward.add(gap.mul(rewardTokenInfos[i].rewardPerBlock));\n                if(totalDepositReward >= totalReward) {\n                    return 0;\n                }else {\n                    return totalReward.sub(totalDepositReward);\n                }\n            }\n        }\n        require(false, \"DODOMineV3: TOKEN_NOT_FOUND\");\n    }\n\n    // ============ Claim ============\n\n    function claimReward(uint256 i) public {\n        require(i<rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(msg.sender, i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        uint256 reward = rt.userRewards[msg.sender];\n        if (reward > 0) {\n            rt.userRewards[msg.sender] = 0;\n            IRewardVault(rt.rewardVault).reward(msg.sender, reward);\n            emit Claim(i, msg.sender, reward);\n        }\n    }\n\n    function claimAllRewards() external {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            claimReward(i);\n        }\n    }\n\n    // =============== Ownable  ================\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external onlyOwner {\n        require(rewardToken != address(0), \"DODOMineV3: TOKEN_INVALID\");\n        require(startBlock > block.number, \"DODOMineV3: START_BLOCK_INVALID\");\n        require(endBlock > startBlock, \"DODOMineV3: DURATION_INVALID\");\n\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            require(\n                rewardToken != rewardTokenInfos[i].rewardToken,\n                \"DODOMineV3: TOKEN_ALREADY_ADDED\"\n            );\n        }\n\n        RewardTokenInfo storage rt = rewardTokenInfos.push();\n        rt.rewardToken = rewardToken;\n        rt.startBlock = startBlock;\n        rt.lastFlagBlock = startBlock;\n        rt.endBlock = endBlock;\n        rt.rewardPerBlock = rewardPerBlock;\n        rt.rewardVault = address(new RewardVault(rewardToken));\n\n        uint256 rewardAmount = rewardPerBlock.mul(endBlock.sub(startBlock));\n        IERC20(rewardToken).safeTransfer(rt.rewardVault, rewardAmount);\n        RewardVault(rt.rewardVault).syncValue();\n\n        emit NewRewardToken(len, rewardToken);\n    }\n\n    function setEndBlock(uint256 i, uint256 newEndBlock)\n        public\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = newEndBlock.sub(rt.lastFlagBlock);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(rt.rewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        require(block.number < newEndBlock, \"DODOMineV3: END_BLOCK_INVALID\");\n        require(block.number > rt.startBlock, \"DODOMineV3: NOT_START\");\n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n\n        rt.endBlock = newEndBlock;\n        emit UpdateEndBlock(i, newEndBlock);\n    }\n\n    function setReward(uint256 i, uint256 newRewardPerBlock)\n        public\n        onlyOwner\n    {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        _updateReward(address(0), i);\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        \n        require(block.number < rt.endBlock, \"DODOMineV3: ALREADY_CLOSE\");\n        \n        rt.workThroughReward = rt.workThroughReward.add((block.number.sub(rt.lastFlagBlock)).mul(rt.rewardPerBlock));\n        rt.rewardPerBlock = newRewardPerBlock;\n        rt.lastFlagBlock = block.number;\n\n        uint256 totalDepositReward = RewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        uint256 gap = rt.endBlock.sub(block.number);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(newRewardPerBlock));\n        require(totalDepositReward >= totalReward, \"DODOMineV3: REWARD_NOT_ENOUGH\");\n\n        emit UpdateReward(i, newRewardPerBlock);\n    }\n\n    function withdrawLeftOver(uint256 i, uint256 amount) external onlyOwner {\n        require(i < rewardTokenInfos.length, \"DODOMineV3: REWARD_ID_NOT_FOUND\");\n        \n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        require(block.number > rt.endBlock, \"DODOMineV3: MINING_NOT_FINISHED\");\n        \n        uint256 gap = rt.endBlock.sub(rt.lastFlagBlock);\n        uint256 totalReward = rt.workThroughReward.add(gap.mul(rt.rewardPerBlock));\n        uint256 totalDepositReward = IRewardVault(rt.rewardVault)._TOTAL_REWARD_();\n        require(amount <= totalDepositReward.sub(totalReward), \"DODOMineV3: NOT_ENOUGH\");\n\n        IRewardVault(rt.rewardVault).withdrawLeftOver(msg.sender,amount);\n\n        emit WithdrawLeftOver(msg.sender, i);\n    }\n\n\n    function directTransferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"DODOMineV3: ZERO_ADDRESS\");\n        emit OwnershipTransferred(_OWNER_, newOwner);\n        _OWNER_ = newOwner;\n    }\n\n    // ============ Internal  ============\n\n    function _updateReward(address user, uint256 i) internal {\n        RewardTokenInfo storage rt = rewardTokenInfos[i];\n        if (rt.lastRewardBlock != block.number){\n            rt.accRewardPerShare = _getAccRewardPerShare(i);\n            rt.lastRewardBlock = block.number;\n        }\n        if (user != address(0)) {\n            rt.userRewards[user] = getPendingReward(user, i);\n            rt.userRewardPerSharePaid[user] = rt.accRewardPerShare;\n        }\n    }\n\n    function _updateAllReward(address user) internal {\n        uint256 len = rewardTokenInfos.length;\n        for (uint256 i = 0; i < len; i++) {\n            _updateReward(user, i);\n        }\n    }\n\n    function _getUnrewardBlockNum(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (block.number < rt.startBlock || rt.lastRewardBlock > rt.endBlock) {\n            return 0;\n        }\n        uint256 start = rt.lastRewardBlock < rt.startBlock ? rt.startBlock : rt.lastRewardBlock;\n        uint256 end = rt.endBlock < block.number ? rt.endBlock : block.number;\n        return end.sub(start);\n    }\n\n    function _getAccRewardPerShare(uint256 i) internal view returns (uint256) {\n        RewardTokenInfo memory rt = rewardTokenInfos[i];\n        if (totalSupply() == 0) {\n            return rt.accRewardPerShare;\n        }\n        return\n            rt.accRewardPerShare.add(\n                DecimalMath.divFloor(_getUnrewardBlockNum(i).mul(rt.rewardPerBlock), totalSupply())\n            );\n    }\n\n}\n"
    },
    "contracts/DODOToken/DODOMineV3/ERC20MineV3.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\nimport {BaseMine} from \"./BaseMine.sol\";\nimport {IRewardVault} from \"./RewardVault.sol\";\n\ncontract ERC20MineV3 is ReentrancyGuard, BaseMine {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    address public _TOKEN_;\n\n    function init(address owner, address token) external {\n        super.initOwner(owner);\n        _TOKEN_ = token;\n    }\n\n    // ============ Event  ============\n\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event FundAndSet(address rewardToken, uint256 amount, uint256 newEndBlock, uint256 newRewardPerBlock);\n\n    // ============ Deposit && Withdraw && Exit ============\n\n    function deposit(uint256 amount) external preventReentrant {\n        require(amount > 0, \"DODOMineV3: CANNOT_DEPOSIT_ZERO\");\n\n        _updateAllReward(msg.sender);\n\n        uint256 erc20OriginBalance = IERC20(_TOKEN_).balanceOf(address(this));\n        IERC20(_TOKEN_).safeTransferFrom(msg.sender, address(this), amount);\n        uint256 actualStakeAmount = IERC20(_TOKEN_).balanceOf(address(this)).sub(erc20OriginBalance);\n        \n        _totalSupply = _totalSupply.add(actualStakeAmount);\n        _balances[msg.sender] = _balances[msg.sender].add(actualStakeAmount);\n\n        emit Deposit(msg.sender, actualStakeAmount);\n    }\n\n    function withdraw(uint256 amount) external preventReentrant {\n        require(amount > 0, \"DODOMineV3: CANNOT_WITHDRAW_ZERO\");\n\n        _updateAllReward(msg.sender);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[msg.sender] = _balances[msg.sender].sub(amount);\n        IERC20(_TOKEN_).safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function fundAndSet(\n        address rewardToken, \n        uint256 amount, \n        uint256 newEndBlock, \n        uint256 newRewardPerBlock\n    ) onlyOwner external {\n        address rewardVault = getVaultByRewardToken(rewardToken);\n        uint256 id = getIdByRewardToken(rewardToken);\n\n        IERC20(rewardToken).safeTransferFrom(msg.sender, rewardVault, amount);\n        IRewardVault(rewardVault).syncValue();\n\n        setReward(id, newRewardPerBlock);\n        setEndBlock(id, newEndBlock);\n\n        emit FundAndSet(rewardToken, amount, newEndBlock, newRewardPerBlock);\n    }\n}\n"
    },
    "contracts/DODOToken/DODOMineV3/RewardVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {Ownable} from \"../../lib/Ownable.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\n\n\ninterface IRewardVault {\n    function reward(address to, uint256 amount) external;\n    function withdrawLeftOver(address to, uint256 amount) external; \n    function syncValue() external;\n    function _TOTAL_REWARD_() external view returns(uint256);\n}\n\ncontract RewardVault is Ownable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    uint256 public _REWARD_RESERVE_;\n    uint256 public _TOTAL_REWARD_;\n    address public _REWARD_TOKEN_;\n\n    // ============ Event =============\n    event DepositReward(uint256 totalReward, uint256 inputReward, uint256 rewardReserve);\n\n    constructor(address _rewardToken) public {\n        _REWARD_TOKEN_ = _rewardToken;\n    }\n\n    function reward(address to, uint256 amount) external onlyOwner {\n        require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\");\n        _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount);\n        IERC20(_REWARD_TOKEN_).safeTransfer(to, amount);\n    }\n\n    function withdrawLeftOver(address to,uint256 amount) external onlyOwner {\n        require(_REWARD_RESERVE_ >= amount, \"VAULT_NOT_ENOUGH\");\n        _REWARD_RESERVE_ = _REWARD_RESERVE_.sub(amount);\n        IERC20(_REWARD_TOKEN_).safeTransfer(to, amount);\n    }\n\n    function syncValue() external {\n        uint256 rewardBalance = IERC20(_REWARD_TOKEN_).balanceOf(address(this));\n        uint256 rewardInput = rewardBalance.sub(_REWARD_RESERVE_);\n\n        _TOTAL_REWARD_ = _TOTAL_REWARD_.add(rewardInput);\n        _REWARD_RESERVE_ = rewardBalance;\n\n        emit DepositReward(_TOTAL_REWARD_, rewardInput, _REWARD_RESERVE_);\n    }\n}"
    },
    "contracts/DODOToken/DODORewardVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {Ownable} from \"../lib/Ownable.sol\";\nimport {SafeERC20} from \"../lib/SafeERC20.sol\";\nimport {IERC20} from \"../intf/IERC20.sol\";\n\n\ninterface IDODORewardVault {\n    function reward(address to, uint256 amount) external;\n}\n\n\ncontract DODORewardVault is Ownable {\n    using SafeERC20 for IERC20;\n\n    address public dodoToken;\n\n    constructor(address _dodoToken) public {\n        dodoToken = _dodoToken;\n    }\n\n    function reward(address to, uint256 amount) external onlyOwner {\n        IERC20(dodoToken).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/DODOToken/DODOToken.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\n\n\n/**\n * @title DODO Token\n * @author DODO Breeder\n */\ncontract DODOToken {\n    using SafeMath for uint256;\n\n    string public symbol = \"DODO\";\n    string public name = \"DODO bird\";\n\n    uint256 public decimals = 18;\n    uint256 public totalSupply = 1000000000 * 10**18; // 1 Billion\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    // ============ Events ============\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    // ============ Functions ============\n\n    constructor() public {\n        balances[msg.sender] = totalSupply;\n    }\n\n    /**\n     * @dev transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(amount <= balances[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the the balance of.\n     * @return balance An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param amount uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        balances[from] = balances[from].sub(amount);\n        balances[to] = balances[to].add(amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n}\n"
    },
    "contracts/DODOToken/Governance.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\npragma solidity 0.6.9;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {SafeMath} from \"../lib/SafeMath.sol\";\n\ninterface IVDODOMine {\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract Governance is InitializableOwnable {\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n    address[] public _VDODO_MINE_LIST_;\n\n\n    // ============ Event =============\n    event AddMineContract(address mineContract);\n    event RemoveMineContract(address mineContract);\n\n\n    function getLockedvDODO(address account) external view returns (uint256 lockedvDODO) {\n        uint256 len = _VDODO_MINE_LIST_.length;\n        for(uint i = 0; i < len; i++){\n            uint256 curLocked = IVDODOMine(_VDODO_MINE_LIST_[i]).balanceOf(account);\n            lockedvDODO = lockedvDODO.add(curLocked);\n        }\n    }\n\n    // =============== Ownable  ================\n\n    function addMineContract(address[] memory mineContracts) external onlyOwner {\n        for(uint i = 0; i < mineContracts.length; i++){\n            require(mineContracts[i] != address(0),\"ADDRESS_INVALID\");\n            _VDODO_MINE_LIST_.push(mineContracts[i]);\n            emit AddMineContract(mineContracts[i]);\n        }\n    }\n\n    function removeMineContract(address mineContract) external onlyOwner {\n        uint256 len = _VDODO_MINE_LIST_.length;\n        for (uint256 i = 0; i < len; i++) {\n            if (mineContract == _VDODO_MINE_LIST_[i]) {\n                _VDODO_MINE_LIST_[i] = _VDODO_MINE_LIST_[len - 1];\n                _VDODO_MINE_LIST_.pop();\n                emit RemoveMineContract(mineContract);\n                break;\n            }\n        }\n    }\n}\n"
    },
    "contracts/DODOToken/LockedTokenVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../lib/DecimalMath.sol\";\nimport {Ownable} from \"../lib/Ownable.sol\";\nimport {SafeERC20} from \"../lib/SafeERC20.sol\";\nimport {IERC20} from \"../intf/IERC20.sol\";\n\n/**\n * @title LockedTokenVault\n * @author DODO Breeder\n *\n * @notice Lock Token and release it linearly\n */\n\ncontract LockedTokenVault is Ownable {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    address public immutable _TOKEN_;\n\n    mapping(address => uint256) internal originBalances;\n    mapping(address => uint256) internal claimedBalances;\n\n    uint256 public _UNDISTRIBUTED_AMOUNT_;\n    uint256 public _START_RELEASE_TIME_;\n    uint256 public _RELEASE_DURATION_;\n    uint256 public _CLIFF_RATE_;\n\n    bool public _DISTRIBUTE_FINISHED_;\n\n    // ============ Events ============\n\n    event Claim(address indexed holder, uint256 origin, uint256 claimed, uint256 amount);\n\n    // ============ Modifiers ============\n\n    modifier beforeStartRelease() {\n        require(block.timestamp < _START_RELEASE_TIME_, \"RELEASE START\");\n        _;\n    }\n\n    modifier afterStartRelease() {\n        require(block.timestamp >= _START_RELEASE_TIME_, \"RELEASE NOT START\");\n        _;\n    }\n\n    modifier distributeNotFinished() {\n        require(!_DISTRIBUTE_FINISHED_, \"DISTRIBUTE FINISHED\");\n        _;\n    }\n\n    // ============ Init Functions ============\n\n    constructor(\n        address _token,\n        uint256 _startReleaseTime,\n        uint256 _releaseDuration,\n        uint256 _cliffRate\n    ) public {\n        _TOKEN_ = _token;\n        _START_RELEASE_TIME_ = _startReleaseTime;\n        _RELEASE_DURATION_ = _releaseDuration;\n        _CLIFF_RATE_ = _cliffRate;\n    }\n\n    function deposit(uint256 amount) external onlyOwner {\n        _tokenTransferIn(_OWNER_, amount);\n        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.add(amount);\n    }\n\n    function withdraw(uint256 amount) external onlyOwner {\n        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.sub(amount);\n        _tokenTransferOut(_OWNER_, amount);\n    }\n\n    function finishDistribute() external onlyOwner {\n        _DISTRIBUTE_FINISHED_ = true;\n    }\n\n    // ============ For Owner ============\n\n    function grant(address[] calldata holderList, uint256[] calldata amountList)\n        external\n        onlyOwner\n    {\n        require(holderList.length == amountList.length, \"batch grant length not match\");\n        uint256 amount = 0;\n        for (uint256 i = 0; i < holderList.length; ++i) {\n            // for saving gas, no event for grant\n            originBalances[holderList[i]] = originBalances[holderList[i]].add(amountList[i]);\n            amount = amount.add(amountList[i]);\n        }\n        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.sub(amount);\n    }\n\n    function recall(address holder) external onlyOwner distributeNotFinished {\n        _UNDISTRIBUTED_AMOUNT_ = _UNDISTRIBUTED_AMOUNT_.add(originBalances[holder]).sub(\n            claimedBalances[holder]\n        );\n        originBalances[holder] = 0;\n        claimedBalances[holder] = 0;\n    }\n\n    // ============ For Holder ============\n\n    function transferLockedToken(address to) external {\n        require(to != msg.sender, \"INVALID_TO_ADDRESS\");\n        originBalances[to] = originBalances[to].add(originBalances[msg.sender]);\n        claimedBalances[to] = claimedBalances[to].add(claimedBalances[msg.sender]);\n\n        originBalances[msg.sender] = 0;\n        claimedBalances[msg.sender] = 0;\n    }\n\n    function claim() external {\n        uint256 claimableToken = getClaimableBalance(msg.sender);\n        _tokenTransferOut(msg.sender, claimableToken);\n        claimedBalances[msg.sender] = claimedBalances[msg.sender].add(claimableToken);\n        emit Claim(\n            msg.sender,\n            originBalances[msg.sender],\n            claimedBalances[msg.sender],\n            claimableToken\n        );\n    }\n\n    // ============ View ============\n\n    function isReleaseStart() external view returns (bool) {\n        return block.timestamp >= _START_RELEASE_TIME_;\n    }\n\n    function getOriginBalance(address holder) external view returns (uint256) {\n        return originBalances[holder];\n    }\n\n    function getClaimedBalance(address holder) external view returns (uint256) {\n        return claimedBalances[holder];\n    }\n\n    function getClaimableBalance(address holder) public view returns (uint256) {\n        uint256 remainingToken = getRemainingBalance(holder);\n        return originBalances[holder].sub(remainingToken).sub(claimedBalances[holder]);\n    }\n\n    function getRemainingBalance(address holder) public view returns (uint256) {\n        uint256 remainingRatio = getRemainingRatio(block.timestamp);\n        return DecimalMath.mulFloor(originBalances[holder], remainingRatio);\n    }\n\n    function getRemainingRatio(uint256 timestamp) public view returns (uint256) {\n        if (timestamp < _START_RELEASE_TIME_) {\n            return DecimalMath.ONE;\n        }\n        uint256 timePast = timestamp.sub(_START_RELEASE_TIME_);\n        if (timePast < _RELEASE_DURATION_) {\n            uint256 remainingTime = _RELEASE_DURATION_.sub(timePast);\n            return DecimalMath.ONE.sub(_CLIFF_RATE_).mul(remainingTime).div(_RELEASE_DURATION_);\n        } else {\n            return 0;\n        }\n    }\n\n    // ============ Internal Helper ============\n\n    function _tokenTransferIn(address from, uint256 amount) internal {\n        IERC20(_TOKEN_).safeTransferFrom(from, address(this), amount);\n    }\n\n    function _tokenTransferOut(address to, uint256 amount) internal {\n        IERC20(_TOKEN_).safeTransfer(to, amount);\n    }\n}\n"
    },
    "contracts/DODOToken/vDODOToken.sol": {
      "content": "/*\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n*/\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"../intf/IERC20.sol\";\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../lib/DecimalMath.sol\";\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {SafeERC20} from \"../lib/SafeERC20.sol\";\nimport {IDODOApproveProxy} from \"../SmartRoute/DODOApproveProxy.sol\";\n\ninterface IGovernance {\n    function getLockedvDODO(address account) external view returns (uint256);\n}\n\ninterface IDODOCirculationHelper {\n    // Locked vDOOD not counted in circulation\n    function getCirculation() external view returns (uint256);\n\n    function getDodoWithdrawFeeRatio() external view returns (uint256);\n}\n\ncontract vDODOToken is InitializableOwnable {\n    using SafeMath for uint256;\n\n    // ============ Storage(ERC20) ============\n\n    string public name = \"vDODO Membership Token\";\n    string public symbol = \"vDODO\";\n    uint8 public decimals = 18;\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\n\n    // ============ Storage ============\n\n    address public immutable _DODO_TOKEN_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _DODO_TEAM_;\n    address public _DOOD_GOV_;\n    address public _DODO_CIRCULATION_HELPER_;\n\n    bool public _CAN_TRANSFER_;\n\n    // staking reward parameters\n    uint256 public _DODO_PER_BLOCK_;\n    uint256 public constant _SUPERIOR_RATIO_ = 10**17; // 0.1\n    uint256 public constant _DODO_RATIO_ = 100; // 100\n    uint256 public _DODO_FEE_BURN_RATIO_;\n\n    // accounting\n    uint112 public alpha = 10**18; // 1\n    uint112 public _TOTAL_BLOCK_DISTRIBUTION_;\n    uint32 public _LAST_REWARD_BLOCK_;\n\n    uint256 public _TOTAL_BLOCK_REWARD_;\n    uint256 public _TOTAL_STAKING_POWER_;\n    mapping(address => UserInfo) public userInfo;\n\n    struct UserInfo {\n        uint128 stakingPower;\n        uint128 superiorSP;\n        address superior;\n        uint256 credit;\n    }\n\n    // ============ Events ============\n\n    event MintVDODO(address user, address superior, uint256 mintDODO);\n    event RedeemVDODO(address user, uint256 receiveDODO, uint256 burnDODO, uint256 feeDODO);\n    event DonateDODO(address user, uint256 donateDODO);\n    event SetCantransfer(bool allowed);\n\n    event PreDeposit(uint256 dodoAmount);\n    event ChangePerReward(uint256 dodoPerBlock);\n    event UpdateDODOFeeBurnRatio(uint256 dodoFeeBurnRatio);\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    // ============ Modifiers ============\n\n    modifier canTransfer() {\n        require(_CAN_TRANSFER_, \"vDODOToken: not allowed transfer\");\n        _;\n    }\n\n    modifier balanceEnough(address account, uint256 amount) {\n        require(availableBalanceOf(account) >= amount, \"vDODOToken: available amount not enough\");\n        _;\n    }\n\n    // ============ Constructor ============\n\n    constructor(\n        address dodoGov,\n        address dodoToken,\n        address dodoApproveProxy,\n        address dodoTeam\n    ) public {\n        _DOOD_GOV_ = dodoGov;\n        _DODO_TOKEN_ = dodoToken;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n        _DODO_TEAM_ = dodoTeam;\n    }\n\n    // ============ Ownable Functions ============`\n\n    function setCantransfer(bool allowed) public onlyOwner {\n        _CAN_TRANSFER_ = allowed;\n        emit SetCantransfer(allowed);\n    }\n\n    function changePerReward(uint256 dodoPerBlock) public onlyOwner {\n        _updateAlpha();\n        _DODO_PER_BLOCK_ = dodoPerBlock;\n        emit ChangePerReward(dodoPerBlock);\n    }\n\n    function updateDODOFeeBurnRatio(uint256 dodoFeeBurnRatio) public onlyOwner {\n        _DODO_FEE_BURN_RATIO_ = dodoFeeBurnRatio;\n        emit UpdateDODOFeeBurnRatio(_DODO_FEE_BURN_RATIO_);\n    }\n\n    function updateDODOCirculationHelper(address helper) public onlyOwner {\n        _DODO_CIRCULATION_HELPER_ = helper;\n    }\n\n    function updateGovernance(address governance) public onlyOwner {\n        _DOOD_GOV_ = governance;\n    }\n\n    function emergencyWithdraw() public onlyOwner {\n        uint256 dodoBalance = IERC20(_DODO_TOKEN_).balanceOf(address(this));\n        IERC20(_DODO_TOKEN_).transfer(_OWNER_, dodoBalance);\n    }\n\n    // ============ Mint & Redeem & Donate ============\n\n    function mint(uint256 dodoAmount, address superiorAddress) public {\n        require(\n            superiorAddress != address(0) && superiorAddress != msg.sender,\n            \"vDODOToken: Superior INVALID\"\n        );\n        require(dodoAmount > 0, \"vDODOToken: must mint greater than 0\");\n\n        UserInfo storage user = userInfo[msg.sender];\n\n        if (user.superior == address(0)) {\n            require(\n                superiorAddress == _DODO_TEAM_ || userInfo[superiorAddress].superior != address(0),\n                \"vDODOToken: INVALID_SUPERIOR_ADDRESS\"\n            );\n            user.superior = superiorAddress;\n        }\n\n        _updateAlpha();\n\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n            _DODO_TOKEN_,\n            msg.sender,\n            address(this),\n            dodoAmount\n        );\n\n        uint256 newStakingPower = DecimalMath.divFloor(dodoAmount, alpha);\n\n        _mint(user, newStakingPower);\n\n        emit MintVDODO(msg.sender, superiorAddress, dodoAmount);\n    }\n\n    function redeem(uint256 vdodoAmount, bool all) public balanceEnough(msg.sender, vdodoAmount) {\n        _updateAlpha();\n        UserInfo storage user = userInfo[msg.sender];\n\n        uint256 dodoAmount;\n        uint256 stakingPower;\n\n        if (all) {\n            stakingPower = uint256(user.stakingPower).sub(DecimalMath.divFloor(user.credit, alpha));\n            dodoAmount = DecimalMath.mulFloor(stakingPower, alpha);\n        } else {\n            dodoAmount = vdodoAmount.mul(_DODO_RATIO_);\n            stakingPower = DecimalMath.divFloor(dodoAmount, alpha);\n        }\n\n        _redeem(user, stakingPower);\n\n        (uint256 dodoReceive, uint256 burnDodoAmount, uint256 withdrawFeeDodoAmount) = getWithdrawResult(dodoAmount);\n\n        IERC20(_DODO_TOKEN_).transfer(msg.sender, dodoReceive);\n        \n        if (burnDodoAmount > 0) {\n            IERC20(_DODO_TOKEN_).transfer(address(0), burnDodoAmount);\n        }\n        \n        if (withdrawFeeDodoAmount > 0) {\n            alpha = uint112(\n                uint256(alpha).add(\n                    DecimalMath.divFloor(withdrawFeeDodoAmount, _TOTAL_STAKING_POWER_)\n                )\n            );\n        }\n\n        emit RedeemVDODO(msg.sender, dodoReceive, burnDodoAmount, withdrawFeeDodoAmount);\n    }\n\n    function donate(uint256 dodoAmount) public {\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n            _DODO_TOKEN_,\n            msg.sender,\n            address(this),\n            dodoAmount\n        );\n        alpha = uint112(\n            uint256(alpha).add(DecimalMath.divFloor(dodoAmount, _TOTAL_STAKING_POWER_))\n        );\n        emit DonateDODO(msg.sender, dodoAmount);\n    }\n\n    function preDepositedBlockReward(uint256 dodoAmount) public {\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n            _DODO_TOKEN_,\n            msg.sender,\n            address(this),\n            dodoAmount\n        );\n        _TOTAL_BLOCK_REWARD_ = _TOTAL_BLOCK_REWARD_.add(dodoAmount);\n        emit PreDeposit(dodoAmount);\n    }\n\n    // ============ ERC20 Functions ============\n\n    function totalSupply() public view returns (uint256 vDODOSupply) {\n        uint256 totalDODO = IERC20(_DODO_TOKEN_).balanceOf(address(this));\n        (,uint256 curDistribution) = getLatestAlpha();\n        uint256 actualDODO = totalDODO.sub(_TOTAL_BLOCK_REWARD_.sub(curDistribution.add(_TOTAL_BLOCK_DISTRIBUTION_)));\n        vDODOSupply = actualDODO / _DODO_RATIO_;\n    }\n    \n    function balanceOf(address account) public view returns (uint256 vDODOAmount) {\n        vDODOAmount = dodoBalanceOf(account) / _DODO_RATIO_;\n    }\n\n    function transfer(address to, uint256 vDODOAmount) public returns (bool) {\n        _updateAlpha();\n        _transfer(msg.sender, to, vDODOAmount);\n        return true;\n    }\n\n    function approve(address spender, uint256 vDODOAmount) canTransfer public returns (bool) {\n        _ALLOWED_[msg.sender][spender] = vDODOAmount;\n        emit Approval(msg.sender, spender, vDODOAmount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 vDODOAmount\n    ) public returns (bool) {\n        require(vDODOAmount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n        _updateAlpha();\n        _transfer(from, to, vDODOAmount);\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(vDODOAmount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _ALLOWED_[owner][spender];\n    }\n\n    // ============ Helper Functions ============\n\n    function getLatestAlpha() public view returns (uint256 newAlpha, uint256 curDistribution) {\n        if (_LAST_REWARD_BLOCK_ == 0) {\n            curDistribution = 0;\n        } else {\n            curDistribution = _DODO_PER_BLOCK_ * (block.number - _LAST_REWARD_BLOCK_);\n        }\n        if (_TOTAL_STAKING_POWER_ > 0) {\n            newAlpha = uint256(alpha).add(DecimalMath.divFloor(curDistribution, _TOTAL_STAKING_POWER_));\n        } else {\n            newAlpha = alpha;\n        }\n    }\n\n    function availableBalanceOf(address account) public view returns (uint256 vDODOAmount) {\n        if (_DOOD_GOV_ == address(0)) {\n            vDODOAmount = balanceOf(account);\n        } else {\n            uint256 lockedvDODOAmount = IGovernance(_DOOD_GOV_).getLockedvDODO(account);\n            vDODOAmount = balanceOf(account).sub(lockedvDODOAmount);\n        }\n    }\n\n    function dodoBalanceOf(address account) public view returns (uint256 dodoAmount) {\n        UserInfo memory user = userInfo[account];\n        (uint256 newAlpha,) = getLatestAlpha();\n        uint256 nominalDodo =  DecimalMath.mulFloor(uint256(user.stakingPower), newAlpha);\n        if(nominalDodo > user.credit) {\n            dodoAmount = nominalDodo - user.credit;\n        }else {\n            dodoAmount = 0;\n        }\n    }\n\n    function getWithdrawResult(uint256 dodoAmount)\n        public\n        view\n        returns (\n            uint256 dodoReceive,\n            uint256 burnDodoAmount,\n            uint256 withdrawFeeDodoAmount\n        )\n    {\n        uint256 feeRatio =\n            IDODOCirculationHelper(_DODO_CIRCULATION_HELPER_).getDodoWithdrawFeeRatio();\n\n        withdrawFeeDodoAmount = DecimalMath.mulFloor(dodoAmount, feeRatio);\n        dodoReceive = dodoAmount.sub(withdrawFeeDodoAmount);\n\n        burnDodoAmount = DecimalMath.mulFloor(withdrawFeeDodoAmount, _DODO_FEE_BURN_RATIO_);\n        withdrawFeeDodoAmount = withdrawFeeDodoAmount.sub(burnDodoAmount);\n    }\n\n    function getDODOWithdrawFeeRatio() public view returns (uint256 feeRatio) {\n        feeRatio = IDODOCirculationHelper(_DODO_CIRCULATION_HELPER_).getDodoWithdrawFeeRatio();\n    }\n\n    function getSuperior(address account) public view returns (address superior) {\n        return userInfo[account].superior;\n    }\n\n    // ============ Internal Functions ============\n\n    function _updateAlpha() internal {\n        (uint256 newAlpha, uint256 curDistribution) = getLatestAlpha();\n        uint256 newTotalDistribution = curDistribution.add(_TOTAL_BLOCK_DISTRIBUTION_);\n        require(newAlpha <= uint112(-1) && newTotalDistribution <= uint112(-1), \"OVERFLOW\");\n        alpha = uint112(newAlpha);\n        _TOTAL_BLOCK_DISTRIBUTION_ = uint112(newTotalDistribution);\n        _LAST_REWARD_BLOCK_ = uint32(block.number);\n    }\n\n    function _mint(UserInfo storage to, uint256 stakingPower) internal {\n        require(stakingPower <= uint128(-1), \"OVERFLOW\");\n        UserInfo storage superior = userInfo[to.superior];\n        uint256 superiorIncreSP = DecimalMath.mulFloor(stakingPower, _SUPERIOR_RATIO_);\n        uint256 superiorIncreCredit = DecimalMath.mulFloor(superiorIncreSP, alpha);\n\n        to.stakingPower = uint128(uint256(to.stakingPower).add(stakingPower));\n        to.superiorSP = uint128(uint256(to.superiorSP).add(superiorIncreSP));\n\n        superior.stakingPower = uint128(uint256(superior.stakingPower).add(superiorIncreSP));\n        superior.credit = uint128(uint256(superior.credit).add(superiorIncreCredit));\n\n        _TOTAL_STAKING_POWER_ = _TOTAL_STAKING_POWER_.add(stakingPower).add(superiorIncreSP);\n    }\n\n    function _redeem(UserInfo storage from, uint256 stakingPower) internal {\n        from.stakingPower = uint128(uint256(from.stakingPower).sub(stakingPower));\n\n        // superior decrease sp = min(stakingPower*0.1, from.superiorSP)\n        uint256 superiorDecreSP = DecimalMath.mulFloor(stakingPower, _SUPERIOR_RATIO_);\n        superiorDecreSP = from.superiorSP <= superiorDecreSP ? from.superiorSP : superiorDecreSP;\n        from.superiorSP = uint128(uint256(from.superiorSP).sub(superiorDecreSP));\n\n        UserInfo storage superior = userInfo[from.superior];\n        uint256 creditSP = DecimalMath.divFloor(superior.credit, alpha);\n\n        if (superiorDecreSP >= creditSP) {\n            superior.credit = 0;\n            superior.stakingPower = uint128(uint256(superior.stakingPower).sub(creditSP));\n        } else {\n            superior.credit = uint128(\n                uint256(superior.credit).sub(DecimalMath.mulFloor(superiorDecreSP, alpha))\n            );\n            superior.stakingPower = uint128(uint256(superior.stakingPower).sub(superiorDecreSP));\n        }\n\n        _TOTAL_STAKING_POWER_ = _TOTAL_STAKING_POWER_.sub(stakingPower).sub(superiorDecreSP);\n    }\n\n    function _transfer(\n        address from,\n        address to,\n        uint256 vDODOAmount\n    ) internal canTransfer balanceEnough(from, vDODOAmount) {\n        require(from != address(0), \"transfer from the zero address\");\n        require(to != address(0), \"transfer to the zero address\");\n        require(from != to, \"transfer from same with to\");\n\n        uint256 stakingPower = DecimalMath.divFloor(vDODOAmount * _DODO_RATIO_, alpha);\n\n        UserInfo storage fromUser = userInfo[from];\n        UserInfo storage toUser = userInfo[to];\n\n        _redeem(fromUser, stakingPower);\n        _mint(toUser, stakingPower);\n\n        emit Transfer(from, to, vDODOAmount);\n    }\n}"
    },
    "contracts/DODOVendingMachine/impl/DVM.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {DVMTrader} from \"./DVMTrader.sol\";\nimport {DVMFunding} from \"./DVMFunding.sol\";\nimport {DVMVault} from \"./DVMVault.sol\";\n\n/**\n * @title DODO VendingMachine\n * @author DODO Breeder\n *\n * @notice DODOVendingMachine initialization\n */\ncontract DVM is DVMTrader, DVMFunding {\n    function init(\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external {\n        require(!_DVM_INITIALIZED_, \"DVM_INITIALIZED\");\n        _DVM_INITIALIZED_ = true;\n        \n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        require(i > 0 && i <= 10**36);\n        _I_ = i;\n\n        require(k <= 10**18);\n        _K_ = k;\n\n        _LP_FEE_RATE_ = lpFeeRate;\n        _MT_FEE_RATE_MODEL_ = IFeeRateModel(mtFeeRateModel);\n        _MAINTAINER_ = maintainer;\n\n        _IS_OPEN_TWAP_ = isOpenTWAP;\n        if(isOpenTWAP) _BLOCK_TIMESTAMP_LAST_ = uint32(block.timestamp % 2**32);\n\n        string memory connect = \"_\";\n        string memory suffix = \"DLP\";\n\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\n        symbol = \"DLP\";\n        decimals = _BASE_TOKEN_.decimals();\n\n        // ============================== Permit ====================================\n        uint256 chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                chainId,\n                address(this)\n            )\n        );\n        // ==========================================================================\n    }\n\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(_addr));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n\n    // ============ Version Control ============\n    \n    function version() external pure returns (string memory) {\n        return \"DVM 1.0.2\";\n    }\n}\n"
    },
    "contracts/DODOVendingMachine/impl/DVMFunding.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DVMVault} from \"./DVMVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\ncontract DVMFunding is DVMVault {\n    // ============ Events ============\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n\n    // ============ Buy & Sell Shares ============\n\n    // buy shares [round down]\n    function buyShares(address to)\n        external\n        preventReentrant\n        returns (\n            uint256 shares,\n            uint256 baseInput,\n            uint256 quoteInput\n        )\n    {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        baseInput = baseBalance.sub(baseReserve);\n        quoteInput = quoteBalance.sub(quoteReserve);\n        require(baseInput > 0, \"NO_BASE_INPUT\");\n\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n        // But May Happen，reserve >0 But totalSupply = 0\n        if (totalSupply == 0) {\n            // case 1. initial supply\n            shares = baseBalance; // 以免出现balance很大但shares很小的情况\n            require(shares > 2001, \"MINT_AMOUNT_NOT_ENOUGH\");\n            _mint(address(0), 1001);\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve == 0) {\n            // case 2. supply when quote reserve is 0\n            shares = baseInput.mul(totalSupply).div(baseReserve);\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 3. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n        }\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n        emit BuyShares(to, shares, _SHARES_[to]);\n    }\n\n    // sell shares [round down]\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external preventReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\n        require(shareAmount <= _SHARES_[msg.sender], \"DLP_NOT_ENOUGH\");\n        require(to != address(this), \"SELL_BACK_NOT_ALLOWED\");\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 totalShares = totalSupply;\n\n        baseAmount = baseBalance.mul(shareAmount).div(totalShares);\n        quoteAmount = quoteBalance.mul(shareAmount).div(totalShares);\n\n        require(\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\n            \"WITHDRAW_NOT_ENOUGH\"\n        );\n\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        if (data.length > 0) {\n            IDODOCallee(to).DVMSellShareCall(\n                msg.sender,\n                shareAmount,\n                baseAmount,\n                quoteAmount,\n                data\n            );\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\n    }\n}\n"
    },
    "contracts/DODOVendingMachine/impl/DVMStorage.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DODOMath} from \"../../lib/DODOMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IFeeRateModel} from \"../../lib/FeeRateModel.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\n\ncontract DVMStorage is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    bool public _IS_OPEN_TWAP_ = false;\n\n    bool internal _DVM_INITIALIZED_;\n\n    // ============ Core Address ============\n\n    address public _MAINTAINER_;\n\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n\n    // ============ Shares (ERC20) ============\n\n    string public symbol;\n    uint8 public decimals;\n    string public name;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) internal _SHARES_;\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\n\n    // ================= Permit ======================\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    // ============ Variables for Pricing ============\n\n    uint256 public _LP_FEE_RATE_;\n    IFeeRateModel public _MT_FEE_RATE_MODEL_;\n    uint256 public _K_;\n    uint256 public _I_;\n\n\n    // ============ Helper Functions ============\n\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = 0; // will be calculated in adjustedTarget\n        state.Q0 = 0;\n        state.R = PMMPricing.RState.ABOVE_ONE;\n        PMMPricing.adjustedTarget(state);\n    }\n\n    function getPMMStateForCall() \n        external \n        view \n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n}\n"
    },
    "contracts/DODOVendingMachine/impl/DVMTrader.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {DVMVault} from \"./DVMVault.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {DODOMath} from \"../../lib/DODOMath.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\n\ncontract DVMTrader is DVMVault {\n    using SafeMath for uint256;\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(\n        address borrower,\n        address assetTo,\n        uint256 baseAmount,\n        uint256 quoteAmount\n    );\n\n    // ============ Trade Functions ============\n\n    function sellBase(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveQuoteAmount)\n    {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n        uint256 mtFee;\n        (receiveQuoteAmount, mtFee) = querySellBase(tx.origin, baseInput);\n\n        _transferQuoteOut(to, receiveQuoteAmount);\n        _transferQuoteOut(_MAINTAINER_, mtFee);\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)));\n\n        emit DODOSwap(\n            address(_BASE_TOKEN_),\n            address(_QUOTE_TOKEN_),\n            baseInput,\n            receiveQuoteAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function sellQuote(address to)\n        external\n        preventReentrant\n        returns (uint256 receiveBaseAmount)\n    {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n        uint256 mtFee;\n        (receiveBaseAmount, mtFee) = querySellQuote(tx.origin, quoteInput);\n\n        _transferBaseOut(to, receiveBaseAmount);\n        _transferBaseOut(_MAINTAINER_, mtFee);\n        _setReserve(_BASE_TOKEN_.balanceOf(address(this)), quoteBalance);\n\n        emit DODOSwap(\n            address(_QUOTE_TOKEN_),\n            address(_BASE_TOKEN_),\n            quoteInput,\n            receiveBaseAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external preventReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0)\n            IDODOCallee(assetTo).DVMFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        \n        // no input -> pure loss\n        require(\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n            \"FLASH_LOAN_FAILED\"\n        );\n\n        // sell quote\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance.sub(uint256(_QUOTE_RESERVE_));\n            (uint256 receiveBaseAmount, uint256 mtFee) = querySellQuote(tx.origin, quoteInput);\n            require(uint256(_BASE_RESERVE_).sub(baseBalance) <= receiveBaseAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferBaseOut(_MAINTAINER_, mtFee);\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance.sub(uint256(_BASE_RESERVE_));\n            (uint256 receiveQuoteAmount, uint256 mtFee) = querySellBase(tx.origin, baseInput);\n            require(uint256(_QUOTE_RESERVE_).sub(quoteBalance) <= receiveQuoteAmount, \"FLASH_LOAN_FAILED\");\n\n            _transferQuoteOut(_MAINTAINER_, mtFee);\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n        \n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n\n    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (uint256 receiveQuoteAmount, uint256 mtFee)\n    {\n        (receiveQuoteAmount, ) = PMMPricing.sellBaseToken(getPMMState(), payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount\n            .sub(DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate))\n            .sub(mtFee);\n    }\n\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (uint256 receiveBaseAmount, uint256 mtFee)\n    {\n        (receiveBaseAmount, ) = PMMPricing.sellQuoteToken(getPMMState(), payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(trader);\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount\n            .sub(DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate))\n            .sub(mtFee);\n    }\n}\n"
    },
    "contracts/DODOVendingMachine/impl/DVMVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {DVMStorage} from \"./DVMStorage.sol\";\n\ncontract DVMVault is DVMStorage {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Events ============\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event Mint(address indexed user, uint256 value);\n\n    event Burn(address indexed user, uint256 value);\n\n    // ============ View Functions ============\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate) {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_MODEL_.getFeeRate(user);\n    }\n\n    // ============ Asset In ============\n\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)).sub(uint256(_BASE_RESERVE_));\n    }\n\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)).sub(uint256(_QUOTE_RESERVE_));\n    }\n\n    // ============ TWAP UPDATE ===========\n    \n    function _twapUpdate() internal {\n        uint32 blockTimestamp = uint32(block.timestamp % 2**32);\n        uint32 timeElapsed = blockTimestamp - _BLOCK_TIMESTAMP_LAST_;\n        if (timeElapsed > 0 && _BASE_RESERVE_ != 0 && _QUOTE_RESERVE_ != 0) {\n            _BASE_PRICE_CUMULATIVE_LAST_ += getMidPrice() * timeElapsed;\n        }\n        _BLOCK_TIMESTAMP_LAST_ = blockTimestamp;\n    }\n\n    // ============ Set States ============\n\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        require(baseReserve <= uint112(-1) && quoteReserve <= uint112(-1), \"OVERFLOW\");\n        _BASE_RESERVE_ = uint112(baseReserve);\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this));\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this));\n        require(baseBalance <= uint112(-1) && quoteBalance <= uint112(-1), \"OVERFLOW\");\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n\n        if(_IS_OPEN_TWAP_) _twapUpdate();\n    }\n\n\n    function sync() external preventReentrant {\n        _sync();\n    }\n\n    // ============ Asset Out ============\n\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    // ============ Shares (ERC20) ============\n\n    /**\n     * @dev transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        _SHARES_[msg.sender] = _SHARES_[msg.sender].sub(amount);\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the the balance of.\n     * @return balance An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        return _SHARES_[owner];\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param amount uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        _SHARES_[from] = _SHARES_[from].sub(amount);\n        _SHARES_[to] = _SHARES_[to].add(amount);\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        _ALLOWED_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _ALLOWED_[owner][spender];\n    }\n\n    function _mint(address user, uint256 value) internal {\n        require(value > 1000, \"MINT_INVALID\");\n        _SHARES_[user] = _SHARES_[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        _SHARES_[user] = _SHARES_[user].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n\n    // ============================ Permit ======================================\n    \n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"DODO_DVM_LP: EXPIRED\");\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                DOMAIN_SEPARATOR,\n                keccak256(\n                    abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)\n                )\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"DODO_DVM_LP: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/DODOVendingMachine/intf/IDVM.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDVM {\n    function init(\n        address maintainer,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        address mtFeeRateModel,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external;\n\n    function _BASE_TOKEN_() external returns (address);\n\n    function _QUOTE_TOKEN_() external returns (address);\n\n    function _MT_FEE_RATE_MODEL_() external returns (address);\n\n    function getVaultReserve() external returns (uint256 baseReserve, uint256 quoteReserve);\n\n    function sellBase(address to) external returns (uint256);\n\n    function sellQuote(address to) external returns (uint256);\n\n    function buyShares(address to) external returns (uint256,uint256,uint256);\n\n    function addressToShortString(address _addr) external pure returns (string memory);\n\n    function getMidPrice() external view returns (uint256 midPrice);\n\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external  returns (uint256 baseAmount, uint256 quoteAmount);\n\n}\n"
    },
    "contracts/external/ERC20/CustomERC20.sol": {
      "content": "/*\n\n    Copyright 2022 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\n\ncontract CustomERC20 is InitializableOwnable {\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public totalSupply;\n\n    uint256 public tradeBurnRatio;\n    uint256 public tradeFeeRatio;\n    address public team;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event ChangeTeam(address oldTeam, address newTeam);\n\n\n    function init(\n        address _creator,\n        uint256 _totalSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _tradeBurnRatio,\n        uint256 _tradeFeeRatio,\n        address _team\n    ) public {\n        initOwner(_creator);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _totalSupply;\n        balances[_creator] = _totalSupply;\n        require(_tradeBurnRatio >= 0 && _tradeBurnRatio <= 5000, \"TRADE_BURN_RATIO_INVALID\");\n        require(_tradeFeeRatio >= 0 && _tradeFeeRatio <= 5000, \"TRADE_FEE_RATIO_INVALID\");\n        tradeBurnRatio = _tradeBurnRatio;\n        tradeFeeRatio = _tradeFeeRatio;\n        team = _team;\n        emit Transfer(address(0), _creator, _totalSupply);\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        _transfer(msg.sender,to,amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n        _transfer(from,to,amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        balances[sender] = balances[sender].sub(amount);\n\n        uint256 burnAmount;\n        uint256 feeAmount;\n        if(tradeBurnRatio > 0) {\n            burnAmount = amount.mul(tradeBurnRatio).div(10000);\n            balances[address(0)] = balances[address(0)].add(burnAmount);\n            emit Transfer(sender, address(0), burnAmount);\n        }\n\n        if(tradeFeeRatio > 0) {\n            feeAmount = amount.mul(tradeFeeRatio).div(10000);\n            balances[team] = balances[team].add(feeAmount);\n            emit Transfer(sender, team, feeAmount);\n        }\n        \n        uint256 receiveAmount = amount.sub(burnAmount).sub(feeAmount);\n        balances[recipient] = balances[recipient].add(receiveAmount);\n\n        emit Transfer(sender, recipient, receiveAmount);\n    }\n\n\n    //=================== Ownable ======================\n    function changeTeamAccount(address newTeam) external onlyOwner {\n        require(tradeFeeRatio > 0, \"NOT_TRADE_FEE_TOKEN\");\n        emit ChangeTeam(team,newTeam);\n        team = newTeam;\n    }\n\n    function abandonOwnership(address zeroAddress) external onlyOwner {\n        require(zeroAddress == address(0), \"NOT_ZERO_ADDRESS\");\n        emit OwnershipTransferred(_OWNER_, address(0));\n        _OWNER_ = address(0);\n    }\n}\n"
    },
    "contracts/external/ERC20/CustomMintableERC20.sol": {
      "content": "/*\n\n    Copyright 2022 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\n\ncontract CustomMintableERC20 is InitializableOwnable {\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public totalSupply;\n\n    uint256 public tradeBurnRatio;\n    uint256 public tradeFeeRatio;\n    address public team;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Mint(address indexed user, uint256 value);\n    event Burn(address indexed user, uint256 value);\n\n    event ChangeTeam(address oldTeam, address newTeam);\n\n\n    function init(\n        address _creator,\n        uint256 _initSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _tradeBurnRatio,\n        uint256 _tradeFeeRatio,\n        address _team\n    ) public {\n        initOwner(_creator);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _initSupply;\n        balances[_creator] = _initSupply;\n        require(_tradeBurnRatio >= 0 && _tradeBurnRatio <= 5000, \"TRADE_BURN_RATIO_INVALID\");\n        require(_tradeFeeRatio >= 0 && _tradeFeeRatio <= 5000, \"TRADE_FEE_RATIO_INVALID\");\n        tradeBurnRatio = _tradeBurnRatio;\n        tradeFeeRatio = _tradeFeeRatio;\n        team = _team;\n        emit Transfer(address(0), _creator, _initSupply);\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        _transfer(msg.sender,to,amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n        _transfer(from,to,amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(balances[sender] >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        balances[sender] = balances[sender].sub(amount);\n\n        uint256 burnAmount;\n        uint256 feeAmount;\n        if(tradeBurnRatio > 0) {\n            burnAmount = amount.mul(tradeBurnRatio).div(10000);\n            balances[address(0)] = balances[address(0)].add(burnAmount);\n            emit Transfer(sender, address(0), burnAmount);\n        }\n\n        if(tradeFeeRatio > 0) {\n            feeAmount = amount.mul(tradeFeeRatio).div(10000);\n            balances[team] = balances[team].add(feeAmount);\n            emit Transfer(sender, team, feeAmount);\n        }\n        \n        uint256 receiveAmount = amount.sub(burnAmount).sub(feeAmount);\n        balances[recipient] = balances[recipient].add(receiveAmount);\n\n        emit Transfer(sender, recipient, receiveAmount);\n    }\n\n    function burn(uint256 value) external {\n        require(balances[msg.sender] >= value, \"VALUE_NOT_ENOUGH\");\n\n        balances[msg.sender] = balances[msg.sender].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(msg.sender, value);\n        emit Transfer(msg.sender, address(0), value);\n    }\n\n    //=================== Ownable ======================\n    function mint(address user, uint256 value) external onlyOwner {\n        require(user == _OWNER_, \"NOT_OWNER\");\n        \n        balances[user] = balances[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function changeTeamAccount(address newTeam) external onlyOwner {\n        require(tradeFeeRatio > 0, \"NOT_TRADE_FEE_TOKEN\");\n        emit ChangeTeam(team,newTeam);\n        team = newTeam;\n    }\n\n    function abandonOwnership(address zeroAddress) external onlyOwner {\n        require(zeroAddress == address(0), \"NOT_ZERO_ADDRESS\");\n        emit OwnershipTransferred(_OWNER_, address(0));\n        _OWNER_ = address(0);\n    }\n}\n"
    },
    "contracts/external/ERC20/InitializableERC20.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\n\ncontract InitializableERC20 {\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public totalSupply;\n\n    bool public initialized;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    function init(\n        address _creator,\n        uint256 _totalSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public {\n        require(!initialized, \"TOKEN_INITIALIZED\");\n        initialized = true;\n        totalSupply = _totalSupply;\n        balances[_creator] = _totalSupply;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        emit Transfer(address(0), _creator, _totalSupply);\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        balances[from] = balances[from].sub(amount);\n        balances[to] = balances[to].add(amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"FROM_ADDRESS_IS_EMPTY\");\n        require(recipient != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[sender], \"BALANCE_NOT_ENOUGH\");\n\n        balances[sender] = balances[sender].sub(amount);\n        balances[recipient] = balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n}\n"
    },
    "contracts/external/ERC20/InitializableFragERC20.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\n\ncontract InitializableFragERC20 {\n    using SafeMath for uint256;\n\n    string public name;\n    string public symbol;\n    uint256 public totalSupply;\n\n    bool public initialized;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    function init(\n        address _creator,\n        uint256 _totalSupply,\n        string memory _name,\n        string memory _symbol\n    ) public {\n        require(!initialized, \"TOKEN_INITIALIZED\");\n        initialized = true;\n        totalSupply = _totalSupply;\n        balances[_creator] = _totalSupply;\n        name = _name;\n        symbol = _symbol;\n        emit Transfer(address(0), _creator, _totalSupply);\n    }\n\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        balances[from] = balances[from].sub(amount);\n        balances[to] = balances[to].add(amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"FROM_ADDRESS_IS_EMPTY\");\n        require(recipient != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[sender], \"BALANCE_NOT_ENOUGH\");\n\n        balances[sender] = balances[sender].sub(amount);\n        balances[recipient] = balances[recipient].add(amount);\n\n        emit Transfer(sender, recipient, amount);\n    }\n\n}\n"
    },
    "contracts/external/ERC20/InitializableInternalMintableERC20.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\n\ncontract InitializableInternalMintableERC20 is InitializableOwnable {\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Mint(address indexed user, uint256 value);\n    event Burn(address indexed user, uint256 value);\n\n    function init(\n        address _creator,\n        uint256 _initSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public {\n        initOwner(_creator);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _initSupply;\n        balances[_creator] = _initSupply;\n        emit Transfer(address(0), _creator, _initSupply);\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        balances[from] = balances[from].sub(amount);\n        balances[to] = balances[to].add(amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    function _mint(address user, uint256 value) internal {\n        balances[user] = balances[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        balances[user] = balances[user].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n}\n"
    },
    "contracts/external/ERC20/InitializableMintableERC20.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\n\ncontract InitializableMintableERC20 is InitializableOwnable {\n    using SafeMath for uint256;\n\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n    event Mint(address indexed user, uint256 value);\n    event Burn(address indexed user, uint256 value);\n\n    function init(\n        address _creator,\n        uint256 _initSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public {\n        initOwner(_creator);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        totalSupply = _initSupply;\n        balances[_creator] = _initSupply;\n        emit Transfer(address(0), _creator, _initSupply);\n    }\n\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        balances[from] = balances[from].sub(amount);\n        balances[to] = balances[to].add(amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    function mint(address user, uint256 value) external onlyOwner {\n        _mint(user, value);\n    }\n\n    function burn(address user, uint256 value) external onlyOwner {\n        _burn(user, value);\n    }\n\n    function _mint(address user, uint256 value) internal {\n        balances[user] = balances[user].add(value);\n        totalSupply = totalSupply.add(value);\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        balances[user] = balances[user].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n}\n"
    },
    "contracts/external/ERC20/MintableERC20.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\n\ncontract MintableERC20 {\n    using SafeMath for uint256;\n\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n    }\n\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        balances[msg.sender] = balances[msg.sender].sub(amount);\n        balances[to] = balances[to].add(amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function balanceOf(address owner) public view returns (uint256 balance) {\n        return balances[owner];\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(to != address(0), \"TO_ADDRESS_IS_EMPTY\");\n        require(amount <= balances[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= allowed[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        balances[from] = balances[from].sub(amount);\n        balances[to] = balances[to].add(amount);\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        allowed[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return allowed[owner][spender];\n    }\n\n    function mint(address account, uint256 amount) external {\n        balances[account] = balances[account].add(amount);\n    }\n}\n"
    },
    "contracts/Factory/CrowdPoolingFactory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {ICP} from \"../CrowdPooling/intf/ICP.sol\";\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {IERC20} from \"../intf/IERC20.sol\";\nimport {DecimalMath} from \"../lib/DecimalMath.sol\";\nimport {FeeRateModel} from \"../lib/FeeRateModel.sol\";\nimport {CP} from \"../CrowdPooling/impl/CP.sol\";\n\ninterface IFeeRateImpl {\n    function getFeeRate(address pool, address trader) external view returns (uint256);\n    function addCpPoolInfo(address cpPool, address quoteToken, int globalQuota, address feeAddr, address quotaAddr) external;\n}\n\n/**\n * @title CrowdPoolingFacotry\n * @author DODO Breeder\n *\n * @notice Create And Register CP Pools \n */\ncontract CrowdPoolingFactory is InitializableOwnable {\n    using SafeMath for uint256;\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _DVM_FACTORY_;\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\n    address public immutable _DEFAULT_PERMISSION_MANAGER_;\n    address public _CP_TEMPLATE_;\n    address public _DEFAULT_MAINTAINER_;\n\n    // ============ Settings =============\n\n    uint256 public _CAP_RATIO_ = 50; \n    uint256 public _FREEZE_DURATION_ =  30 days;\n    uint256 public _CALM_DURATION_ = 0;\n    uint256 public _VEST_DURATION_ = 0;\n    uint256 public _K_ = 0;\n    uint256 public _CLIFF_RATE_ = 10**18;\n\n    // ============ Registry ============\n\n    // base -> quote -> CP address list\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\n    // creator -> CP address list\n    mapping(address => address[]) public _USER_REGISTRY_;\n\n    // ============ modifiers ===========\n\n    modifier valueCheck(\n        address cpAddress,\n        address baseToken,\n        uint256[] memory timeLine,\n        uint256[] memory valueList)\n    {\n        require(timeLine[2] == _CALM_DURATION_, \"CP_FACTORY : PHASE_CALM_DURATION_INVALID\");\n        require(timeLine[4] == _VEST_DURATION_, \"CP_FACTORY : VEST_DURATION_INVALID\");\n        require(valueList[1] == _K_, \"CP_FACTORY : K_INVALID\");\n        require(valueList[3] == _CLIFF_RATE_, \"CP_FACTORY : CLIFF_RATE_INVALID\");\n\n        uint256 baseTokenBalance = IERC20(baseToken).balanceOf(cpAddress);\n        require(valueList[0].mul(100) <= baseTokenBalance.mul(valueList[2]).div(10**18).mul(_CAP_RATIO_),\"CP_FACTORY : QUOTE_CAP_INVALID\");\n        require(timeLine[3]>= _FREEZE_DURATION_, \"CP_FACTORY : FREEZE_DURATION_INVALID\");\n        _;\n    }\n\n    // ============ Events ============\n\n    event NewCP(\n        address baseToken,\n        address quoteToken,\n        address creator,\n        address cp\n    );\n\n    event RemoveCP(address cp);\n\n    constructor(\n        address cloneFactory,\n        address cpTemplate,\n        address dvmFactory,\n        address defaultMaintainer,\n        address defaultMtFeeRateModel,\n        address defaultPermissionManager\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _CP_TEMPLATE_ = cpTemplate;\n        _DVM_FACTORY_ = dvmFactory;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\n        _DEFAULT_PERMISSION_MANAGER_ = defaultPermissionManager;\n    }\n\n    // ============ Functions ============\n\n    function createCrowdPooling() external returns (address newCrowdPooling) {\n        CP newPool = new CP();\n        newCrowdPooling = address(newPool);\n    }\n\n    function initCrowdPooling(\n        address cpAddress,\n        address creator,\n        address[] memory tokens,//0 baseToken 1 quoteToken\n        uint256[] memory timeLine,\n        uint256[] memory valueList,\n        bool[] memory switches,\n        int globalQuota\n    ) external valueCheck(cpAddress,tokens[0],timeLine,valueList) {\n        {\n        address[] memory addressList = new address[](7);\n        addressList[0] = creator;\n        addressList[1] = _DEFAULT_MAINTAINER_;\n        addressList[2] = tokens[0];\n        addressList[3] = tokens[1];\n        addressList[4] = _DEFAULT_PERMISSION_MANAGER_;\n        addressList[5] = _DEFAULT_MT_FEE_RATE_MODEL_;\n        addressList[6] = _DVM_FACTORY_;\n\n        ICP(cpAddress).init(\n            addressList,\n            timeLine,\n            valueList,\n            switches\n        );\n\n        address feeRateImplAddr = FeeRateModel(_DEFAULT_MT_FEE_RATE_MODEL_).feeRateImpl();\n        IFeeRateImpl(feeRateImplAddr).addCpPoolInfo(cpAddress, tokens[1], globalQuota, address(0), address(0));\n        }\n\n        _REGISTRY_[tokens[0]][tokens[1]].push(cpAddress);\n        _USER_REGISTRY_[creator].push(cpAddress);\n\n        emit NewCP(tokens[0], tokens[1], creator, cpAddress);\n    }\n\n    // ============ View Functions ============\n\n    function getCrowdPooling(address baseToken, address quoteToken)\n        external\n        view\n        returns (address[] memory pools)\n    {\n        return _REGISTRY_[baseToken][quoteToken];\n    }\n\n    function getCrowdPoolingBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory baseToken0Pools, address[] memory baseToken1Pools)\n    {\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n    }\n\n    function getCrowdPoolingByUser(address user)\n        external\n        view\n        returns (address[] memory pools)\n    {\n        return _USER_REGISTRY_[user];\n    }\n\n    // ============ Owner Functions ============\n    \n    function updateCPTemplate(address _newCPTemplate) external onlyOwner {\n        _CP_TEMPLATE_ = _newCPTemplate;\n    }\n\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\n    }\n\n    function setCapRatio(uint256 _newCapRatio) public onlyOwner {\n        require(_newCapRatio > 0 && _newCapRatio <= 100, \"CP_FACTORY : INVALID\");\n        _CAP_RATIO_ = _newCapRatio;\n    }\n\n    function setFreezeDuration(uint256 _newFreeDuration) public onlyOwner {\n        _FREEZE_DURATION_ = _newFreeDuration;\n    }\n\n    function setCalmDuration(uint256 _newCalmDuration) public onlyOwner {\n        _CALM_DURATION_ = _newCalmDuration;\n    }\n\n    function setVestDuration(uint256 _newVestDuration) public onlyOwner {\n        _VEST_DURATION_ = _newVestDuration;\n    }\n\n    function setK(uint256 _newK) public onlyOwner {\n        require(_newK <= 10**18, \"CP_FACTORY : INVALID\");\n        _K_ = _newK;\n    }\n\n    function setCliffRate(uint256 _newCliffRate) public onlyOwner {\n        require(_newCliffRate <= 10**18, \"CP_FACTORY : INVALID\");\n        _CLIFF_RATE_ = _newCliffRate;\n    }\n\n    function removePoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n        for (uint256 i = 0; i < registryList.length; i++) {\n            if (registryList[i] == pool) {\n                registryList[i] = registryList[registryList.length - 1];\n                break;\n            }\n        }\n        _REGISTRY_[baseToken][quoteToken] = registryList;\n        _REGISTRY_[baseToken][quoteToken].pop();\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\n            if (userRegistryList[i] == pool) {\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n                break;\n            }\n        }\n        _USER_REGISTRY_[creator] = userRegistryList;\n        _USER_REGISTRY_[creator].pop();\n        emit RemoveCP(pool);\n    }\n}\n"
    },
    "contracts/Factory/DODOMineV2Factory.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {ERC20Mine} from \"../DODOToken/DODOMineV2/ERC20Mine.sol\";\n\ninterface IMineV2 {\n    function init(address owner, address token) external;\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external;\n\n    function transferOwnership(address newOwner) external;\n}\n\n/**\n * @title DODOMineV2 Factory\n * @author DODO Breeder\n *\n * @notice Create And Register DODOMineV2 Contracts \n */\ncontract DODOMineV2Factory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public _DEFAULT_MAINTAINER_;\n    address public _MINEV2_TEMPLATE_;\n\n    // mine -> stakeToken\n    mapping(address => address) public _MINE_REGISTRY_;\n    // stakeToken -> mine\n    mapping(address => address) public _STAKE_REGISTRY_;\n\n    // ============ Events ============\n\n    event NewMineV2(address mine, address stakeToken);\n    event RemoveMineV2(address mine, address stakeToken);\n\n    constructor(\n        address cloneFactory,\n        address mineTemplate,\n        address defaultMaintainer\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _MINEV2_TEMPLATE_ = mineTemplate;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n    }\n\n    // ============ Functions ============\n\n    function createDODOMineV2(\n        address stakeToken,\n        address[] memory rewardTokens,\n        uint256[] memory rewardPerBlock,\n        uint256[] memory startBlock,\n        uint256[] memory endBlock\n    ) external onlyOwner returns (address newMineV2) {\n        require(rewardTokens.length > 0, \"REWARD_EMPTY\");\n        require(rewardTokens.length == rewardPerBlock.length, \"REWARD_PARAM_NOT_MATCH\");\n        require(startBlock.length == rewardPerBlock.length, \"REWARD_PARAM_NOT_MATCH\");\n        require(endBlock.length == rewardPerBlock.length, \"REWARD_PARAM_NOT_MATCH\");\n\n        ERC20Mine newPool = new ERC20Mine();\n        newMineV2 = address(newPool);\n\n        IMineV2(newMineV2).init(address(this), stakeToken);\n\n        for(uint i = 0; i<rewardTokens.length; i++) {\n            IMineV2(newMineV2).addRewardToken(\n                rewardTokens[i],\n                rewardPerBlock[i],\n                startBlock[i],\n                endBlock[i]\n            );\n        }\n\n        IMineV2(newMineV2).transferOwnership(_DEFAULT_MAINTAINER_);\n\n        _MINE_REGISTRY_[newMineV2] = stakeToken;\n        _STAKE_REGISTRY_[stakeToken] = newMineV2;\n\n        emit NewMineV2(newMineV2, stakeToken);\n    }\n\n    // ============ Admin Operation Functions ============\n    \n    function updateMineV2Template(address _newMineV2Template) external onlyOwner {\n        _MINEV2_TEMPLATE_ = _newMineV2Template;\n    }\n\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\n    }\n\n    function addByAdmin(\n        address mine,\n        address stakeToken\n    ) external onlyOwner {\n        _MINE_REGISTRY_[mine] = stakeToken;\n        _STAKE_REGISTRY_[stakeToken] = mine;\n\n        emit NewMineV2(mine, stakeToken);\n    }\n\n    function removeByAdmin(\n        address mine,\n        address stakeToken\n    ) external onlyOwner {\n        _MINE_REGISTRY_[mine] = address(0);\n        _STAKE_REGISTRY_[stakeToken] = address(0);\n\n        emit RemoveMineV2(mine, stakeToken);\n    }\n}\n"
    },
    "contracts/Factory/DPPFactory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {IFeeRateModel} from \"../lib/FeeRateModel.sol\";\nimport {IDPP} from \"../DODOPrivatePool/intf/IDPP.sol\";\nimport {IDPPAdmin} from \"../DODOPrivatePool/intf/IDPPAdmin.sol\";\nimport {DPPAdvanced} from \"../DODOPrivatePool/impl/DPPAdvanced/DPPAdvanced.sol\";\nimport {DPPAdvancedAdmin} from \"../DODOPrivatePool/impl/DPPAdvanced/DPPAdvancedAdmin.sol\";\n\n/**\n * @title DODO PrivatePool Factory\n * @author DODO Breeder\n *\n * @notice Create And Register DPP Pools \n */\ncontract DPPFactory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public _DEFAULT_MAINTAINER_;\n    address public _DPP_TEMPLATE_;\n    address public _DPP_ADMIN_TEMPLATE_;\n\n    mapping (address => bool) public isAdminListed;\n\n    // ============ Registry ============\n\n    // base -> quote -> DPP address list\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\n    // creator -> DPP address list\n    mapping(address => address[]) public _USER_REGISTRY_;\n\n    // ============ Events ============\n\n    event NewDPP(\n        address baseToken,\n        address quoteToken,\n        address creator,\n        address dpp\n    );\n\n    event RemoveDPP(address dpp);\n\n    event addAdmin(address admin);\n    event removeAdmin(address admin);\n\n    constructor(\n        address cloneFactory,\n        address dppTemplate,\n        address dppAdminTemplate,\n        address defaultMaintainer,\n        address defaultMtFeeRateModel,\n        address dodoApproveProxy\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _DPP_TEMPLATE_ = dppTemplate;\n        _DPP_ADMIN_TEMPLATE_ = dppAdminTemplate;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    // ============ Functions ============\n\n    function createDODOPrivatePool() external returns (address newPrivatePool) {\n        DPPAdvanced newPool = new DPPAdvanced();\n        newPrivatePool = address(newPool);\n    }\n\n    function initDODOPrivatePool(\n        address dppAddress,\n        address creator,\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 k,\n        uint256 i,\n        bool isOpenTwap\n    ) external {\n        require(isAdminListed[msg.sender], \"ACCESS_DENIED\");\n        {\n            address _dppAddress = dppAddress;\n            address adminModel = _createDPPAdminModel(\n                creator,\n                _dppAddress,\n                creator,\n                _DODO_APPROVE_PROXY_\n            );\n            IDPP(_dppAddress).init(\n                adminModel,\n                _DEFAULT_MAINTAINER_,\n                baseToken,\n                quoteToken,\n                lpFeeRate,\n                _DEFAULT_MT_FEE_RATE_MODEL_,\n                k,\n                i,\n                isOpenTwap\n            );\n        }\n\n        _REGISTRY_[baseToken][quoteToken].push(dppAddress);\n        _USER_REGISTRY_[creator].push(dppAddress);\n        emit NewDPP(baseToken, quoteToken, creator, dppAddress);\n    }\n\n    function _createDPPAdminModel(\n        address owner,\n        address dpp,\n        address operator,\n        address dodoApproveProxy\n    ) internal returns (address adminModel) {\n        DPPAdvancedAdmin newModel = new DPPAdvancedAdmin();\n        adminModel = address(newModel);\n        IDPPAdmin(adminModel).init(owner, dpp, operator, dodoApproveProxy);\n    }\n\n    // ============ Admin Operation Functions ============\n    \n    function updateAdminTemplate(address _newDPPAdminTemplate) external onlyOwner {\n        _DPP_ADMIN_TEMPLATE_ = _newDPPAdminTemplate;\n    }\n\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\n    }\n\n    function updateDppTemplate(address _newDPPTemplate) external onlyOwner {\n        _DPP_TEMPLATE_ = _newDPPTemplate;\n    }\n\n    function addAdminList (address contractAddr) external onlyOwner {\n        isAdminListed[contractAddr] = true;\n        emit addAdmin(contractAddr);\n    }\n\n    function removeAdminList (address contractAddr) external onlyOwner {\n        isAdminListed[contractAddr] = false;\n        emit removeAdmin(contractAddr);\n    }\n\n    function addPoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        _REGISTRY_[baseToken][quoteToken].push(pool);\n        _USER_REGISTRY_[creator].push(pool);\n        emit NewDPP(baseToken, quoteToken, creator, pool);\n    }\n\n    function batchAddPoolByAdmin(\n        address[] memory creators,\n        address[] memory baseTokens, \n        address[] memory quoteTokens,\n        address[] memory pools\n    ) external onlyOwner {\n        require(creators.length == baseTokens.length,\"PARAMS_INVALID\");\n        require(creators.length == quoteTokens.length,\"PARAMS_INVALID\");\n        require(creators.length == pools.length,\"PARAMS_INVALID\");\n        for(uint256 i = 0; i < creators.length; i++) {\n            address creator = creators[i];\n            address baseToken = baseTokens[i];\n            address quoteToken = quoteTokens[i];\n            address pool = pools[i];\n            \n            _REGISTRY_[baseToken][quoteToken].push(pool);\n            _USER_REGISTRY_[creator].push(pool);\n            emit NewDPP(baseToken, quoteToken, creator, pool);\n        }\n    }\n\n    function removePoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n        for (uint256 i = 0; i < registryList.length; i++) {\n            if (registryList[i] == pool) {\n                registryList[i] = registryList[registryList.length - 1];\n                break;\n            }\n        }\n        _REGISTRY_[baseToken][quoteToken] = registryList;\n        _REGISTRY_[baseToken][quoteToken].pop();\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\n            if (userRegistryList[i] == pool) {\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n                break;\n            }\n        }\n        _USER_REGISTRY_[creator] = userRegistryList;\n        _USER_REGISTRY_[creator].pop();\n        emit RemoveDPP(pool);\n    }\n\n    // ============ View Functions ============\n\n    function getDODOPool(address baseToken, address quoteToken)\n        external\n        view\n        returns (address[] memory pools)\n    {\n        return _REGISTRY_[baseToken][quoteToken];\n    }\n\n    function getDODOPoolBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory baseToken0Pool, address[] memory baseToken1Pool)\n    {\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n    }\n\n    function getDODOPoolByUser(address user) \n        external\n        view\n        returns (address[] memory pools)\n    {\n        return _USER_REGISTRY_[user];\n    }\n}\n"
    },
    "contracts/Factory/DSPFactory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {IDSP} from \"../DODOStablePool/intf/IDSP.sol\";\nimport {DSP} from \"../DODOStablePool/impl/DSP.sol\";\n\ninterface IDSPFactory {\n    function createDODOStablePool(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newStablePool);\n}\n\n/**\n * @title DODO StablePool Factory\n * @author DODO Breeder\n *\n * @notice Create And Register DSP Pools\n */\ncontract DSPFactory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\n    address public _DEFAULT_MAINTAINER_;\n    address public _DSP_TEMPLATE_;\n\n    // ============ Registry ============\n\n    // base -> quote -> DSP address list\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\n    // creator -> DSP address list\n    mapping(address => address[]) public _USER_REGISTRY_;\n\n    // ============ Events ============\n\n    event NewDSP(address baseToken, address quoteToken, address creator, address DSP);\n\n    event RemoveDSP(address DSP);\n\n    // ============ Functions ============\n\n    constructor(\n        address cloneFactory,\n        address DSPTemplate,\n        address defaultMaintainer,\n        address defaultMtFeeRateModel\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _DSP_TEMPLATE_ = DSPTemplate;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\n    }\n\n    function createDODOStablePool(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newStablePool) {\n        DSP newPool = new DSP();\n        newStablePool = address(newPool);\n        {\n            IDSP(newStablePool).init(\n                _DEFAULT_MAINTAINER_,\n                baseToken,\n                quoteToken,\n                lpFeeRate,\n                _DEFAULT_MT_FEE_RATE_MODEL_,\n                i,\n                k,\n                isOpenTWAP\n            );\n        }\n        _REGISTRY_[baseToken][quoteToken].push(newStablePool);\n        _USER_REGISTRY_[tx.origin].push(newStablePool);\n        emit NewDSP(baseToken, quoteToken, tx.origin, newStablePool);\n    }\n\n    // ============ Admin Operation Functions ============\n\n    function updateDSPTemplate(address _newDSPTemplate) external onlyOwner {\n        _DSP_TEMPLATE_ = _newDSPTemplate;\n    }\n\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\n    }\n\n    function addPoolByAdmin(\n        address creator,\n        address baseToken,\n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        _REGISTRY_[baseToken][quoteToken].push(pool);\n        _USER_REGISTRY_[creator].push(pool);\n        emit NewDSP(baseToken, quoteToken, creator, pool);\n    }\n\n    function removePoolByAdmin(\n        address creator,\n        address baseToken,\n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n        for (uint256 i = 0; i < registryList.length; i++) {\n            if (registryList[i] == pool) {\n                registryList[i] = registryList[registryList.length - 1];\n                break;\n            }\n        }\n        _REGISTRY_[baseToken][quoteToken] = registryList;\n        _REGISTRY_[baseToken][quoteToken].pop();\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\n            if (userRegistryList[i] == pool) {\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n                break;\n            }\n        }\n        _USER_REGISTRY_[creator] = userRegistryList;\n        _USER_REGISTRY_[creator].pop();\n        emit RemoveDSP(pool);\n    }\n\n    // ============ View Functions ============\n\n    function getDODOPool(address baseToken, address quoteToken)\n        external\n        view\n        returns (address[] memory machines)\n    {\n        return _REGISTRY_[baseToken][quoteToken];\n    }\n\n    function getDODOPoolBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory baseToken0Machines, address[] memory baseToken1Machines)\n    {\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n    }\n\n    function getDODOPoolByUser(address user) external view returns (address[] memory machines) {\n        return _USER_REGISTRY_[user];\n    }\n}\n"
    },
    "contracts/Factory/DVMFactory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {IDVM} from \"../DODOVendingMachine/intf/IDVM.sol\";\nimport {DVM} from \"../DODOVendingMachine/impl/DVM.sol\";\n\ninterface IDVMFactory {\n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newVendingMachine);\n}\n\n\n/**\n * @title DODO VendingMachine Factory\n * @author DODO Breeder\n *\n * @notice Create And Register DVM Pools \n */\ncontract DVMFactory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _DEFAULT_MT_FEE_RATE_MODEL_;\n    address public _DEFAULT_MAINTAINER_;\n    address public _DVM_TEMPLATE_;\n\n    // ============ Registry ============\n\n    // base -> quote -> DVM address list\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\n    // creator -> DVM address list\n    mapping(address => address[]) public _USER_REGISTRY_;\n\n    // ============ Events ============\n\n    event NewDVM(\n        address baseToken,\n        address quoteToken,\n        address creator,\n        address dvm\n    );\n\n    event RemoveDVM(address dvm);\n\n    // ============ Functions ============\n\n    constructor(\n        address cloneFactory,\n        address dvmTemplate,\n        address defaultMaintainer,\n        address defaultMtFeeRateModel\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _DVM_TEMPLATE_ = dvmTemplate;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n        _DEFAULT_MT_FEE_RATE_MODEL_ = defaultMtFeeRateModel;\n    }\n\n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newVendingMachine) {\n        DVM newPool = new DVM();\n        newVendingMachine = address(newPool);\n        {\n            IDVM(newVendingMachine).init(\n                _DEFAULT_MAINTAINER_,\n                baseToken,\n                quoteToken,\n                lpFeeRate,\n                _DEFAULT_MT_FEE_RATE_MODEL_,\n                i,\n                k,\n                isOpenTWAP\n            );\n        }\n        _REGISTRY_[baseToken][quoteToken].push(newVendingMachine);\n        _USER_REGISTRY_[tx.origin].push(newVendingMachine);\n        emit NewDVM(baseToken, quoteToken, tx.origin, newVendingMachine);\n    }\n\n    // ============ Admin Operation Functions ============\n\n    function updateDvmTemplate(address _newDVMTemplate) external onlyOwner {\n        _DVM_TEMPLATE_ = _newDVMTemplate;\n    }\n    \n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\n    }\n\n    function addPoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        _REGISTRY_[baseToken][quoteToken].push(pool);\n        _USER_REGISTRY_[creator].push(pool);\n        emit NewDVM(baseToken, quoteToken, creator, pool);\n    }\n\n    function removePoolByAdmin(\n        address creator,\n        address baseToken, \n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n        for (uint256 i = 0; i < registryList.length; i++) {\n            if (registryList[i] == pool) {\n                registryList[i] = registryList[registryList.length - 1];\n                break;\n            }\n        }\n        _REGISTRY_[baseToken][quoteToken] = registryList;\n        _REGISTRY_[baseToken][quoteToken].pop();\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\n            if (userRegistryList[i] == pool) {\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n                break;\n            }\n        }\n        _USER_REGISTRY_[creator] = userRegistryList;\n        _USER_REGISTRY_[creator].pop();\n        emit RemoveDVM(pool);\n    }\n\n    // ============ View Functions ============\n\n    function getDODOPool(address baseToken, address quoteToken)\n        external\n        view\n        returns (address[] memory machines)\n    {\n        return _REGISTRY_[baseToken][quoteToken];\n    }\n\n    function getDODOPoolBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory baseToken0Machines, address[] memory baseToken1Machines)\n    {\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n    }\n\n    function getDODOPoolByUser(address user)\n        external\n        view\n        returns (address[] memory machines)\n    {\n        return _USER_REGISTRY_[user];\n    }\n}\n"
    },
    "contracts/Factory/ERC20Factory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {InitializableERC20} from \"../external/ERC20/InitializableERC20.sol\";\nimport {InitializableMintableERC20} from \"../external/ERC20/InitializableMintableERC20.sol\";\n\n\n/**\n * @title DODO ERC20Factory\n * @author DODO Breeder\n *\n * @notice Help user to create erc20 token\n */\ncontract ERC20Factory {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _ERC20_TEMPLATE_;\n    address public immutable _MINTABLE_ERC20_TEMPLATE_;\n\n    // ============ Events ============\n\n    event NewERC20(address erc20, address creator, bool isMintable);\n\n    // ============ Registry ============\n    // creator -> token address list\n    mapping(address => address[]) public _USER_STD_REGISTRY_;\n\n    // ============ Functions ============\n\n    constructor(\n        address cloneFactory,\n        address erc20Template,\n        address mintableErc20Template\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _ERC20_TEMPLATE_ = erc20Template;\n        _MINTABLE_ERC20_TEMPLATE_ = mintableErc20Template;\n    }\n\n    function createStdERC20(\n        uint256 totalSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) external returns (address newERC20) {\n        newERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_ERC20_TEMPLATE_);\n        InitializableERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals);\n        _USER_STD_REGISTRY_[msg.sender].push(newERC20);\n        emit NewERC20(newERC20, msg.sender, false);\n    }\n\n    function createMintableERC20(\n        uint256 initSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) external returns (address newMintableERC20) {\n        newMintableERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_MINTABLE_ERC20_TEMPLATE_);\n        InitializableMintableERC20(newMintableERC20).init(\n            msg.sender,\n            initSupply,\n            name,\n            symbol,\n            decimals\n        );\n        emit NewERC20(newMintableERC20, msg.sender, true);\n    }\n\n\n    function getTokenByUser(address user) \n        external\n        view\n        returns (address[] memory tokens)\n    {\n        return _USER_STD_REGISTRY_[user];\n    }\n}\n"
    },
    "contracts/Factory/ERC20V2Factory.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\n\ninterface IStdERC20 {\n    function init(\n        address _creator,\n        uint256 _totalSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) external;\n}\n\ninterface ICustomERC20 {\n    function init(\n        address _creator,\n        uint256 _initSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _tradeBurnRatio,\n        uint256 _tradeFeeRatio,\n        address _team,\n        bool _isMintable\n    ) external;\n}\n\n/**\n * @title DODO ERC20V2Factory\n * @author DODO Breeder\n *\n * @notice Help user to create erc20 token\n */\ncontract ERC20V2Factory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public _ERC20_TEMPLATE_;\n    address public _CUSTOM_ERC20_TEMPLATE_;\n    uint256 public _CREATE_FEE_;\n\n    // ============ Events ============\n    // 0 Std 1 TradeBurn or TradeFee 2 Mintable\n    event NewERC20(address erc20, address creator, uint256 erc20Type);\n    event ChangeCreateFee(uint256 newFee);\n    event Withdraw(address account, uint256 amount);\n    event ChangeStdTemplate(address newStdTemplate);\n    event ChangeCustomTemplate(address newCustomTemplate);\n\n    // ============ Registry ============\n    // creator -> token address list\n    mapping(address => address[]) public _USER_STD_REGISTRY_;\n    mapping(address => address[]) public _USER_CUSTOM_REGISTRY_;\n\n    // ============ Functions ============\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor(\n        address cloneFactory,\n        address erc20Template,\n        address customErc20Template\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _ERC20_TEMPLATE_ = erc20Template;\n        _CUSTOM_ERC20_TEMPLATE_ = customErc20Template;\n    }\n\n    function createStdERC20(\n        uint256 totalSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) external payable returns (address newERC20) {\n        require(msg.value >= _CREATE_FEE_, \"CREATE_FEE_NOT_ENOUGH\");\n        newERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_ERC20_TEMPLATE_);\n        IStdERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals);\n        _USER_STD_REGISTRY_[msg.sender].push(newERC20);\n        emit NewERC20(newERC20, msg.sender, 0);\n    }\n\n    function createCustomERC20(\n        uint256 initSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 tradeBurnRatio,\n        uint256 tradeFeeRatio,\n        address teamAccount,\n        bool isMintable\n    ) external payable returns (address newCustomERC20) {\n        require(msg.value >= _CREATE_FEE_, \"CREATE_FEE_NOT_ENOUGH\");\n        newCustomERC20 = ICloneFactory(_CLONE_FACTORY_).clone(_CUSTOM_ERC20_TEMPLATE_);\n\n        ICustomERC20(newCustomERC20).init(\n            msg.sender,\n            initSupply, \n            name, \n            symbol, \n            decimals, \n            tradeBurnRatio, \n            tradeFeeRatio,\n            teamAccount,\n            isMintable\n        );\n\n        _USER_CUSTOM_REGISTRY_[msg.sender].push(newCustomERC20);\n        if(isMintable)\n            emit NewERC20(newCustomERC20, msg.sender, 2);\n        else \n            emit NewERC20(newCustomERC20, msg.sender, 1);\n    }\n\n\n    // ============ View ============\n    function getTokenByUser(address user) \n        external\n        view\n        returns (address[] memory stds,address[] memory customs)\n    {\n        return (_USER_STD_REGISTRY_[user], _USER_CUSTOM_REGISTRY_[user]);\n    }\n\n    // ============ Ownable =============\n    function changeCreateFee(uint256 newFee) external onlyOwner {\n        _CREATE_FEE_ = newFee;\n        emit ChangeCreateFee(newFee);\n    }\n\n    function withdraw() external onlyOwner {\n        uint256 amount = address(this).balance;\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"ETH_TRANSFER_FAILED\");\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function updateStdTemplate(address newStdTemplate) external onlyOwner {\n        _ERC20_TEMPLATE_ = newStdTemplate;\n        emit ChangeStdTemplate(newStdTemplate);\n    }\n\n    function updateCustomTemplate(address newCustomTemplate) external onlyOwner {\n        _CUSTOM_ERC20_TEMPLATE_ = newCustomTemplate;\n        emit ChangeCustomTemplate(newCustomTemplate);\n    }\n}\n"
    },
    "contracts/Factory/ERC20V3Factory.sol": {
      "content": "/*\n\n    Copyright 2022 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {InitializableERC20} from \"../external/ERC20/InitializableERC20.sol\";\nimport {CustomERC20} from \"../external/ERC20/CustomERC20.sol\";\nimport {CustomMintableERC20} from \"../external/ERC20/CustomMintableERC20.sol\";\n\n\ninterface IStdERC20 {\n    function init(\n        address _creator,\n        uint256 _totalSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) external;\n}\n\ninterface ICustomERC20 {\n    function init(\n        address _creator,\n        uint256 _initSupply,\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals,\n        uint256 _tradeBurnRatio,\n        uint256 _tradeFeeRatio,\n        address _team\n    ) external;\n}\n\n/**\n * @title DODO ERC20V2Factory\n * @author DODO Breeder\n *\n * @notice Help user to create erc20 token\n */\ncontract ERC20V3Factory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public _ERC20_TEMPLATE_;\n    address public _CUSTOM_ERC20_TEMPLATE_;\n    address public _CUSTOM_MINTABLE_ERC20_TEMPLATE_;\n    uint256 public _CREATE_FEE_;\n\n    // ============ Events ============\n    // 0 Std 1 TradeBurn or TradeFee 2 Mintable\n    event NewERC20(address erc20, address creator, uint256 erc20Type);\n    event ChangeCreateFee(uint256 newFee);\n    event Withdraw(address account, uint256 amount);\n    event ChangeStdTemplate(address newStdTemplate);\n    event ChangeCustomTemplate(address newCustomTemplate);\n    event ChangeCustomMintableTemplate(address newCustomMintableTemplate);\n\n    // ============ Registry ============\n    // creator -> token address list\n    mapping(address => address[]) public _USER_STD_REGISTRY_;\n    mapping(address => address[]) public _USER_CUSTOM_REGISTRY_;\n    mapping(address => address[]) public _USER_CUSTOM_MINTABLE_REGISTRY_;\n\n    // ============ Functions ============\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor(\n        address cloneFactory,\n        address erc20Template,\n        address customErc20Template,\n        address customMintableErc20Template,\n        uint256 createFee\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _ERC20_TEMPLATE_ = erc20Template;\n        _CUSTOM_ERC20_TEMPLATE_ = customErc20Template;\n        _CUSTOM_MINTABLE_ERC20_TEMPLATE_ = customMintableErc20Template;\n        _CREATE_FEE_ = createFee;\n    }\n\n    function createStdERC20(\n        uint256 totalSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) external payable returns (address newERC20) {\n        require(msg.value >= _CREATE_FEE_, \"CREATE_FEE_NOT_ENOUGH\");\n        InitializableERC20 newToken = new InitializableERC20();\n        newERC20 = address(newToken);\n        IStdERC20(newERC20).init(msg.sender, totalSupply, name, symbol, decimals);\n        _USER_STD_REGISTRY_[msg.sender].push(newERC20);\n        emit NewERC20(newERC20, msg.sender, 0);\n    }\n\n    function createCustomERC20(\n        uint256 totalSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 tradeBurnRatio,\n        uint256 tradeFeeRatio,\n        address teamAccount\n    ) external payable returns (address newCustomERC20) {\n        require(msg.value >= _CREATE_FEE_, \"CREATE_FEE_NOT_ENOUGH\");\n        CustomERC20 newToken = new CustomERC20();\n        newCustomERC20 = address(newToken);\n\n        ICustomERC20(newCustomERC20).init(\n            msg.sender,\n            totalSupply, \n            name, \n            symbol, \n            decimals, \n            tradeBurnRatio, \n            tradeFeeRatio,\n            teamAccount\n        );\n\n        _USER_CUSTOM_REGISTRY_[msg.sender].push(newCustomERC20);\n        \n        emit NewERC20(newCustomERC20, msg.sender, 1);    \n    }\n\n    function createCustomMintableERC20(\n        uint256 initSupply,\n        string memory name,\n        string memory symbol,\n        uint8 decimals,\n        uint256 tradeBurnRatio,\n        uint256 tradeFeeRatio,\n        address teamAccount\n    ) external payable returns (address newCustomMintableERC20) {\n        require(msg.value >= _CREATE_FEE_, \"CREATE_FEE_NOT_ENOUGH\");\n        CustomMintableERC20 newToken = new CustomMintableERC20();\n        newCustomMintableERC20 = address(newToken);\n\n        ICustomERC20(newCustomMintableERC20).init(\n            msg.sender,\n            initSupply, \n            name, \n            symbol, \n            decimals, \n            tradeBurnRatio, \n            tradeFeeRatio,\n            teamAccount\n        );\n\n        _USER_CUSTOM_MINTABLE_REGISTRY_[msg.sender].push(newCustomMintableERC20);\n        \n        emit NewERC20(newCustomMintableERC20, msg.sender, 2);    \n    }\n\n\n    // ============ View ============\n    function getTokenByUser(address user) \n        external\n        view\n        returns (address[] memory stds,address[] memory customs,address[] memory mintables)\n    {\n        return (_USER_STD_REGISTRY_[user], _USER_CUSTOM_REGISTRY_[user], _USER_CUSTOM_MINTABLE_REGISTRY_[user]);\n    }\n\n    // ============ Ownable =============\n    function changeCreateFee(uint256 newFee) external onlyOwner {\n        _CREATE_FEE_ = newFee;\n        emit ChangeCreateFee(newFee);\n    }\n\n    function withdraw() external onlyOwner {\n        uint256 amount = address(this).balance;\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"ETH_TRANSFER_FAILED\");\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function updateStdTemplate(address newStdTemplate) external onlyOwner {\n        _ERC20_TEMPLATE_ = newStdTemplate;\n        emit ChangeStdTemplate(newStdTemplate);\n    }\n\n    function updateCustomTemplate(address newCustomTemplate) external onlyOwner {\n        _CUSTOM_ERC20_TEMPLATE_ = newCustomTemplate;\n        emit ChangeCustomTemplate(newCustomTemplate);\n    }\n\n    function updateCustomMintableTemplate(address newCustomMintableTemplate) external onlyOwner {\n        _CUSTOM_MINTABLE_ERC20_TEMPLATE_ = newCustomMintableTemplate;\n        emit ChangeCustomMintableTemplate(newCustomMintableTemplate);\n    }\n}\n"
    },
    "contracts/Factory/Registries/DODOMineV3Registry.sol": {
      "content": "/*\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\n\ninterface IDODOMineV3Registry {\n    function addMineV3(\n        address mine,\n        bool isLpToken,\n        address stakeToken\n    ) external;\n}\n\n/**\n * @title DODOMineV3 Registry\n * @author DODO Breeder\n *\n * @notice Register DODOMineV3 Pools \n */\ncontract DODOMineV3Registry is InitializableOwnable, IDODOMineV3Registry {\n\n    mapping (address => bool) public isAdminListed;\n    \n    // ============ Registry ============\n    // minePool -> stakeToken\n    mapping(address => address) public _MINE_REGISTRY_;\n    // lpToken -> minePool\n    mapping(address => address[]) public _LP_REGISTRY_;\n    // singleToken -> minePool\n    mapping(address => address[]) public _SINGLE_REGISTRY_;\n\n\n    // ============ Events ============\n    event NewMineV3(address mine, address stakeToken, bool isLpToken);\n    event RemoveMineV3(address mine, address stakeToken);\n    event addAdmin(address admin);\n    event removeAdmin(address admin);\n\n\n    function addMineV3(\n        address mine,\n        bool isLpToken,\n        address stakeToken\n    ) override external {\n        require(isAdminListed[msg.sender], \"ACCESS_DENIED\");\n        _MINE_REGISTRY_[mine] = stakeToken;\n        if(isLpToken) {\n            _LP_REGISTRY_[stakeToken].push(mine);\n        }else {\n            _SINGLE_REGISTRY_[stakeToken].push(mine);\n        }\n\n        emit NewMineV3(mine, stakeToken, isLpToken);\n    }\n\n    // ============ Admin Operation Functions ============\n\n    function removeMineV3(\n        address mine,\n        bool isLpToken,\n        address stakeToken\n    ) external onlyOwner {\n        _MINE_REGISTRY_[mine] = address(0);\n        if(isLpToken) {\n            uint256 len = _LP_REGISTRY_[stakeToken].length;\n            for (uint256 i = 0; i < len; i++) {\n                if (mine == _LP_REGISTRY_[stakeToken][i]) {\n                    if(i != len - 1) {\n                        _LP_REGISTRY_[stakeToken][i] = _LP_REGISTRY_[stakeToken][len - 1];\n                    }\n                    _LP_REGISTRY_[stakeToken].pop();\n                    break;\n                }\n            }\n        }else {\n            uint256 len = _SINGLE_REGISTRY_[stakeToken].length;\n            for (uint256 i = 0; i < len; i++) {\n                if (mine == _SINGLE_REGISTRY_[stakeToken][i]) {\n                    if(i != len - 1) {\n                        _SINGLE_REGISTRY_[stakeToken][i] = _SINGLE_REGISTRY_[stakeToken][len - 1];\n                    }\n                    _SINGLE_REGISTRY_[stakeToken].pop();\n                    break;\n                }\n            }\n        }\n\n        emit RemoveMineV3(mine, stakeToken);\n    }\n\n    function addAdminList (address contractAddr) external onlyOwner {\n        isAdminListed[contractAddr] = true;\n        emit addAdmin(contractAddr);\n    }\n\n    function removeAdminList (address contractAddr) external onlyOwner {\n        isAdminListed[contractAddr] = false;\n        emit removeAdmin(contractAddr);\n    }\n}"
    },
    "contracts/intf/IDODOApprove.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\ninterface IDODOApprove {\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\n    function getDODOProxy() external view returns (address);\n}\n"
    },
    "contracts/intf/IDODOCallee.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDODOCallee {\n    function DVMSellShareCall(\n        address sender,\n        uint256 burnShareAmount,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DVMFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DSPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function CPCancelCall(\n        address sender,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n\tfunction CPClaimBidCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function NFTRedeemCall(\n        address payable assetTo,\n        uint256 quoteAmount,\n        bytes calldata\n    ) external;\n}\n"
    },
    "contracts/intf/IERC20.sol": {
      "content": "// This is a file copied from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/IERC20.sol\n// SPDX-License-Identifier: MIT\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n}"
    },
    "contracts/intf/IWETH.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n\ninterface IWETH {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) external returns (bool);\n\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/lib/CloneFactory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface ICloneFactory {\n    function clone(address prototype) external returns (address proxy);\n}\n\n// introduction of proxy mode design: https://docs.openzeppelin.com/upgrades/2.8/\n// minimum implementation of transparent proxy: https://eips.ethereum.org/EIPS/eip-1167\n\ncontract CloneFactory is ICloneFactory {\n    function clone(address prototype) external override returns (address proxy) {\n        bytes20 targetBytes = bytes20(prototype);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(\n                add(clone, 0x28),\n                0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000\n            )\n            proxy := create(0, clone, 0x37)\n        }\n        return proxy;\n    }\n}\n"
    },
    "contracts/lib/DecimalMath.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./SafeMath.sol\";\n\n/**\n * @title DecimalMath\n * @author DODO Breeder\n *\n * @notice Functions for fixed point number with 18 decimals\n */\nlibrary DecimalMath {\n    using SafeMath for uint256;\n\n    uint256 internal constant ONE = 10**18;\n    uint256 internal constant ONE2 = 10**36;\n\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(d) / (10**18);\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(d).divCeil(10**18);\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(10**18).div(d);\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target.mul(10**18).divCeil(d);\n    }\n\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\n        return uint256(10**36).div(target);\n    }\n\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\n        return uint256(10**36).divCeil(target);\n    }\n\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\n        if (e == 0) {\n            return 10 ** 18;\n        } else if (e == 1) {\n            return target;\n        } else {\n            uint p = powFloor(target, e.div(2));\n            p = p.mul(p) / (10**18);\n            if (e % 2 == 1) {\n                p = p.mul(target) / (10**18);\n            }\n            return p;\n        }\n    }\n}\n"
    },
    "contracts/lib/DODOMath.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"./SafeMath.sol\";\nimport {DecimalMath} from \"./DecimalMath.sol\";\n\n/**\n * @title DODOMath\n * @author DODO Breeder\n *\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n */\nlibrary DODOMath {\n    using SafeMath for uint256;\n\n    /*\n        Integrate dodo curve from V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n\n        i is the price of V-res trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _GeneralIntegrate(\n        uint256 V0,\n        uint256 V1,\n        uint256 V2,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        uint256 fairAmount = i.mul(V1.sub(V2)); // i*delta\n        if (k == 0) {\n            return fairAmount.div(DecimalMath.ONE);\n        }\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0.mul(V0).div(V1), V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return DecimalMath.ONE.sub(k).add(penalty).mul(fairAmount).div(DecimalMath.ONE2);\n    }\n\n    /*\n        Follow the integration function above\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n\n        i is the price of delta-V trading pair\n        give out target of V\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTarget(\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        if (k == 0) {\n            return V1.add(DecimalMath.mulFloor(i, delta));\n        }\n        // V0 = V1*(1+(sqrt-1)/2k)\n        // sqrt = √(1+4kidelta/V1)\n        // premium = 1+(sqrt-1)/2k\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n\n        if (V1 == 0) {\n            return 0;\n        }\n        uint256 sqrt;\n        uint256 ki = (4 * k).mul(i);\n        if (ki == 0) {\n            sqrt = DecimalMath.ONE;\n        } else if ((ki * delta) / ki == delta) {\n            sqrt = (ki * delta).div(V1).add(DecimalMath.ONE2).sqrt();\n        } else {\n            sqrt = ki.div(V1).mul(delta).add(DecimalMath.ONE2).sqrt();\n        }\n        uint256 premium =\n            DecimalMath.divFloor(sqrt.sub(DecimalMath.ONE), k * 2).add(DecimalMath.ONE);\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mulFloor(V1, premium);\n    }\n\n    /*\n        Follow the integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2 \n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n        return |Q1-Q2|\n\n        as we only support sell amount as delta, the deltaB is always negative\n        the input ideltaB is actually -ideltaB in the equation\n\n        i is the price of delta-V trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTrade(\n        uint256 V0,\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        if (delta == 0) {\n            return 0;\n        }\n\n        if (k == 0) {\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n        }\n\n        if (k == DecimalMath.ONE) {\n            // if k==1\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n            // temp = ideltaBQ1/Q0/Q0\n            // Q2 = Q1/(1+temp)\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n            uint256 temp;\n            uint256 idelta = i.mul(delta);\n            if (idelta == 0) {\n                temp = 0;\n            } else if ((idelta * V1) / idelta == V1) {\n                temp = (idelta * V1).div(V0.mul(V0));\n            } else {\n                temp = delta.mul(V1).div(V0).mul(i).div(V0);\n            }\n            return V1.mul(temp).div(temp.add(DecimalMath.ONE));\n        }\n\n        // calculate -b value and sig\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n        // part1 = (1-k)Q1 >=0\n        // part2 = kQ0^2/Q1-i*deltaB >=0\n        // bAbs = abs(part1-part2)\n        // if part1>part2 => b is negative => bSig is false\n        // if part2>part1 => b is positive => bSig is true\n        uint256 part2 = k.mul(V0).div(V1).mul(V0).add(i.mul(delta)); // kQ0^2/Q1-i*deltaB\n        uint256 bAbs = DecimalMath.ONE.sub(k).mul(V1); // (1-k)Q1\n\n        bool bSig;\n        if (bAbs >= part2) {\n            bAbs = bAbs - part2;\n            bSig = false;\n        } else {\n            bAbs = part2 - bAbs;\n            bSig = true;\n        }\n        bAbs = bAbs.div(DecimalMath.ONE);\n\n        // calculate sqrt\n        uint256 squareRoot =\n            DecimalMath.mulFloor(\n                DecimalMath.ONE.sub(k).mul(4),\n                DecimalMath.mulFloor(k, V0).mul(V0)\n            ); // 4(1-k)kQ0^2\n        squareRoot = bAbs.mul(bAbs).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\n        uint256 numerator;\n        if (bSig) {\n            numerator = squareRoot.sub(bAbs);\n            if (numerator == 0) {\n                revert(\"DODOMath: should not be zero\");\n            }\n        } else {\n            numerator = bAbs.add(squareRoot);\n        }\n\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n        if (V2 > V1) {\n            return 0;\n        } else {\n            return V1 - V2;\n        }\n    }\n}\n"
    },
    "contracts/lib/ExternalValue.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\n\ninterface IExternalValue {\n    function init(address owner, uint256 value) external;\n    function set(uint256 value) external;\n    function get() external view returns (uint256);\n}\n\n\ncontract ExternalValue is InitializableOwnable {\n    uint256 public _VALUE_;\n\n    function init(address owner, uint256 value) external {\n        initOwner(owner);\n        _VALUE_ = value;\n    }\n\n    function set(uint256 value) external onlyOwner {\n        _VALUE_ = value;\n    }\n\n    function get() external view returns (uint256) {\n        return _VALUE_;\n    }\n}\n"
    },
    "contracts/lib/FeeRateModel.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\n\ninterface IFeeRateImpl {\n    function getFeeRate(address pool, address trader) external view returns (uint256);\n}\n\ninterface IFeeRateModel {\n    function getFeeRate(address trader) external view returns (uint256);\n}\n\ncontract FeeRateModel is InitializableOwnable {\n    address public feeRateImpl;\n\n    function setFeeProxy(address _feeRateImpl) public onlyOwner {\n        feeRateImpl = _feeRateImpl;\n    }\n    \n    function getFeeRate(address trader) external view returns (uint256) {\n        if(feeRateImpl == address(0))\n            return 0;\n        return IFeeRateImpl(feeRateImpl).getFeeRate(msg.sender,trader);\n    }\n}\n"
    },
    "contracts/lib/InitializableOwnable.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract InitializableOwnable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n    bool internal _INITIALIZED_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier notInitialized() {\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    function initOwner(address newOwner) public notInitialized {\n        _INITIALIZED_ = true;\n        _OWNER_ = newOwner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n"
    },
    "contracts/lib/Ownable.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract Ownable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    constructor() internal {\n        _OWNER_ = msg.sender;\n        emit OwnershipTransferred(address(0), _OWNER_);\n    }\n\n    function transferOwnership(address newOwner) external virtual onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() external {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n"
    },
    "contracts/lib/PermissionManager.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"./InitializableOwnable.sol\";\n\ninterface IPermissionManager {\n    function initOwner(address) external;\n\n    function isAllowed(address) external view returns (bool);\n}\n\ncontract PermissionManager is InitializableOwnable {\n    bool public _WHITELIST_MODE_ON_;\n\n    mapping(address => bool) internal _whitelist_;\n    mapping(address => bool) internal _blacklist_;\n\n    function isAllowed(address account) external view returns (bool) {\n        if (_WHITELIST_MODE_ON_) {\n            return _whitelist_[account];\n        } else {\n            return !_blacklist_[account];\n        }\n    }\n\n    function openBlacklistMode() external onlyOwner {\n        _WHITELIST_MODE_ON_ = false;\n    }\n\n    function openWhitelistMode() external onlyOwner {\n        _WHITELIST_MODE_ON_ = true;\n    }\n\n    function addToWhitelist(address account) external onlyOwner {\n        _whitelist_[account] = true;\n    }\n\n    function removeFromWhitelist(address account) external onlyOwner {\n        _whitelist_[account] = false;\n    }\n\n    function addToBlacklist(address account) external onlyOwner {\n        _blacklist_[account] = true;\n    }\n\n    function removeFromBlacklist(address account) external onlyOwner {\n        _blacklist_[account] = false;\n    }\n}\n"
    },
    "contracts/lib/PMMPricing.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../lib/DecimalMath.sol\";\nimport {DODOMath} from \"../lib/DODOMath.sol\";\n\n/**\n * @title Pricing\n * @author DODO Breeder\n *\n * @notice DODO Pricing model\n */\n\nlibrary PMMPricing {\n    using SafeMath for uint256;\n\n    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\n\n    struct PMMState {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        RState R;\n    }\n\n    // ============ buy & sell ============\n\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (uint256 receiveQuoteAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            // case 1: R=1\n            // R falls below one\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0.sub(state.B);\n            uint256 backToOneReceiveQuote = state.Q.sub(state.Q0);\n            // case 2: R>1\n            // complex case, R status depends on trading amount\n            if (payBaseAmount < backToOnePayBase) {\n                // case 2.1: R status do not change\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n                newR = RState.ABOVE_ONE;\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n                    receiveQuoteAmount = backToOneReceiveQuote;\n                }\n            } else if (payBaseAmount == backToOnePayBase) {\n                // case 2.2: R status changes to ONE\n                receiveQuoteAmount = backToOneReceiveQuote;\n                newR = RState.ONE;\n            } else {\n                // case 2.3: R status changes to BELOW_ONE\n                receiveQuoteAmount = backToOneReceiveQuote.add(\n                    _ROneSellBaseToken(state, payBaseAmount.sub(backToOnePayBase))\n                );\n                newR = RState.BELOW_ONE;\n            }\n        } else {\n            // state.R == RState.BELOW_ONE\n            // case 3: R<1\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        }\n    }\n\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (uint256 receiveBaseAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else {\n            uint256 backToOnePayQuote = state.Q0.sub(state.Q);\n            uint256 backToOneReceiveBase = state.B.sub(state.B0);\n            if (payQuoteAmount < backToOnePayQuote) {\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount);\n                newR = RState.BELOW_ONE;\n                if (receiveBaseAmount > backToOneReceiveBase) {\n                    receiveBaseAmount = backToOneReceiveBase;\n                }\n            } else if (payQuoteAmount == backToOnePayQuote) {\n                receiveBaseAmount = backToOneReceiveBase;\n                newR = RState.ONE;\n            } else {\n                receiveBaseAmount = backToOneReceiveBase.add(\n                    _ROneSellQuoteToken(state, payQuoteAmount.sub(backToOnePayQuote))\n                );\n                newR = RState.ABOVE_ONE;\n            }\n        }\n    }\n\n    // ============ R = 1 cases ============\n\n    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        // in theory Q2 <= targetQuoteTokenAmount\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.Q0,\n                state.Q0,\n                payBaseAmount,\n                state.i,\n                state.K\n            );\n    }\n\n    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B0,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ R < 1 cases ============\n\n    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._GeneralIntegrate(\n                state.Q0,\n                state.Q.add(payQuoteAmount),\n                state.Q,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.Q0,\n                state.Q,\n                payBaseAmount,\n                state.i,\n                state.K\n            );\n    }\n\n    // ============ R > 1 cases ============\n\n    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return\n            DODOMath._GeneralIntegrate(\n                state.B0,\n                state.B.add(payBaseAmount),\n                state.B,\n                state.i,\n                state.K\n            );\n    }\n\n    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ Helper functions ============\n\n    function adjustedTarget(PMMState memory state) internal pure {\n        if (state.R == RState.BELOW_ONE) {\n            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(\n                state.Q,\n                state.B.sub(state.B0),\n                state.i,\n                state.K\n            );\n        } else if (state.R == RState.ABOVE_ONE) {\n            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\n                state.B,\n                state.Q.sub(state.Q0),\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n        }\n    }\n\n    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\n        if (state.R == RState.BELOW_ONE) {\n            uint256 R = DecimalMath.divFloor(state.Q0.mul(state.Q0).div(state.Q), state.Q);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.divFloor(state.i, R);\n        } else {\n            uint256 R = DecimalMath.divFloor(state.B0.mul(state.B0).div(state.B), state.B);\n            R = DecimalMath.ONE.sub(state.K).add(DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.mulFloor(state.i, R);\n        }\n    }\n}\n"
    },
    "contracts/lib/ReentrancyGuard.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n/**\n * @title ReentrancyGuard\n * @author DODO Breeder\n *\n * @notice Protect functions from Reentrancy Attack\n */\ncontract ReentrancyGuard {\n    // https://solidity.readthedocs.io/en/latest/control-structures.html?highlight=zero-state#scoping-and-declarations\n    // zero-state of _ENTERED_ is false\n    bool private _ENTERED_;\n\n    modifier preventReentrant() {\n        require(!_ENTERED_, \"REENTRANT\");\n        _ENTERED_ = true;\n        _;\n        _ENTERED_ = false;\n    }\n}\n"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n    This is a simplified version of OpenZepplin's SafeERC20 library\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IERC20} from \"../intf/IERC20.sol\";\nimport {SafeMath} from \"./SafeMath.sol\";\n\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves.\n\n        // A Solidity high level call has three parts:\n        //  1. The target address is checked to verify it contains contract code\n        //  2. The call itself is made, and success asserted\n        //  3. The return value is decoded, which in turn checks the size of the returned data.\n        // solhint-disable-next-line max-line-length\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = address(token).call(data);\n        require(success, \"SafeERC20: low-level call failed\");\n\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n\n/**\n * @title SafeMath\n * @author DODO Breeder\n *\n * @notice Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"MUL_ERROR\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"DIVIDING_ERROR\");\n        return a / b;\n    }\n\n    function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = div(a, b);\n        uint256 remainder = a - quotient * b;\n        if (remainder > 0) {\n            return quotient + 1;\n        } else {\n            return quotient;\n        }\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SUB_ERROR\");\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"ADD_ERROR\");\n        return c;\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = x / 2 + 1;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n}\n"
    },
    "contracts/SmartRoute/adapter/DODOV1Adapter.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {IDODOV1} from \"../intf/IDODOV1.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IDODOSellHelper} from \"../helper/DODOSellHelper.sol\";\nimport {UniversalERC20} from \"../lib/UniversalERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {IDODOAdapter} from \"../intf/IDODOAdapter.sol\";\n\ncontract DODOV1Adapter is IDODOAdapter {\n    using SafeMath for uint256;\n    using UniversalERC20 for IERC20;\n\n    address public immutable _DODO_SELL_HELPER_;\n\n    constructor(address dodoSellHelper) public {\n        _DODO_SELL_HELPER_ = dodoSellHelper;\n    }\n    \n    function sellBase(address to, address pool, bytes memory) external override {\n        address curBase = IDODOV1(pool)._BASE_TOKEN_();\n        uint256 curAmountIn = IERC20(curBase).tokenBalanceOf(address(this));\n        IERC20(curBase).universalApproveMax(pool, curAmountIn);\n        IDODOV1(pool).sellBaseToken(curAmountIn, 0, \"\");\n        if(to != address(this)) {\n            address curQuote = IDODOV1(pool)._QUOTE_TOKEN_();\n            SafeERC20.safeTransfer(IERC20(curQuote), to, IERC20(curQuote).tokenBalanceOf(address(this)));\n        }\n    }\n\n    function sellQuote(address to, address pool, bytes memory) external override {\n        address curQuote = IDODOV1(pool)._QUOTE_TOKEN_();\n        uint256 curAmountIn = IERC20(curQuote).tokenBalanceOf(address(this));\n        IERC20(curQuote).universalApproveMax(pool, curAmountIn);\n        uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n            pool,\n            curAmountIn\n        );\n        IDODOV1(pool).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n        if(to != address(this)) {\n            address curBase = IDODOV1(pool)._BASE_TOKEN_();\n            SafeERC20.safeTransfer(IERC20(curBase), to, canBuyBaseAmount);\n        }\n    }\n}"
    },
    "contracts/SmartRoute/adapter/DODOV2Adapter.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {IDODOV2} from \"../intf/IDODOV2.sol\";\nimport {IDODOAdapter} from \"../intf/IDODOAdapter.sol\";\n\ncontract DODOV2Adapter is IDODOAdapter {\n    function sellBase(address to, address pool, bytes memory) external override {\n        IDODOV2(pool).sellBase(to);\n    }\n\n    function sellQuote(address to, address pool, bytes memory) external override {\n        IDODOV2(pool).sellQuote(to);\n    }\n}"
    },
    "contracts/SmartRoute/adapter/UniAdapter.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n    \n*/\n\npragma solidity 0.6.9;\n\nimport {IDODOAdapter} from \"../intf/IDODOAdapter.sol\";\nimport {IUni} from \"../intf/IUni.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\n\ncontract UniAdapter is IDODOAdapter {\n    using SafeMath for uint;\n\n    //fromToken == token0\n    function sellBase(address to, address pool, bytes memory data) external override {\n        address baseToken = IUni(pool).token0();\n        (uint reserveIn, uint reserveOut,) = IUni(pool).getReserves();\n        uint receiveQuoteAmount;\n        {\n        (uint256 fee, uint256 denFee) = abi.decode(data, (uint256, uint256));\n        require(reserveIn > 0 && reserveOut > 0, 'UniAdapter: INSUFFICIENT_LIQUIDITY');\n\n        uint balance0 = IERC20(baseToken).balanceOf(pool);\n        uint sellBaseAmount = balance0 - reserveIn;\n        \n        uint sellBaseAmountWithFee = sellBaseAmount.mul(denFee - fee);\n        uint numerator = sellBaseAmountWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(denFee).add(sellBaseAmountWithFee);\n        receiveQuoteAmount = numerator / denominator;\n        }\n        IUni(pool).swap(0, receiveQuoteAmount, to, new bytes(0));\n    }\n\n    //fromToken == token1\n    function sellQuote(address to, address pool, bytes memory data) external override {\n        address quoteToken = IUni(pool).token1();\n        (uint reserveOut, uint reserveIn,) = IUni(pool).getReserves();\n        uint receiveBaseAmount;\n        {\n        (uint256 fee, uint256 denFee) = abi.decode(data, (uint256, uint256));\n        require(reserveIn > 0 && reserveOut > 0, 'UniAdapter: INSUFFICIENT_LIQUIDITY');\n\n        uint balance1 = IERC20(quoteToken).balanceOf(pool);\n        uint sellQuoteAmount = balance1 - reserveIn;\n\n        uint sellQuoteAmountWithFee = sellQuoteAmount.mul(denFee - fee);\n        uint numerator = sellQuoteAmountWithFee.mul(reserveOut);\n        uint denominator = reserveIn.mul(denFee).add(sellQuoteAmountWithFee);\n        receiveBaseAmount = numerator / denominator;\n        }\n        IUni(pool).swap(receiveBaseAmount, 0, to, new bytes(0));\n    }\n}"
    },
    "contracts/SmartRoute/DODOApprove.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {IERC20} from \"../intf/IERC20.sol\";\nimport {SafeERC20} from \"../lib/SafeERC20.sol\";\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\n\n\n/**\n * @title DODOApprove\n * @author DODO Breeder\n *\n * @notice Handle authorizations in DODO platform\n */\ncontract DODOApprove is InitializableOwnable {\n    using SafeERC20 for IERC20;\n    \n    // ============ Storage ============\n    uint256 private constant _TIMELOCK_DURATION_ = 3 days;\n    uint256 private constant _TIMELOCK_EMERGENCY_DURATION_ = 24 hours;\n    uint256 public _TIMELOCK_;\n    address public _PENDING_DODO_PROXY_;\n    address public _DODO_PROXY_;\n\n    // ============ Events ============\n\n    event SetDODOProxy(address indexed oldProxy, address indexed newProxy);\n\n    \n    // ============ Modifiers ============\n    modifier notLocked() {\n        require(\n            _TIMELOCK_ <= block.timestamp,\n            \"SetProxy is timelocked\"\n        );\n        _;\n    }\n\n    function init(address owner, address initProxyAddress) external {\n        initOwner(owner);\n        _DODO_PROXY_ = initProxyAddress;\n    }\n\n    function unlockSetProxy(address newDodoProxy) public onlyOwner {\n        if(_DODO_PROXY_ == address(0))\n            _TIMELOCK_ = block.timestamp + _TIMELOCK_EMERGENCY_DURATION_;\n        else\n            _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\n        _PENDING_DODO_PROXY_ = newDodoProxy;\n    }\n\n\n    function lockSetProxy() public onlyOwner {\n       _PENDING_DODO_PROXY_ = address(0);\n       _TIMELOCK_ = 0;\n    }\n\n\n    function setDODOProxy() external onlyOwner notLocked() {\n        emit SetDODOProxy(_DODO_PROXY_, _PENDING_DODO_PROXY_);\n        _DODO_PROXY_ = _PENDING_DODO_PROXY_;\n        lockSetProxy();\n    }\n\n\n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external {\n        require(msg.sender == _DODO_PROXY_, \"DODOApprove:Access restricted\");\n        if (amount > 0) {\n            IERC20(token).safeTransferFrom(who, dest, amount);\n        }\n    }\n\n    function getDODOProxy() public view returns (address) {\n        return _DODO_PROXY_;\n    }\n}\n"
    },
    "contracts/SmartRoute/DODOApproveProxy.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDODOApprove} from \"../intf/IDODOApprove.sol\";\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\n\ninterface IDODOApproveProxy {\n    function isAllowedProxy(address _proxy) external view returns (bool);\n    function claimTokens(address token,address who,address dest,uint256 amount) external;\n}\n\n/**\n * @title DODOApproveProxy\n * @author DODO Breeder\n *\n * @notice Allow different version dodoproxy to claim from DODOApprove\n */\ncontract DODOApproveProxy is InitializableOwnable {\n    \n    // ============ Storage ============\n    uint256 private constant _TIMELOCK_DURATION_ = 3 days;\n    mapping (address => bool) public _IS_ALLOWED_PROXY_;\n    uint256 public _TIMELOCK_;\n    address public _PENDING_ADD_DODO_PROXY_;\n    address public immutable _DODO_APPROVE_;\n\n    // ============ Modifiers ============\n    modifier notLocked() {\n        require(\n            _TIMELOCK_ <= block.timestamp,\n            \"SetProxy is timelocked\"\n        );\n        _;\n    }\n\n    constructor(address dodoApporve) public {\n        _DODO_APPROVE_ = dodoApporve;\n    }\n\n    function init(address owner, address[] memory proxies) external {\n        initOwner(owner);\n        for(uint i = 0; i < proxies.length; i++) \n            _IS_ALLOWED_PROXY_[proxies[i]] = true;\n    }\n\n    function unlockAddProxy(address newDodoProxy) public onlyOwner {\n        _TIMELOCK_ = block.timestamp + _TIMELOCK_DURATION_;\n        _PENDING_ADD_DODO_PROXY_ = newDodoProxy;\n    }\n\n    function lockAddProxy() public onlyOwner {\n       _PENDING_ADD_DODO_PROXY_ = address(0);\n       _TIMELOCK_ = 0;\n    }\n\n\n    function addDODOProxy() external onlyOwner notLocked() {\n        _IS_ALLOWED_PROXY_[_PENDING_ADD_DODO_PROXY_] = true;\n        lockAddProxy();\n    }\n\n    function removeDODOProxy (address oldDodoProxy) public onlyOwner {\n        _IS_ALLOWED_PROXY_[oldDodoProxy] = false;\n    }\n    \n    function claimTokens(\n        address token,\n        address who,\n        address dest,\n        uint256 amount\n    ) external {\n        require(_IS_ALLOWED_PROXY_[msg.sender], \"DODOApproveProxy:Access restricted\");\n        IDODOApprove(_DODO_APPROVE_).claimTokens(\n            token,\n            who,\n            dest,\n            amount\n        );\n    }\n\n    function isAllowedProxy(address _proxy) external view returns (bool) {\n        return _IS_ALLOWED_PROXY_[_proxy];\n    }\n}\n"
    },
    "contracts/SmartRoute/DODOV2Proxy02.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {IDODOV2Proxy01} from \"./intf/IDODOV2Proxy01.sol\";\nimport {IDODOV2} from \"./intf/IDODOV2.sol\";\nimport {IDODOV1} from \"./intf/IDODOV1.sol\";\nimport {IDODOApproveProxy} from \"./DODOApproveProxy.sol\";\nimport {IDODOSellHelper} from \"./helper/DODOSellHelper.sol\";\nimport {IERC20} from \"../intf/IERC20.sol\";\nimport {IWETH} from \"../intf/IWETH.sol\";\nimport {IUni} from \"./intf/IUni.sol\";\nimport {SafeMath} from \"../lib/SafeMath.sol\";\nimport {UniversalERC20} from \"./lib/UniversalERC20.sol\";\nimport {SafeERC20} from \"../lib/SafeERC20.sol\";\nimport {DecimalMath} from \"../lib/DecimalMath.sol\";\nimport {ReentrancyGuard} from \"../lib/ReentrancyGuard.sol\";\nimport {InitializableOwnable} from \"../lib/InitializableOwnable.sol\";\nimport {IDODOAdapter} from \"./intf/IDODOAdapter.sol\";\n\n/**\n * @title DODOV2Proxy02\n * @author DODO Breeder\n *\n * @notice Entrance of trading in DODO platform\n */\ncontract DODOV2Proxy02 is IDODOV2Proxy01, ReentrancyGuard, InitializableOwnable {\n    using SafeMath for uint256;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public immutable _WETH_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _DODO_SELL_HELPER_;\n    address public immutable _DVM_FACTORY_;\n    mapping (address => bool) public isWhiteListed;\n\n    // ============ Events ============\n\n    event OrderHistory(\n        address fromToken,\n        address toToken,\n        address sender,\n        uint256 fromAmount,\n        uint256 returnAmount\n    );\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"DODOV2Proxy02: EXPIRED\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor(\n        address dvmFactory,\n        address payable weth,\n        address dodoApproveProxy,\n        address dodoSellHelper\n    ) public {\n        _DVM_FACTORY_ = dvmFactory;\n        _WETH_ = weth;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n        _DODO_SELL_HELPER_ = dodoSellHelper;\n    }\n\n    function addWhiteList (address contractAddr) public onlyOwner {\n        isWhiteListed[contractAddr] = true;\n    }\n\n    function removeWhiteList (address contractAddr) public onlyOwner {\n        isWhiteListed[contractAddr] = false;\n    }\n\n    // ============ DVM Functions (create & add liquidity) ============\n\n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        preventReentrant\n        judgeExpired(deadLine)\n        returns (address newVendingMachine, uint256 shares)\n    {\n        {\n            address _baseToken = baseToken == _ETH_ADDRESS_ ? _WETH_ : baseToken;\n            address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n            newVendingMachine = IDODOV2(_DVM_FACTORY_).createDODOVendingMachine(\n                _baseToken,\n                _quoteToken,\n                lpFeeRate,\n                i,\n                k,\n                isOpenTWAP\n            );\n        }\n\n        {\n            address _baseToken = baseToken;\n            address _quoteToken = quoteToken;\n            _deposit(\n                msg.sender,\n                newVendingMachine,\n                _baseToken,\n                baseInAmount,\n                _baseToken == _ETH_ADDRESS_\n            );\n            _deposit(\n                msg.sender,\n                newVendingMachine,\n                _quoteToken,\n                quoteInAmount,\n                _quoteToken == _ETH_ADDRESS_\n            );\n        }\n\n        (shares, , ) = IDODOV2(newVendingMachine).buyShares(msg.sender);\n    }\n\n    function addDVMLiquidity(\n        address dvmAddress,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        preventReentrant\n        judgeExpired(deadLine)\n        returns (\n            uint256 shares,\n            uint256 baseAdjustedInAmount,\n            uint256 quoteAdjustedInAmount\n        )\n    {\n        address _dvm = dvmAddress;\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _addDVMLiquidity(\n            _dvm,\n            baseInAmount,\n            quoteInAmount\n        );\n        require(\n            baseAdjustedInAmount >= baseMinAmount && quoteAdjustedInAmount >= quoteMinAmount,\n            \"DODOV2Proxy02: deposit amount is not enough\"\n        );\n\n        _deposit(msg.sender, _dvm, IDODOV2(_dvm)._BASE_TOKEN_(), baseAdjustedInAmount, flag == 1);\n        _deposit(msg.sender, _dvm, IDODOV2(_dvm)._QUOTE_TOKEN_(), quoteAdjustedInAmount, flag == 2);\n        \n        (shares, , ) = IDODOV2(_dvm).buyShares(msg.sender);\n        // refund dust eth\n        if (flag == 1 && msg.value > baseAdjustedInAmount) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value - baseAdjustedInAmount}(\"\");\n            require(success, \"DODOV2Proxy02: ETH transfer failed\");\n        }\n        if (flag == 2 && msg.value > quoteAdjustedInAmount) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value - quoteAdjustedInAmount}(\"\");\n            require(success, \"DODOV2Proxy02: ETH transfer failed\");\n        }\n    }\n\n    function _addDVMLiquidity(\n        address dvmAddress,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\n        (uint256 baseReserve, uint256 quoteReserve) = IDODOV2(dvmAddress).getVaultReserve();\n        if (quoteReserve == 0 && baseReserve == 0) {\n            baseAdjustedInAmount = baseInAmount;\n            quoteAdjustedInAmount = quoteInAmount;\n        }\n        if (quoteReserve == 0 && baseReserve > 0) {\n            baseAdjustedInAmount = baseInAmount;\n            quoteAdjustedInAmount = 0;\n        }\n        if (quoteReserve > 0 && baseReserve > 0) {\n            uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n            uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n            if (baseIncreaseRatio <= quoteIncreaseRatio) {\n                baseAdjustedInAmount = baseInAmount;\n                quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\n            } else {\n                quoteAdjustedInAmount = quoteInAmount;\n                baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\n            }\n        }\n    }\n\n    // ============ Swap ============\n\n    function dodoSwapV2ETHToToken(\n        address toToken,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        \n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n        IWETH(_WETH_).deposit{value: msg.value}();\n        SafeERC20.safeTransfer(IERC20(_WETH_), dodoPairs[0], msg.value);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n                }\n            } else {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        emit OrderHistory(\n            _ETH_ADDRESS_,\n            toToken,\n            msg.sender,\n            msg.value,\n            returnAmount\n        );\n    }\n\n    function dodoSwapV2TokenToETH(\n        address fromToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool,\n        uint256 deadLine\n    )\n        external\n        override\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        \n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(address(this));\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(address(this));\n                }\n            } else {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n        returnAmount = IWETH(_WETH_).balanceOf(address(this));\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        IWETH(_WETH_).withdraw(returnAmount);\n        (bool success, ) = payable(msg.sender).call{value: returnAmount}(\"\");\n        require(success, \"DODOV2Proxy02: ETH transfer failed\");\n\n        emit OrderHistory(\n            fromToken,\n            _ETH_ADDRESS_,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }\n\n    function dodoSwapV2TokenToToken(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool,\n        uint256 deadLine\n    )\n        external\n        override\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n\n        uint256 originToTokenBalance = IERC20(toToken).balanceOf(msg.sender);\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(fromToken, msg.sender, dodoPairs[0], fromTokenAmount);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            if (i == dodoPairs.length - 1) {\n                if (directions & 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(msg.sender);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(msg.sender);\n                }\n            } else {\n                if (directions& 1 == 0) {\n                    IDODOV2(dodoPairs[i]).sellBase(dodoPairs[i + 1]);\n                } else {\n                    IDODOV2(dodoPairs[i]).sellQuote(dodoPairs[i + 1]);\n                }\n            }\n            directions = directions >> 1;\n        }\n        returnAmount = IERC20(toToken).balanceOf(msg.sender).sub(originToTokenBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }\n\n    function externalSwap(\n        address fromToken,\n        address toToken,\n        address approveTarget,\n        address swapTarget,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        bytes memory callDataConcat,\n        bool,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        \n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n        if (fromToken != _ETH_ADDRESS_) {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(\n                fromToken,\n                msg.sender,\n                address(this),\n                fromTokenAmount\n            );\n            IERC20(fromToken).universalApproveMax(approveTarget, fromTokenAmount);\n        }\n\n        require(isWhiteListed[swapTarget], \"DODOV2Proxy02: Not Whitelist Contract\");\n        (bool success, ) = swapTarget.call{value: fromToken == _ETH_ADDRESS_ ? msg.value : 0}(callDataConcat);\n\n        require(success, \"DODOV2Proxy02: External Swap execution Failed\");\n\n        IERC20(toToken).universalTransfer(\n            msg.sender,\n            IERC20(toToken).universalBalanceOf(address(this))\n        );\n\n        returnAmount = IERC20(toToken).universalBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n\n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            fromTokenAmount,\n            returnAmount\n        );\n    }\n\n    function dodoSwapV1(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool,\n        uint256 deadLine\n    )\n        external\n        override\n        payable\n        judgeExpired(deadLine)\n        returns (uint256 returnAmount)\n    {\n        require(dodoPairs.length > 0, \"DODOV2Proxy02: PAIRS_EMPTY\");\n        require(minReturnAmount > 0, \"DODOV2Proxy02: RETURN_AMOUNT_ZERO\");\n        \n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        \n        _deposit(msg.sender, address(this), _fromToken, fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            address curDodoPair = dodoPairs[i];\n            if (directions & 1 == 0) {\n                address curDodoBase = IDODOV1(curDodoPair)._BASE_TOKEN_();\n                uint256 curAmountIn = IERC20(curDodoBase).balanceOf(address(this));\n                IERC20(curDodoBase).universalApproveMax(curDodoPair, curAmountIn);\n                IDODOV1(curDodoPair).sellBaseToken(curAmountIn, 0, \"\");\n            } else {\n                address curDodoQuote = IDODOV1(curDodoPair)._QUOTE_TOKEN_();\n                uint256 curAmountIn = IERC20(curDodoQuote).balanceOf(address(this));\n                IERC20(curDodoQuote).universalApproveMax(curDodoPair, curAmountIn);\n                uint256 canBuyBaseAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n                    curDodoPair,\n                    curAmountIn\n                );\n                IDODOV1(curDodoPair).buyBaseToken(canBuyBaseAmount, curAmountIn, \"\");\n            }\n            directions = directions >> 1;\n        }\n\n        \n        if (_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n        } else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(address(this));\n        }\n        \n        require(returnAmount >= minReturnAmount, \"DODOV2Proxy02: Return amount is not enough\");\n        IERC20(_toToken).universalTransfer(msg.sender, returnAmount);\n\n        emit OrderHistory(_fromToken, _toToken, msg.sender, fromTokenAmount, returnAmount);\n    }\n\n    //============ CrowdPooling Functions (bid) ============\n    // function bid(\n    //     address cpAddress,\n    //     uint256 quoteAmount,\n    //     uint8 flag, // 0 - ERC20, 1 - quoteInETH\n    //     uint256 deadLine\n    // ) external override payable preventReentrant judgeExpired(deadLine) {\n    //     _deposit(msg.sender, cpAddress, IDODOV2(cpAddress)._QUOTE_TOKEN_(), quoteAmount, flag == 1);\n    //     IDODOV2(cpAddress).bid(msg.sender);\n    // }\n\n\n    function addLiquidityToV1(\n        address pair,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        uint256 baseMinShares,\n        uint256 quoteMinShares,\n        uint8 flag, // 0 erc20 In  1 baseInETH  2 quoteIn ETH \n        uint256 deadLine\n    ) external override payable preventReentrant judgeExpired(deadLine) returns(uint256 baseShares, uint256 quoteShares) {\n        address _baseToken = IDODOV1(pair)._BASE_TOKEN_();\n        address _quoteToken = IDODOV1(pair)._QUOTE_TOKEN_();\n        \n        _deposit(msg.sender, address(this), _baseToken, baseAmount, flag == 1);\n        _deposit(msg.sender, address(this), _quoteToken, quoteAmount, flag == 2);\n\n        \n        if(baseAmount > 0) {\n            IERC20(_baseToken).universalApproveMax(pair, baseAmount);\n            baseShares = IDODOV1(pair).depositBaseTo(msg.sender, baseAmount);\n        }\n        if(quoteAmount > 0) {\n            IERC20(_quoteToken).universalApproveMax(pair, quoteAmount);\n            quoteShares = IDODOV1(pair).depositQuoteTo(msg.sender, quoteAmount);\n        }\n\n        require(baseShares >= baseMinShares && quoteShares >= quoteMinShares,\"DODOV2Proxy02: Return DLP is not enough\");\n    }\n    \n\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                require(msg.value == amount, \"ETH_VALUE_WRONG\");\n                IWETH(_WETH_).deposit{value: amount}();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\n            }\n        } else {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\n        }\n    }\n\n    function _withdraw(\n        address payable to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                IWETH(_WETH_).withdraw(amount);\n                (bool success, ) = to.call{value: amount}(\"\");\n                require(success, \"ETH_TRANSFER_FAILED\");\n            }\n        } else {\n            if (amount > 0) {\n                SafeERC20.safeTransfer(IERC20(token), to, amount);\n            }\n        }\n    }\n}\n"
    },
    "contracts/SmartRoute/helper/DODOCalleeHelper.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDODOV2} from \"../intf/IDODOV2.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {IWETH} from \"../../intf/IWETH.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\n\ncontract DODOCalleeHelper is ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    address payable public immutable _WETH_;\n\n    fallback() external payable {\n        require(msg.sender == _WETH_, \"WE_SAVED_YOUR_ETH\");\n    }\n\n    receive() external payable {\n        require(msg.sender == _WETH_, \"WE_SAVED_YOUR_ETH\");\n    }\n\n    constructor(address payable weth) public {\n        _WETH_ = weth;\n    }\n\n    function DVMSellShareCall(\n        address payable assetTo,\n        uint256,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata\n    ) external preventReentrant {\n        address _baseToken = IDODOV2(msg.sender)._BASE_TOKEN_();\n        address _quoteToken = IDODOV2(msg.sender)._QUOTE_TOKEN_();\n        _withdraw(assetTo, _baseToken, baseAmount, _baseToken == _WETH_);\n        _withdraw(assetTo, _quoteToken, quoteAmount, _quoteToken == _WETH_);\n    }\n\n    function CPCancelCall(\n        address payable assetTo,\n        uint256 amount,\n        bytes calldata\n    )external preventReentrant{\n        address _quoteToken = IDODOV2(msg.sender)._QUOTE_TOKEN_();\n        _withdraw(assetTo, _quoteToken, amount, _quoteToken == _WETH_);\n    }\n\n\tfunction CPClaimBidCall(\n        address payable assetTo,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata\n    ) external preventReentrant {\n        address _baseToken = IDODOV2(msg.sender)._BASE_TOKEN_();\n        address _quoteToken = IDODOV2(msg.sender)._QUOTE_TOKEN_();\n        _withdraw(assetTo, _baseToken, baseAmount, _baseToken == _WETH_);\n        _withdraw(assetTo, _quoteToken, quoteAmount, _quoteToken == _WETH_);\n    }\n\n    function _withdraw(\n        address payable to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                IWETH(_WETH_).withdraw(amount);\n                (bool success, ) = to.call{value: amount}(\"\");\n                require(success, \"ETH_TRANSFER_FAILED\");\n            }\n        } else {\n            if (amount > 0) {\n                SafeERC20.safeTransfer(IERC20(token), to, amount);\n            }\n        }\n    }\n}\n"
    },
    "contracts/SmartRoute/helper/DODOSellHelper.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDODOV1} from \"../intf/IDODOV1.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\n\n// import {DODOMath} from \"../lib/DODOMath.sol\";\n\ninterface IDODOSellHelper {\n    function querySellQuoteToken(address dodo, uint256 amount) external view returns (uint256);\n    \n    function querySellBaseToken(address dodo, uint256 amount) external view returns (uint256);\n}\n\nlibrary DODOMath {\n    using SafeMath for uint256;\n\n    /*\n        Integrate dodo curve fron V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n    */\n    function _GeneralIntegrate(\n        uint256 V0,\n        uint256 V1,\n        uint256 V2,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        uint256 fairAmount = DecimalMath.mulFloor(i, V1.sub(V2)); // i*delta\n        uint256 V0V0V1V2 = DecimalMath.divCeil(V0.mul(V0).div(V1), V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return DecimalMath.mulFloor(fairAmount, DecimalMath.ONE.sub(k).add(penalty));\n    }\n\n    /*\n        The same with integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2\n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n        if deltaBSig=true, then Q2>Q1\n        if deltaBSig=false, then Q2<Q1\n    */\n    function _SolveQuadraticFunctionForTrade(\n        uint256 Q0,\n        uint256 Q1,\n        uint256 ideltaB,\n        bool deltaBSig,\n        uint256 k\n    ) internal pure returns (uint256) {\n        // calculate -b value and sig\n        // -b = (1-k)Q1-kQ0^2/Q1+i*deltaB\n        uint256 kQ02Q1 = DecimalMath.mulFloor(k, Q0).mul(Q0).div(Q1); // kQ0^2/Q1\n        uint256 b = DecimalMath.mulFloor(DecimalMath.ONE.sub(k), Q1); // (1-k)Q1\n        bool minusbSig = true;\n        if (deltaBSig) {\n            b = b.add(ideltaB); // (1-k)Q1+i*deltaB\n        } else {\n            kQ02Q1 = kQ02Q1.add(ideltaB); // i*deltaB+kQ0^2/Q1\n        }\n        if (b >= kQ02Q1) {\n            b = b.sub(kQ02Q1);\n            minusbSig = true;\n        } else {\n            b = kQ02Q1.sub(b);\n            minusbSig = false;\n        }\n\n        // calculate sqrt\n        uint256 squareRoot = DecimalMath.mulFloor(\n            DecimalMath.ONE.sub(k).mul(4),\n            DecimalMath.mulFloor(k, Q0).mul(Q0)\n        ); // 4(1-k)kQ0^2\n        squareRoot = b.mul(b).add(squareRoot).sqrt(); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = DecimalMath.ONE.sub(k).mul(2); // 2(1-k)\n        uint256 numerator;\n        if (minusbSig) {\n            numerator = b.add(squareRoot);\n        } else {\n            numerator = squareRoot.sub(b);\n        }\n\n        if (deltaBSig) {\n            return DecimalMath.divFloor(numerator, denominator);\n        } else {\n            return DecimalMath.divCeil(numerator, denominator);\n        }\n    }\n\n    /*\n        Start from the integration function\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n        let fairAmount = i*deltaB\n    */\n    function _SolveQuadraticFunctionForTarget(\n        uint256 V1,\n        uint256 k,\n        uint256 fairAmount\n    ) internal pure returns (uint256 V0) {\n        // V0 = V1+V1*(sqrt-1)/2k\n        uint256 sqrt = DecimalMath.divCeil(DecimalMath.mulFloor(k, fairAmount).mul(4), V1);\n        sqrt = sqrt.add(DecimalMath.ONE).mul(DecimalMath.ONE).sqrt();\n        uint256 premium = DecimalMath.divCeil(sqrt.sub(DecimalMath.ONE), k.mul(2));\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mulFloor(V1, DecimalMath.ONE.add(premium));\n    }\n}\n\ncontract DODOSellHelper {\n    using SafeMath for uint256;\n\n    enum RStatus {ONE, ABOVE_ONE, BELOW_ONE}\n\n    uint256 constant ONE = 10**18;\n\n    struct DODOState {\n        uint256 oraclePrice;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 baseTarget;\n        uint256 quoteTarget;\n        RStatus rStatus;\n    }\n\n    function querySellBaseToken(address dodo, uint256 amount) public view returns (uint256) {\n        return IDODOV1(dodo).querySellBaseToken(amount);\n    }\n\n    function querySellQuoteToken(address dodo, uint256 amount) public view returns (uint256) {\n        DODOState memory state;\n        (state.baseTarget, state.quoteTarget) = IDODOV1(dodo).getExpectedTarget();\n        state.rStatus = RStatus(IDODOV1(dodo)._R_STATUS_());\n        state.oraclePrice = IDODOV1(dodo).getOraclePrice();\n        state.Q = IDODOV1(dodo)._QUOTE_BALANCE_();\n        state.B = IDODOV1(dodo)._BASE_BALANCE_();\n        state.K = IDODOV1(dodo)._K_();\n\n        uint256 boughtAmount;\n        // Determine the status (RStatus) and calculate the amount\n        // based on the state\n        if (state.rStatus == RStatus.ONE) {\n            boughtAmount = _ROneSellQuoteToken(amount, state);\n        } else if (state.rStatus == RStatus.ABOVE_ONE) {\n            boughtAmount = _RAboveSellQuoteToken(amount, state);\n        } else {\n            uint256 backOneBase = state.B.sub(state.baseTarget);\n            uint256 backOneQuote = state.quoteTarget.sub(state.Q);\n            if (amount <= backOneQuote) {\n                boughtAmount = _RBelowSellQuoteToken(amount, state);\n            } else {\n                boughtAmount = backOneBase.add(\n                    _ROneSellQuoteToken(amount.sub(backOneQuote), state)\n                );\n            }\n        }\n        // Calculate fees\n        return\n            DecimalMath.divFloor(\n                boughtAmount,\n                DecimalMath.ONE.add(IDODOV1(dodo)._MT_FEE_RATE_()).add(\n                    IDODOV1(dodo)._LP_FEE_RATE_()\n                )\n            );\n    }\n\n    function _ROneSellQuoteToken(uint256 amount, DODOState memory state)\n        internal\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        uint256 i = DecimalMath.divFloor(ONE, state.oraclePrice);\n        uint256 B2 = DODOMath._SolveQuadraticFunctionForTrade(\n            state.baseTarget,\n            state.baseTarget,\n            DecimalMath.mulFloor(i, amount),\n            false,\n            state.K\n        );\n        return state.baseTarget.sub(B2);\n    }\n\n    function _RAboveSellQuoteToken(uint256 amount, DODOState memory state)\n        internal\n        pure\n        returns (uint256 receieBaseToken)\n    {\n        uint256 i = DecimalMath.divFloor(ONE, state.oraclePrice);\n        uint256 B2 = DODOMath._SolveQuadraticFunctionForTrade(\n            state.baseTarget,\n            state.B,\n            DecimalMath.mulFloor(i, amount),\n            false,\n            state.K\n        );\n        return state.B.sub(B2);\n    }\n\n    function _RBelowSellQuoteToken(uint256 amount, DODOState memory state)\n        internal\n        pure\n        returns (uint256 receiveBaseToken)\n    {\n        uint256 Q1 = state.Q.add(amount);\n        uint256 i = DecimalMath.divFloor(ONE, state.oraclePrice);\n        return DODOMath._GeneralIntegrate(state.quoteTarget, Q1, state.Q, i, state.K);\n    }\n}\n"
    },
    "contracts/SmartRoute/helper/DODOSwapCalcHelper.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {IDODOV1} from \"../intf/IDODOV1.sol\";\nimport {IDODOSellHelper} from \"./DODOSellHelper.sol\";\n\ncontract DODOSwapCalcHelper {\n    address public immutable _DODO_SELL_HELPER_;\n\n    constructor(address dodoSellHelper) public {\n        _DODO_SELL_HELPER_ = dodoSellHelper;\n    }\n\n    function calcReturnAmountV1(\n        uint256 fromTokenAmount,\n        address[] memory dodoPairs,\n        uint8[] memory directions\n    ) external view returns (uint256 returnAmount,uint256[] memory midPrices,uint256[] memory feeRates) {\n        returnAmount = fromTokenAmount;\n        midPrices = new uint256[](dodoPairs.length);\n        feeRates = new uint256[](dodoPairs.length);\n        for (uint256 i = 0; i < dodoPairs.length; i++) {\n            address curDodoPair = dodoPairs[i];\n            if (directions[i] == 0) {\n                returnAmount = IDODOV1(curDodoPair).querySellBaseToken(returnAmount);\n            } else {\n                returnAmount = IDODOSellHelper(_DODO_SELL_HELPER_).querySellQuoteToken(\n                    curDodoPair,\n                    returnAmount\n                );\n            }\n            midPrices[i] = IDODOV1(curDodoPair).getMidPrice();\n            feeRates[i] = IDODOV1(curDodoPair)._MT_FEE_RATE_() + IDODOV1(curDodoPair)._LP_FEE_RATE_();\n        }        \n    }\n}"
    },
    "contracts/SmartRoute/helper/DODOV1PmmHelper.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDODOV1} from \"../intf/IDODOV1.sol\";\n\ncontract DODOV1PmmHelper {\n    \n    struct PairDetail {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        uint256 R;\n        uint256 lpFeeRate;\n        uint256 mtFeeRate;\n        address baseToken;\n        address quoteToken;\n        address curPair;\n        uint256 pairVersion;\n    }\n\n    function getPairDetail(address pool) external view returns (PairDetail[] memory res) {\n        res = new PairDetail[](1);\n        PairDetail memory curRes = PairDetail(0,0,0,0,0,0,0,0,0,address(0),address(0),pool,1);\n        curRes.i = IDODOV1(pool).getOraclePrice();\n        curRes.K = IDODOV1(pool)._K_();\n        curRes.B = IDODOV1(pool)._BASE_BALANCE_();\n        curRes.Q = IDODOV1(pool)._QUOTE_BALANCE_();\n        (curRes.B0,curRes.Q0) = IDODOV1(pool).getExpectedTarget();\n        curRes.R = IDODOV1(pool)._R_STATUS_();\n        curRes.lpFeeRate = IDODOV1(pool)._LP_FEE_RATE_();\n        curRes.mtFeeRate = IDODOV1(pool)._MT_FEE_RATE_();\n        curRes.baseToken = IDODOV1(pool)._BASE_TOKEN_();\n        curRes.quoteToken =  IDODOV1(pool)._QUOTE_TOKEN_();\n        res[0] = curRes;\n    }\n}"
    },
    "contracts/SmartRoute/helper/DODOV2RouteHelper.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDODOV2} from \"../intf/IDODOV2.sol\";\n\ncontract DODOV2RouteHelper {\n    address public immutable _DVM_FACTORY_;\n    address public immutable _DPP_FACTORY_;\n    address public immutable _DSP_FACTORY_;\n\n    struct PairDetail {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        uint256 R;\n        uint256 lpFeeRate;\n        uint256 mtFeeRate;\n        address baseToken;\n        address quoteToken;\n        address curPair;\n        uint256 pairVersion;\n    }\n\n    constructor(address dvmFactory,address dppFactory,address dspFactory) public {\n        _DVM_FACTORY_ = dvmFactory;\n        _DPP_FACTORY_ = dppFactory;\n        _DSP_FACTORY_ = dspFactory;\n    }\n\n    function getPairDetail(address token0,address token1,address userAddr) external view returns (PairDetail[] memory res) {\n        (address[] memory baseToken0DVM, address[] memory baseToken1DVM) = IDODOV2(_DVM_FACTORY_).getDODOPoolBidirection(token0,token1);\n        (address[] memory baseToken0DPP, address[] memory baseToken1DPP) = IDODOV2(_DPP_FACTORY_).getDODOPoolBidirection(token0,token1);\n        (address[] memory baseToken0DSP, address[] memory baseToken1DSP) = IDODOV2(_DSP_FACTORY_).getDODOPoolBidirection(token0,token1);\n\n        uint256 len = baseToken0DVM.length + baseToken1DVM.length + baseToken0DPP.length + baseToken1DPP.length + baseToken0DSP.length + baseToken1DSP.length;\n        res = new PairDetail[](len);\n        for(uint8 i = 0; i < len; i++) {\n            PairDetail memory curRes = PairDetail(0,0,0,0,0,0,0,0,0,address(0),address(0),address(0),2);\n            address cur;\n            if(i < baseToken0DVM.length) {\n                cur = baseToken0DVM[i];\n                curRes.baseToken = token0;\n                curRes.quoteToken = token1;\n            } else if(i < baseToken0DVM.length + baseToken1DVM.length) {\n                cur = baseToken1DVM[i - baseToken0DVM.length];\n                curRes.baseToken = token1;\n                curRes.quoteToken = token0;\n            } else if(i < baseToken0DVM.length + baseToken1DVM.length + baseToken0DPP.length) {\n                cur = baseToken0DPP[i - baseToken0DVM.length - baseToken1DVM.length];\n                curRes.baseToken = token0;\n                curRes.quoteToken = token1;\n            } else if(i < baseToken0DVM.length + baseToken1DVM.length + baseToken0DPP.length + baseToken1DPP.length)  {\n                cur = baseToken1DPP[i - baseToken0DVM.length - baseToken1DVM.length - baseToken0DPP.length];\n                curRes.baseToken = token1;\n                curRes.quoteToken = token0;\n            } else if(i < baseToken0DVM.length + baseToken1DVM.length + baseToken0DPP.length + baseToken1DPP.length + baseToken0DSP.length)  {\n                cur = baseToken0DSP[i - baseToken0DVM.length - baseToken1DVM.length - baseToken0DPP.length - baseToken1DPP.length];\n                curRes.baseToken = token0;\n                curRes.quoteToken = token1;\n            } else {\n                cur = baseToken1DSP[i - baseToken0DVM.length - baseToken1DVM.length - baseToken0DPP.length - baseToken1DPP.length - baseToken0DSP.length];\n                curRes.baseToken = token1;\n                curRes.quoteToken = token0;\n            }\n\n            try IDODOV2(cur).getPMMStateForCall() returns (uint256 _i, uint256 _K, uint256 _B, uint256 _Q, uint256 _B0, uint256 _Q0, uint256 _R){                  \n                curRes.i = _i;\n                curRes.K = _K;\n                curRes.B = _B;\n                curRes.Q = _Q;\n                curRes.B0 = _B0;\n                curRes.Q0 = _Q0;\n                curRes.R = _R;\n            } catch {\n                continue;\n            }\n            \n            try IDODOV2(cur).getUserFeeRate(userAddr) returns  (uint256 lpFeeRate, uint256 mtFeeRate) {\n                (curRes.lpFeeRate, curRes.mtFeeRate) = (lpFeeRate, mtFeeRate);\n            } catch {\n                (curRes.lpFeeRate, curRes.mtFeeRate) = (0, 1e18);\n            }  \n            curRes.curPair = cur;\n            res[i] = curRes;\n        }\n    }\n}"
    },
    "contracts/SmartRoute/intf/IDODOAdapter.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDODOAdapter {\n    \n    function sellBase(address to, address pool, bytes memory data) external;\n\n    function sellQuote(address to, address pool, bytes memory data) external;\n}\n"
    },
    "contracts/SmartRoute/intf/IDODOV1.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDODOV1 {\n    function init(\n        address owner,\n        address supervisor,\n        address maintainer,\n        address baseToken,\n        address quoteToken,\n        address oracle,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 k,\n        uint256 gasPriceLimit\n    ) external;\n\n    function transferOwnership(address newOwner) external;\n\n    function claimOwnership() external;\n\n    function sellBaseToken(\n        uint256 amount,\n        uint256 minReceiveQuote,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function buyBaseToken(\n        uint256 amount,\n        uint256 maxPayQuote,\n        bytes calldata data\n    ) external returns (uint256);\n\n    function querySellBaseToken(uint256 amount) external view returns (uint256 receiveQuote);\n\n    function queryBuyBaseToken(uint256 amount) external view returns (uint256 payQuote);\n\n    function depositBaseTo(address to, uint256 amount) external returns (uint256);\n\n    function withdrawBase(uint256 amount) external returns (uint256);\n\n    function withdrawAllBase() external returns (uint256);\n\n    function depositQuoteTo(address to, uint256 amount) external returns (uint256);\n\n    function withdrawQuote(uint256 amount) external returns (uint256);\n\n    function withdrawAllQuote() external returns (uint256);\n\n    function _BASE_CAPITAL_TOKEN_() external returns (address);\n\n    function _QUOTE_CAPITAL_TOKEN_() external returns (address);\n\n    function _BASE_TOKEN_() external view returns (address);\n\n    function _QUOTE_TOKEN_() external view returns (address);\n\n    function _R_STATUS_() external view returns (uint8);\n\n    function _QUOTE_BALANCE_() external view returns (uint256);\n\n    function _BASE_BALANCE_() external view returns (uint256);\n\n    function _K_() external view returns (uint256);\n\n    function _MT_FEE_RATE_() external view returns (uint256);\n\n    function _LP_FEE_RATE_() external view returns (uint256);\n\n    function getExpectedTarget() external view returns (uint256 baseTarget, uint256 quoteTarget);\n\n    function getOraclePrice() external view returns (uint256);\n\n    function getMidPrice() external view returns (uint256 midPrice); \n}\n"
    },
    "contracts/SmartRoute/intf/IDODOV2.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IDODOV2 {\n\n    //========== Common ==================\n\n    function sellBase(address to) external returns (uint256 receiveQuoteAmount);\n\n    function sellQuote(address to) external returns (uint256 receiveBaseAmount);\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\n\n    function _BASE_TOKEN_() external view returns (address);\n\n    function _QUOTE_TOKEN_() external view returns (address);\n\n    function getPMMStateForCall() external view returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n    );\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\n\n    \n    function getDODOPoolBidirection(address token0, address token1) external view returns (address[] memory, address[] memory);\n\n    //========== DODOVendingMachine ========\n    \n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP\n    ) external returns (address newVendingMachine);\n    \n    function buyShares(address to) external returns (uint256,uint256,uint256);\n\n\n    //========== DODOPrivatePool ===========\n\n    function createDODOPrivatePool() external returns (address newPrivatePool);\n\n    function initDODOPrivatePool(\n        address dppAddress,\n        address creator,\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 k,\n        uint256 i,\n        bool isOpenTwap\n    ) external;\n\n    function reset(\n        address operator,\n        uint256 newLpFeeRate,\n        uint256 newI,\n        uint256 newK,\n        uint256 baseOutAmount,\n        uint256 quoteOutAmount,\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve\n    ) external returns (bool); \n\n\n    function _OWNER_() external returns (address);\n    \n    //========== CrowdPooling ===========\n\n    function createCrowdPooling() external returns (address payable newCrowdPooling);\n\n    function initCrowdPooling(\n        address cpAddress,\n        address creator,\n        address[] memory tokens,\n        uint256[] memory timeLine,\n        uint256[] memory valueList,\n        bool[] memory switches,\n        int globalQuota\n    ) external;\n\n    function bid(address to) external;\n}"
    },
    "contracts/SmartRoute/intf/IDODOV2Proxy01.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\n\ninterface IDODOV2Proxy01 {\n    function dodoSwapV2ETHToToken(\n        address toToken,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    ) external payable returns (uint256 returnAmount);\n\n    function dodoSwapV2TokenToETH(\n        address fromToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    ) external returns (uint256 returnAmount);\n\n    function dodoSwapV2TokenToToken(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    ) external returns (uint256 returnAmount);\n\n    function createDODOVendingMachine(\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP,\n        uint256 deadLine\n    ) external payable returns (address newVendingMachine, uint256 shares);\n\n    function addDVMLiquidity(\n        address dvmAddress,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        uint8 flag, //  0 - ERC20, 1 - baseInETH, 2 - quoteInETH\n        uint256 deadLine\n    )\n        external\n        payable\n        returns (\n            uint256 shares,\n            uint256 baseAdjustedInAmount,\n            uint256 quoteAdjustedInAmount\n        );\n\n    // function createDODOPrivatePool(\n    //     address baseToken,\n    //     address quoteToken,\n    //     uint256 baseInAmount,\n    //     uint256 quoteInAmount,\n    //     uint256 lpFeeRate,\n    //     uint256 i,\n    //     uint256 k,\n    //     bool isOpenTwap,\n    //     uint256 deadLine\n    // ) external payable returns (address newPrivatePool);\n\n    // function resetDODOPrivatePool(\n    //     address dppAddress,\n    //     uint256[] memory paramList,  //0 - newLpFeeRate, 1 - newI, 2 - newK\n    //     uint256[] memory amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3 - quoteOutAmount\n    //     uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n    //     uint256 minBaseReserve,\n    //     uint256 minQuoteReserve,\n    //     uint256 deadLine\n    // ) external payable;\n\n\n    // function bid(\n    //     address cpAddress,\n    //     uint256 quoteAmount,\n    //     uint8 flag, // 0 - ERC20, 1 - quoteInETH\n    //     uint256 deadLine\n    // ) external payable;\n\n    function addLiquidityToV1(\n        address pair,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        uint256 baseMinShares,\n        uint256 quoteMinShares,\n        uint8 flag, // 0 erc20 Out  1 baseInETH  2 quoteInETH \n        uint256 deadLine\n    ) external payable returns(uint256, uint256);\n\n    function dodoSwapV1(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory dodoPairs,\n        uint256 directions,\n        bool isIncentive,\n        uint256 deadLine\n    ) external payable returns (uint256 returnAmount);\n\n    function externalSwap(\n        address fromToken,\n        address toToken,\n        address approveTarget,\n        address to,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        bytes memory callDataConcat,\n        bool isIncentive,\n        uint256 deadLine\n    ) external payable returns (uint256 returnAmount);\n\n    // function mixSwap(\n    //     address fromToken,\n    //     address toToken,\n    //     uint256 fromTokenAmount,\n    //     uint256 minReturnAmount,\n    //     address[] memory mixAdapters,\n    //     address[] memory mixPairs,\n    //     address[] memory assetTo,\n    //     uint256 directions,\n    //     bool isIncentive,\n    //     uint256 deadLine\n    // ) external payable returns (uint256 returnAmount);\n}\n"
    },
    "contracts/SmartRoute/intf/IUni.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\ninterface IUni {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function token0() external view returns (address);\n    \n    function token1() external view returns (address);\n}"
    },
    "contracts/SmartRoute/lib/UniversalERC20.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\n\nlibrary UniversalERC20 {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    IERC20 private constant ETH_ADDRESS = IERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\n\n    function universalTransfer(\n        IERC20 token,\n        address payable to,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            if (isETH(token)) {\n                (bool success, ) = to.call{value: amount}(\"\");\n                require(success, \"ETH_TRANSFER_FAILED\");\n            } else {\n                token.safeTransfer(to, amount);\n            }\n        }\n    }\n\n    function universalApproveMax(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        uint256 allowance = token.allowance(address(this), to);\n        if (allowance < amount) {\n            if (allowance > 0) {\n                token.safeApprove(to, 0);\n            }\n            token.safeApprove(to, uint256(-1));\n        }\n    }\n\n    function universalBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        if (isETH(token)) {\n            return who.balance;\n        } else {\n            return token.balanceOf(who);\n        }\n    }\n\n    function tokenBalanceOf(IERC20 token, address who) internal view returns (uint256) {\n        return token.balanceOf(who);\n    }\n\n    function isETH(IERC20 token) internal pure returns (bool) {\n        return token == ETH_ADDRESS;\n    }\n}\n"
    },
    "contracts/SmartRoute/proxies/DODOCpProxy.sol": {
      "content": "/*\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n*/\n\npragma solidity 0.6.9;\n\nimport {IDODOApproveProxy} from \"../DODOApproveProxy.sol\";\nimport {IDODOV2} from \"./../intf/IDODOV2.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IWETH} from \"../../intf/IWETH.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\n\n/**\n * @title DODOCpProxy\n * @author DODO Breeder\n *\n * @notice CrowdPooling && UpCrowdPooling Proxy\n */\ncontract DODOCpProxy is ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Storage ============\n\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public immutable _WETH_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _CP_FACTORY_;\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"DODOCpProxy: EXPIRED\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor(\n        address payable weth,\n        address cpFactory,\n        address dodoApproveProxy\n    ) public {\n        _WETH_ = weth;\n        _CP_FACTORY_ = cpFactory;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    //============ CrowdPooling Functions (create) ============\n\n    function createCrowdPooling(\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256[] memory timeLine,\n        uint256[] memory valueList,\n        bool[] memory switches,\n        uint256 deadLine,\n        int globalQuota\n    ) external payable preventReentrant judgeExpired(deadLine) returns (address payable newCrowdPooling) {\n        address _baseToken = baseToken;\n        address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n        \n        newCrowdPooling = IDODOV2(_CP_FACTORY_).createCrowdPooling();\n\n        _deposit(\n            msg.sender,\n            newCrowdPooling,\n            _baseToken,\n            baseInAmount,\n            false\n        );\n        \n        (bool success, ) = newCrowdPooling.call{value: msg.value}(\"\");\n        require(success, \"DODOCpProxy: Transfer failed\");\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = _baseToken;\n        tokens[1] = _quoteToken;\n\n        IDODOV2(_CP_FACTORY_).initCrowdPooling(\n            newCrowdPooling,\n            msg.sender,\n            tokens,\n            timeLine,\n            valueList,\n            switches,\n            globalQuota\n        );\n    }\n\n    function bid(\n        address cpAddress,\n        uint256 quoteAmount,\n        uint8 flag, // 0 - ERC20, 1 - quoteInETH\n        uint256 deadLine\n    ) external payable preventReentrant judgeExpired(deadLine) {\n        _deposit(msg.sender, cpAddress, IDODOV2(cpAddress)._QUOTE_TOKEN_(), quoteAmount, flag == 1);\n        IDODOV2(cpAddress).bid(msg.sender);\n    }\n\n    //====================== internal =======================\n\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                require(msg.value == amount, \"ETH_VALUE_WRONG\");\n                IWETH(_WETH_).deposit{value: amount}();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\n            }\n        } else {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\n        }\n    }\n}"
    },
    "contracts/SmartRoute/proxies/DODODppProxy.sol": {
      "content": "/*\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n*/\n\npragma solidity 0.6.9;\n\nimport {IDODOApproveProxy} from \"../DODOApproveProxy.sol\";\nimport {IDODOV2} from \"./../intf/IDODOV2.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IWETH} from \"../../intf/IWETH.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\n\n// interface IDPPOracle {\n//     function reset(\n//         address assetTo,\n//         uint256 newLpFeeRate,\n//         uint256 newK,\n//         uint256 baseOutAmount,\n//         uint256 quoteOutAmount,\n//         uint256 minBaseReserve,\n//         uint256 minQuoteReserve\n//     ) external returns (bool);\n// }\n\n\n/**\n * @title DODODppProxy\n * @author DODO Breeder\n *\n * @notice DODO Private Pool Proxy\n */\ncontract DODODppProxy is ReentrancyGuard {\n    using SafeMath for uint256;\n    using SafeERC20 for IERC20;\n\n    // ============ Storage ============\n\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public immutable _WETH_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _DPP_FACTORY_;\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"DPPProxy: EXPIRED\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor(\n        address payable weth,\n        address dodoApproveProxy,\n        address dppFactory\n    ) public {\n        _WETH_ = weth;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n        _DPP_FACTORY_ = dppFactory;\n    }\n\n    \n    function createDODOPrivatePool(\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTwap,\n        uint256 deadLine\n    )\n        external\n        payable\n        preventReentrant\n        judgeExpired(deadLine)\n        returns (address newPrivatePool)\n    {\n        newPrivatePool = IDODOV2(_DPP_FACTORY_).createDODOPrivatePool();\n\n        address _baseToken = baseToken;\n        address _quoteToken = quoteToken;\n        _deposit(msg.sender, newPrivatePool, _baseToken, baseInAmount, _baseToken == _ETH_ADDRESS_);\n        _deposit(\n            msg.sender,\n            newPrivatePool,\n            _quoteToken,\n            quoteInAmount,\n            _quoteToken == _ETH_ADDRESS_\n        );\n\n        if (_baseToken == _ETH_ADDRESS_) _baseToken = _WETH_;\n        if (_quoteToken == _ETH_ADDRESS_) _quoteToken = _WETH_;\n\n        IDODOV2(_DPP_FACTORY_).initDODOPrivatePool(\n            newPrivatePool,\n            msg.sender,\n            _baseToken,\n            _quoteToken,\n            lpFeeRate,\n            k,\n            i,\n            isOpenTwap\n        );\n    }\n\n    function resetDODOPrivatePool(\n        address dppAddress,\n        uint256[] memory paramList,  //0 - newLpFeeRate, 1 - newI, 2 - newK\n        uint256[] memory amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3- quoteOutAmount\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n        uint256 minBaseReserve,\n        uint256 minQuoteReserve,\n        uint256 deadLine\n    ) external payable preventReentrant judgeExpired(deadLine) {\n        _deposit(\n            msg.sender,\n            dppAddress,\n            IDODOV2(dppAddress)._BASE_TOKEN_(),\n            amountList[0],\n            flag == 1\n        );\n        _deposit(\n            msg.sender,\n            dppAddress,\n            IDODOV2(dppAddress)._QUOTE_TOKEN_(),\n            amountList[1],\n            flag == 2\n        );\n\n        require(IDODOV2(IDODOV2(dppAddress)._OWNER_()).reset(\n            msg.sender,\n            paramList[0],\n            paramList[1],\n            paramList[2],\n            amountList[2],\n            amountList[3],\n            minBaseReserve,\n            minQuoteReserve\n        ), \"Reset Failed\");\n\n        _withdraw(msg.sender, IDODOV2(dppAddress)._BASE_TOKEN_(), amountList[2], flag == 3);\n        _withdraw(msg.sender, IDODOV2(dppAddress)._QUOTE_TOKEN_(), amountList[3], flag == 4);\n    }\n\n    \n    \n    // DPPOracle\n    // function resetDODOPrivatePool(\n    //     address dppAddress,\n    //     uint256[] memory paramList,  //0 - newLpFeeRate, 1 - newK\n    //     uint256[] memory amountList, //0 - baseInAmount, 1 - quoteInAmount, 2 - baseOutAmount, 3- quoteOutAmount\n    //     uint8 flag, //0 - ERC20, 1 - baseInETH, 2 - quoteInETH, 3 - baseOutETH, 4 - quoteOutETH\n    //     uint256 minBaseReserve,\n    //     uint256 minQuoteReserve,\n    //     uint256 deadLine\n    // ) external payable preventReentrant judgeExpired(deadLine) {\n    //     _deposit(\n    //         msg.sender,\n    //         dppAddress,\n    //         IDODOV2(dppAddress)._BASE_TOKEN_(),\n    //         amountList[0],\n    //         flag == 1\n    //     );\n    //     _deposit(\n    //         msg.sender,\n    //         dppAddress,\n    //         IDODOV2(dppAddress)._QUOTE_TOKEN_(),\n    //         amountList[1],\n    //         flag == 2\n    //     );\n\n    //     require(IDPPOracle(IDODOV2(dppAddress)._OWNER_()).reset(\n    //         msg.sender,\n    //         paramList[0],\n    //         paramList[1],\n    //         amountList[2],\n    //         amountList[3],\n    //         minBaseReserve,\n    //         minQuoteReserve\n    //     ), \"Reset Failed\");\n\n    //     _withdraw(msg.sender, IDODOV2(dppAddress)._BASE_TOKEN_(), amountList[2], flag == 3);\n    //     _withdraw(msg.sender, IDODOV2(dppAddress)._QUOTE_TOKEN_(), amountList[3], flag == 4);\n    // }\n\n    //====================== internal =======================\n\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                IWETH(_WETH_).deposit{value: amount}();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\n            }\n        } else {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\n        }\n    }\n\n    function _withdraw(\n        address payable to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                IWETH(_WETH_).withdraw(amount);\n                (bool success, ) = to.call{value: amount}(\"\");\n                require(success, \"ETH_TRANSFER_FAILED\");\n            }\n        } else {\n            if (amount > 0) {\n                SafeERC20.safeTransfer(IERC20(token), to, amount);\n            }\n        }\n    }\n}"
    },
    "contracts/SmartRoute/proxies/DODODspProxy.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\n\nimport {IDODOApproveProxy} from \"../DODOApproveProxy.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {IWETH} from \"../../intf/IWETH.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {ReentrancyGuard} from \"../../lib/ReentrancyGuard.sol\";\nimport {IDSP} from \"../../DODOStablePool/intf/IDSP.sol\";\nimport {IDSPFactory} from \"../../Factory/DSPFactory.sol\";\n\ninterface IGSP {\n    function buyShares(address to) external returns (uint256 shares, uint256 baseInput, uint256 quoteInput);\n}\n\ninterface IGSPFactory {\n    function createDODOGasSavingPool(\n        address admin,\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 i,\n        uint256 k,\n        uint256 priceLimit,\n        bool isOpenTWAP\n    ) external returns (address newGasSavingPool);\n}\n\n/**\n * @title DODODspProxy\n * @author DODO Breeder\n *\n * @notice Entrance of DODO Stable Pair in DODO platform\n */\ncontract DODODspProxy is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    // ============ Storage ============\n\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public immutable _WETH_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _DSP_FACTORY_;\n    address public immutable _GSP_FACTORY_;\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"DODODspProxy: EXPIRED\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor(\n        address dspFactory,\n        address gspFactory,\n        address payable weth,\n        address dodoApproveProxy\n    ) public {\n        _DSP_FACTORY_ = dspFactory;\n        _GSP_FACTORY_ = gspFactory;\n        _WETH_ = weth;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    // ============ GSP Functions (create & add liquidity) ============\n\n    function createDODOGasSavingPair(\n        address admin,\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 i,\n        uint256 k,\n        uint256 priceLimit,\n        uint256 deadLine\n    )\n        external\n        payable\n        preventReentrant\n        judgeExpired(deadLine)\n        returns (address newGasSavingPair, uint256 shares)\n    {               \n            \n        {\n            address _admin = admin;\n            address _baseToken = baseToken == _ETH_ADDRESS_ ? _WETH_ : baseToken;\n            address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n            uint256 _lpFeeRate = lpFeeRate;\n            uint256 _mtFeeRate = mtFeeRate;\n            uint256 _i = i;\n            uint256 _k = k;\n            uint256 _priceLimit = priceLimit;\n            \n            newGasSavingPair = IGSPFactory(_GSP_FACTORY_).createDODOGasSavingPool(\n                _admin,\n                _baseToken,\n                _quoteToken,\n                _lpFeeRate,\n                _mtFeeRate,\n                _i,\n                _k,\n                _priceLimit,\n                false\n            );\n        }\n\n        {\n            address _baseToken = baseToken;\n            address _quoteToken = quoteToken;\n            uint256 _baseInAmount = baseInAmount;\n            uint256 _quoteInAmount = quoteInAmount;\n            \n            _deposit(\n                msg.sender,\n                newGasSavingPair,\n                _baseToken,\n                _baseInAmount,\n                _baseToken == _ETH_ADDRESS_\n            );\n            _deposit(\n                msg.sender,\n                newGasSavingPair,\n                _quoteToken,\n                _quoteInAmount,\n                _quoteToken == _ETH_ADDRESS_\n            );\n        }\n\n        (shares, , ) = IGSP(newGasSavingPair).buyShares(msg.sender);\n    }\n\n    // ============ DSP Functions (create & add liquidity) ============\n\n    function createDODOStablePair(\n        address baseToken,\n        address quoteToken,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 lpFeeRate,\n        uint256 i,\n        uint256 k,\n        bool isOpenTWAP,\n        uint256 deadLine\n    )\n        external\n        payable\n        preventReentrant\n        judgeExpired(deadLine)\n        returns (address newDODOStablePair, uint256 shares)\n    {\n        {\n            address _baseToken = baseToken == _ETH_ADDRESS_ ? _WETH_ : baseToken;\n            address _quoteToken = quoteToken == _ETH_ADDRESS_ ? _WETH_ : quoteToken;\n            newDODOStablePair = IDSPFactory(_DSP_FACTORY_).createDODOStablePool(\n                _baseToken,\n                _quoteToken,\n                lpFeeRate,\n                i,\n                k,\n                isOpenTWAP\n            );\n        }\n\n        {\n            address _baseToken = baseToken;\n            address _quoteToken = quoteToken;\n            _deposit(\n                msg.sender,\n                newDODOStablePair,\n                _baseToken,\n                baseInAmount,\n                _baseToken == _ETH_ADDRESS_\n            );\n            _deposit(\n                msg.sender,\n                newDODOStablePair,\n                _quoteToken,\n                quoteInAmount,\n                _quoteToken == _ETH_ADDRESS_\n            );\n        }\n\n        (shares, , ) = IDSP(newDODOStablePair).buyShares(msg.sender);\n    }\n\n    function addDSPLiquidity(\n        address dspAddress,\n        uint256 baseInAmount,\n        uint256 quoteInAmount,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        uint8 flag, // 0 - ERC20, 1 - baseInETH, 2 - quoteInETH\n        uint256 deadLine\n    )\n        external\n        payable\n        preventReentrant\n        judgeExpired(deadLine)\n        returns (\n            uint256 shares,\n            uint256 baseAdjustedInAmount,\n            uint256 quoteAdjustedInAmount\n        )\n    {\n        address _dsp = dspAddress;\n        (baseAdjustedInAmount, quoteAdjustedInAmount) = _addDSPLiquidity(\n            _dsp,\n            baseInAmount,\n            quoteInAmount\n        );\n        require(\n            baseAdjustedInAmount >= baseMinAmount && quoteAdjustedInAmount >= quoteMinAmount,\n            \"DODODspProxy: deposit amount is not enough\"\n        );\n\n        _deposit(msg.sender, _dsp, IDSP(_dsp)._BASE_TOKEN_(), baseAdjustedInAmount, flag == 1);\n        _deposit(msg.sender, _dsp, IDSP(_dsp)._QUOTE_TOKEN_(), quoteAdjustedInAmount, flag == 2);\n        \n        (shares, , ) = IDSP(_dsp).buyShares(msg.sender);\n\n        // refund dust eth\n        if (flag == 1 && msg.value > baseAdjustedInAmount) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value - baseAdjustedInAmount}(\"\");\n            require(success, \"DODODspProxy: ETH transfer failed\");\n        }\n        if (flag == 2 && msg.value > quoteAdjustedInAmount) {\n            (bool success, ) = payable(msg.sender).call{value: msg.value - quoteAdjustedInAmount}(\"\");\n            require(success, \"DODODspProxy: ETH transfer failed\");\n        }\n    }\n\n\n    // =================== internal functions =====================\n\n    function _addDSPLiquidity(\n        address dspAddress,\n        uint256 baseInAmount,\n        uint256 quoteInAmount\n    ) internal view returns (uint256 baseAdjustedInAmount, uint256 quoteAdjustedInAmount) {\n        (uint256 baseReserve, uint256 quoteReserve) = IDSP(dspAddress).getVaultReserve();\n        if (quoteReserve == 0 && baseReserve == 0) {\n            uint256 i = IDSP(dspAddress)._I_();\n            uint256 shares = quoteInAmount < DecimalMath.mulFloor(baseInAmount, i)\n                ? DecimalMath.divFloor(quoteInAmount, i)\n                : baseInAmount;\n            baseAdjustedInAmount = shares;\n            quoteAdjustedInAmount = DecimalMath.mulFloor(shares, i);\n        }\n        if (quoteReserve > 0 && baseReserve > 0) {\n            uint256 baseIncreaseRatio = DecimalMath.divFloor(baseInAmount, baseReserve);\n            uint256 quoteIncreaseRatio = DecimalMath.divFloor(quoteInAmount, quoteReserve);\n            if (baseIncreaseRatio <= quoteIncreaseRatio) {\n                baseAdjustedInAmount = baseInAmount;\n                quoteAdjustedInAmount = DecimalMath.mulFloor(quoteReserve, baseIncreaseRatio);\n            } else {\n                quoteAdjustedInAmount = quoteInAmount;\n                baseAdjustedInAmount = DecimalMath.mulFloor(baseReserve, quoteIncreaseRatio);\n            }\n        }\n    }\n\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                IWETH(_WETH_).deposit{value: amount}();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\n            }\n        } else {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\n        }\n    }\n}"
    },
    "contracts/SmartRoute/proxies/DODOMineV3Proxy.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {InitializableOwnable} from \"../../lib/InitializableOwnable.sol\";\nimport {IDODOApproveProxy} from \"../DODOApproveProxy.sol\";\nimport {IRewardVault} from \"../../DODOToken/DODOMineV3/RewardVault.sol\";\nimport {IDODOMineV3Registry} from \"../../Factory/Registries/DODOMineV3Registry.sol\";\nimport {ICloneFactory} from \"../../lib/CloneFactory.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\n\ninterface IMineV3 {\n    function init(address owner, address token) external;\n\n    function addRewardToken(\n        address rewardToken,\n        uint256 rewardPerBlock,\n        uint256 startBlock,\n        uint256 endBlock\n    ) external;\n\n    function directTransferOwnership(address newOwner) external;\n\n    function getVaultByRewardToken(address rewardToken) external view returns(address);\n}\n\n/**\n * @title DODOMineV3 Proxy\n * @author DODO Breeder\n *\n * @notice Create And Register DODOMineV3 Contracts \n */\ncontract DODOMineV3Proxy is InitializableOwnable {\n    using SafeMath for uint256;\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public immutable _DODO_APPROVE_PROXY_;\n    address public immutable _DODO_MINEV3_REGISTRY_;\n    address public _MINEV3_TEMPLATE_;\n\n\n    // ============ Events ============\n    event DepositRewardToVault(address mine, address rewardToken, uint256 amount);\n    event DepositRewardToMine(address mine, address rewardToken, uint256 amount);\n    event CreateMineV3(address account, address mineV3, uint256 platform);\n    event ChangeMineV3Template(address mineV3);\n\n    constructor(\n        address cloneFactory,\n        address mineTemplate,\n        address dodoApproveProxy,\n        address dodoMineV3Registry\n    ) public {\n        _CLONE_FACTORY_ = cloneFactory;\n        _MINEV3_TEMPLATE_ = mineTemplate;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n        _DODO_MINEV3_REGISTRY_ = dodoMineV3Registry;\n    }\n\n    // ============ Functions ============\n\n    function createDODOMineV3(\n        address stakeToken,\n        bool isLpToken,\n        uint256 platform,\n        address[] memory rewardTokens,\n        uint256[] memory rewardPerBlock,\n        uint256[] memory startBlock,\n        uint256[] memory endBlock\n    ) external returns (address newMineV3) {\n        require(rewardTokens.length > 0, \"REWARD_EMPTY\");\n        require(rewardTokens.length == rewardPerBlock.length, \"REWARD_PARAM_NOT_MATCH\");\n        require(startBlock.length == rewardPerBlock.length, \"REWARD_PARAM_NOT_MATCH\");\n        require(endBlock.length == rewardPerBlock.length, \"REWARD_PARAM_NOT_MATCH\");\n\n        newMineV3 = ICloneFactory(_CLONE_FACTORY_).clone(_MINEV3_TEMPLATE_);\n\n        IMineV3(newMineV3).init(address(this), stakeToken);\n\n        for(uint i = 0; i<rewardTokens.length; i++) {\n            uint256 rewardAmount = rewardPerBlock[i].mul(endBlock[i].sub(startBlock[i]));\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(rewardTokens[i], msg.sender, newMineV3, rewardAmount);\n            IMineV3(newMineV3).addRewardToken(\n                rewardTokens[i],\n                rewardPerBlock[i],\n                startBlock[i],\n                endBlock[i]\n            );\n        }\n\n        IMineV3(newMineV3).directTransferOwnership(msg.sender);\n\n        IDODOMineV3Registry(_DODO_MINEV3_REGISTRY_).addMineV3(newMineV3, isLpToken, stakeToken);\n\n        emit CreateMineV3(msg.sender, newMineV3, platform);\n    }\n\n    function depositRewardToVault(\n        address mineV3,\n        address rewardToken,\n        uint256 amount\n    ) external {    \n        address rewardVault = IMineV3(mineV3).getVaultByRewardToken(rewardToken);\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(rewardToken, msg.sender, rewardVault, amount);\n        IRewardVault(rewardVault).syncValue();\n\n        emit DepositRewardToVault(mineV3,rewardToken,amount);\n    }\n\n    function depositRewardToMine(\n        address mineV3,\n        address rewardToken,\n        uint256 amount\n    ) external {\n        require(mineV3 != address(0), \"MINE_EMPTY\");\n        IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(rewardToken, msg.sender, mineV3, amount);\n\n        emit DepositRewardToMine(mineV3,rewardToken,amount);\n    }\n\n    // ============ Admin Operation Functions ============\n    \n    function updateMineV3Template(address _newMineV3Template) external onlyOwner {\n        _MINEV3_TEMPLATE_ = _newMineV3Template;\n        emit ChangeMineV3Template(_newMineV3Template);\n    }\n\n    function version() virtual external pure returns (string memory) {\n        return \"MineV3Proxy 0.0.1\";\n    }\n}\n"
    },
    "contracts/SmartRoute/proxies/DODORouteProxy.sol": {
      "content": "/*\n\n    Copyright 2021 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.6.9;\npragma experimental ABIEncoderV2;\n\nimport {IDODOApproveProxy} from \"../DODOApproveProxy.sol\";\nimport {IERC20} from \"../../intf/IERC20.sol\";\nimport {IWETH} from \"../../intf/IWETH.sol\";\nimport {SafeMath} from \"../../lib/SafeMath.sol\";\nimport {UniversalERC20} from \"../lib/UniversalERC20.sol\";\nimport {SafeERC20} from \"../../lib/SafeERC20.sol\";\nimport {IDODOAdapter} from \"../intf/IDODOAdapter.sol\";\n\n\n/**\n * @title DODORouteProxy\n * @author DODO Breeder\n *\n * @notice Entrance of Split trading in DODO platform\n */\ncontract DODORouteProxy {\n    using SafeMath for uint256;\n    using UniversalERC20 for IERC20;\n\n    // ============ Storage ============\n\n    address constant _ETH_ADDRESS_ = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    address public immutable _WETH_;\n    address public immutable _DODO_APPROVE_PROXY_;\n\n    struct PoolInfo {\n        uint256 direction;\n        uint256 poolEdition;\n        uint256 weight;\n        address pool;\n        address adapter;\n        bytes moreInfo;\n    }\n\n    // ============ Events ============\n\n     event OrderHistory(\n        address fromToken,\n        address toToken,\n        address sender,\n        uint256 fromAmount,\n        uint256 returnAmount\n    );\n\n    // ============ Modifiers ============\n\n    modifier judgeExpired(uint256 deadLine) {\n        require(deadLine >= block.timestamp, \"DODORouteProxy: EXPIRED\");\n        _;\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n\n    constructor (\n        address payable weth,\n        address dodoApproveProxy\n    ) public {\n        _WETH_ = weth;\n        _DODO_APPROVE_PROXY_ = dodoApproveProxy;\n    }\n\n    function mixSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        address[] memory mixAdapters,\n        address[] memory mixPairs,\n        address[] memory assetTo,\n        uint256 directions,\n        bytes[] memory moreInfos,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(mixPairs.length > 0, \"DODORouteProxy: PAIRS_EMPTY\");\n        require(mixPairs.length == mixAdapters.length, \"DODORouteProxy: PAIR_ADAPTER_NOT_MATCH\");\n        require(mixPairs.length == assetTo.length - 1, \"DODORouteProxy: PAIR_ASSETTO_NOT_MATCH\");\n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n\n        address _fromToken = fromToken;\n        address _toToken = toToken;\n        uint256 _fromTokenAmount = fromTokenAmount;\n        \n        uint256 toTokenOriginBalance = IERC20(_toToken).universalBalanceOf(msg.sender);\n        \n        _deposit(msg.sender, assetTo[0], _fromToken, _fromTokenAmount, _fromToken == _ETH_ADDRESS_);\n\n        for (uint256 i = 0; i < mixPairs.length; i++) {\n            if (directions & 1 == 0) {\n                IDODOAdapter(mixAdapters[i]).sellBase(assetTo[i + 1],mixPairs[i], moreInfos[i]);\n            } else {\n                IDODOAdapter(mixAdapters[i]).sellQuote(assetTo[i + 1],mixPairs[i], moreInfos[i]);\n            }\n            directions = directions >> 1;\n        }\n\n        if(_toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            (bool success, ) = payable(msg.sender).call{value: returnAmount}(\"\");\n            require(success, \"DODORouteProxy: ETH transfer failed\");\n        }else {\n            returnAmount = IERC20(_toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n\n        emit OrderHistory(\n            _fromToken,\n            _toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );\n    }\n\n    function dodoMutliSwap(\n        uint256 fromTokenAmount,\n        uint256 minReturnAmount,\n        uint256[] memory totalWeight,\n        uint256[] memory splitNumber,\n        address[] memory midToken,\n        address[] memory assetFrom,\n        bytes[] memory sequence,\n        uint256 deadLine\n    ) external payable judgeExpired(deadLine) returns (uint256 returnAmount) {\n        require(assetFrom.length == splitNumber.length, 'DODORouteProxy: PAIR_ASSETTO_NOT_MATCH');        \n        require(minReturnAmount > 0, \"DODORouteProxy: RETURN_AMOUNT_ZERO\");\n        \n        uint256 _fromTokenAmount = fromTokenAmount;\n        address fromToken = midToken[0];\n        address toToken = midToken[midToken.length - 1];\n\n        uint256 toTokenOriginBalance = IERC20(toToken).universalBalanceOf(msg.sender);\n\n        _deposit(msg.sender, assetFrom[0], fromToken, _fromTokenAmount, fromToken == _ETH_ADDRESS_);\n\n        _multiSwap(totalWeight, midToken, splitNumber, sequence, assetFrom);\n    \n        if(toToken == _ETH_ADDRESS_) {\n            returnAmount = IWETH(_WETH_).balanceOf(address(this));\n            IWETH(_WETH_).withdraw(returnAmount);\n            (bool success, ) = payable(msg.sender).call{value: returnAmount}(\"\");\n            require(success, \"DODORouteProxy: ETH transfer failed\");\n        }else {\n            returnAmount = IERC20(toToken).tokenBalanceOf(msg.sender).sub(toTokenOriginBalance);\n        }\n\n        require(returnAmount >= minReturnAmount, \"DODORouteProxy: Return amount is not enough\");\n    \n        emit OrderHistory(\n            fromToken,\n            toToken,\n            msg.sender,\n            _fromTokenAmount,\n            returnAmount\n        );    \n    }\n\n    \n    //====================== internal =======================\n\n    function _multiSwap(\n        uint256[] memory totalWeight,\n        address[] memory midToken,\n        uint256[] memory splitNumber,\n        bytes[] memory swapSequence,\n        address[] memory assetFrom\n    ) internal { \n        for(uint256 i = 1; i < splitNumber.length; i++) { \n            // define midtoken address, ETH -> WETH address\n            uint256 curTotalAmount = IERC20(midToken[i]).tokenBalanceOf(assetFrom[i-1]);\n            uint256 curTotalWeight = totalWeight[i-1];\n            \n            for(uint256 j = splitNumber[i-1]; j < splitNumber[i]; j++) {\n                PoolInfo memory curPoolInfo;\n                {\n                    (address pool, address adapter, uint256 mixPara, bytes memory moreInfo) = abi.decode(swapSequence[j], (address, address, uint256, bytes));\n                \n                    curPoolInfo.direction = mixPara >> 17;\n                    curPoolInfo.weight = (0xffff & mixPara) >> 9;\n                    curPoolInfo.poolEdition = (0xff & mixPara);\n                    curPoolInfo.pool = pool;\n                    curPoolInfo.adapter = adapter;\n                    curPoolInfo.moreInfo = moreInfo;\n                }\n\n                if(assetFrom[i-1] == address(this)) {\n                    uint256 curAmount = curTotalAmount.mul(curPoolInfo.weight).div(curTotalWeight);\n            \n                    if(curPoolInfo.poolEdition == 1) {   \n                        //For using transferFrom pool (like dodoV1, Curve)\n                        IERC20(midToken[i]).transfer(curPoolInfo.adapter, curAmount);\n                    } else {\n                        //For using transfer pool (like dodoV2)\n                        IERC20(midToken[i]).transfer(curPoolInfo.pool, curAmount);\n                    }\n                }\n                \n                if(curPoolInfo.direction == 0) {\n                    IDODOAdapter(curPoolInfo.adapter).sellBase(assetFrom[i], curPoolInfo.pool, curPoolInfo.moreInfo);\n                } else {\n                    IDODOAdapter(curPoolInfo.adapter).sellQuote(assetFrom[i], curPoolInfo.pool, curPoolInfo.moreInfo);\n                }\n            }\n        }\n    }\n\n    function _deposit(\n        address from,\n        address to,\n        address token,\n        uint256 amount,\n        bool isETH\n    ) internal {\n        if (isETH) {\n            if (amount > 0) {\n                require(msg.value == amount, \"ETH_VALUE_WRONG\");\n                IWETH(_WETH_).deposit{value: amount}();\n                if (to != address(this)) SafeERC20.safeTransfer(IERC20(_WETH_), to, amount);\n            }\n        } else {\n            IDODOApproveProxy(_DODO_APPROVE_PROXY_).claimTokens(token, from, to, amount);\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "mode": "3"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "forceEVMLA": false,
    "detectMissingLibraries": false,
    "enableEraVMExtensions": false,
    "libraries": {}
  }
}