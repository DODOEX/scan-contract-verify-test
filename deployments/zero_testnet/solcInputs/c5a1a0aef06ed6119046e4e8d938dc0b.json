{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/GasSavingPool/impl/GSP.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {GSPTrader} from \"./GSPTrader.sol\";\nimport {GSPFunding} from \"./GSPFunding.sol\";\nimport {GSPVault} from \"./GSPVault.sol\";\n\n/**\n * @title DODO GasSavingPool\n * @author DODO Breeder\n *\n * @notice DODO GasSavingPool initialization\n */\ncontract GSP is GSPTrader, GSPFunding {\n    /**\n     * @notice Function will be called in factory, init risk should not be included.\n     * @param maintainer The dodo's address, who can claim mtFee and own this pool\n     * @param admin oracle owner address, who can set price.\n     * @param baseTokenAddress The base token address\n     * @param quoteTokenAddress The quote token address\n     * @param lpFeeRate The rate of lp fee, with 18 decimal\n     * @param mtFeeRate The rate of mt fee, with 18 decimal\n     * @param i The oracle price, possible to be changed only by maintainer\n     * @param k The swap curve parameter\n     * @param priceLimit The limit of the setting range of the I\n     * @param isOpenTWAP Useless, always false, just for compatible with old version pool\n     */\n    function init(\n        address maintainer,\n        address admin,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 i,\n        uint256 k,\n        uint256 priceLimit,\n        bool isOpenTWAP\n    ) external {\n        // GSP can only be initialized once\n        require(!_GSP_INITIALIZED_, \"GSP_INITIALIZED\");\n        // _GSP_INITIALIZED_ is set to true after initialization\n        _GSP_INITIALIZED_ = true;\n        // baseTokenAddress and quoteTokenAddress should not be the same\n        require(baseTokenAddress != quoteTokenAddress, \"BASE_QUOTE_CAN_NOT_BE_SAME\");\n        // _BASE_TOKEN_ and _QUOTE_TOKEN_ should be valid ERC20 tokens\n        _BASE_TOKEN_ = IERC20(baseTokenAddress);\n        _QUOTE_TOKEN_ = IERC20(quoteTokenAddress);\n\n        // i should be greater than 0 and less than 10**36\n        require(i > 0 && i <= 10**36);\n        _I_ = i;\n        // k should be greater than 0 and less than 10**18\n        require(k <= 10**18);\n        _K_ = k;\n\n        // _LP_FEE_RATE_ is set when initialization\n        _LP_FEE_RATE_ = lpFeeRate;\n        // _MT_FEE_RATE_ is set when initialization\n        _MT_FEE_RATE_ = mtFeeRate;\n        // _MAINTAINER_ is set when initialization, the address receives the fee\n        _MAINTAINER_ = maintainer;\n        _ADMIN_ = admin;\n\n        _PRICE_LIMIT_ = priceLimit;\n        // _IS_OPEN_TWAP_ is always false\n        _IS_OPEN_TWAP_ = false;\n\n\n        string memory connect = \"_\";\n        string memory suffix = \"GSP\";\n        // name of the shares is the combination of suffix, connect and string of the GSP\n        name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\n        // symbol of the shares is GLP\n        symbol = \"GLP\";\n        // decimals of the shares is the same as the base token decimals\n        decimals = IERC20Metadata(baseTokenAddress).decimals();\n        // initialize DOMAIN_SEPARATOR\n        buildDomainSeparator();\n        // ==========================================================================\n    }\n\n    // ============================== Permit ====================================\n    /**\n     * @notice DOMAIN_SEPARATOR is used for approve by signature\n     */\n    function buildDomainSeparator() public returns (bytes32){\n        string memory connect = \"_\";\n        string memory suffix = \"GSP\";\n        // name of the shares is the combination of suffix, connect and string of the GSP\n        string memory name = string(abi.encodePacked(suffix, connect, addressToShortString(address(this))));\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                keccak256(bytes(name)),\n                keccak256(bytes(\"1\")),\n                block.chainid,\n                address(this)\n            )\n        );\n        return DOMAIN_SEPARATOR;\n    }\n\n    /**\n     * @notice Convert the address to a shorter string\n     * @param _addr The address to convert\n     * @return A string representation of _addr in hexadecimal\n     */\n    function addressToShortString(address _addr) public pure returns (string memory) {\n        bytes32 value = bytes32(uint256(uint160(_addr)));\n        bytes memory alphabet = \"0123456789abcdef\";\n\n        bytes memory str = new bytes(8);\n        for (uint256 i = 0; i < 4; i++) {\n            str[i * 2] = alphabet[uint8(value[i + 12] >> 4)];\n            str[1 + i * 2] = alphabet[uint8(value[i + 12] & 0x0f)];\n        }\n        return string(str);\n    }\n\n    // ============ Version Control ============\n    /**\n     * @notice Return the version of DODOGasSavingPool\n     * @return The current version is 1.0.1\n     */\n    function version() external pure returns (string memory) {\n        return \"GSP 1.0.1\";\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/GasSavingPool/impl/GSPFunding.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\n\npragma solidity 0.8.16;\n\nimport {GSPVault} from \"./GSPVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\n/// @notice this part focus on Lp tokens, mint and burn\ncontract GSPFunding is GSPVault {\n    // ============ Events ============\n\n    event BuyShares(address to, uint256 increaseShares, uint256 totalShares);\n\n    event SellShares(address payer, address to, uint256 decreaseShares, uint256 totalShares);\n\n    // ============ Buy & Sell Shares ============\n    \n    /// @notice User mint Lp token and deposit tokens, the result is rounded down\n    /// @dev User first transfer baseToken and quoteToken to GSP, then call buyShares\n    /// @param to The address will receive shares\n    /// @return shares The amount of shares user will receive\n    /// @return baseInput The amount of baseToken user transfer to GSP\n    /// @return quoteInput The amount of quoteToken user transfer to GSP\n    function buyShares(address to)\n        external\n        nonReentrant\n        returns (\n            uint256 shares,\n            uint256 baseInput,\n            uint256 quoteInput\n        )\n    {\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The reserve of baseToken and quoteToken\n        uint256 baseReserve = _BASE_RESERVE_;\n        uint256 quoteReserve = _QUOTE_RESERVE_;\n\n        // The amount of baseToken and quoteToken user transfer to GSP\n        baseInput = baseBalance - baseReserve;\n        quoteInput = quoteBalance - quoteReserve;\n\n        // BaseToken should be transferred to GSP before calling buyShares\n        require(baseInput > 0, \"NO_BASE_INPUT\");\n\n        // Round down when withdrawing. Therefore, never be a situation occuring balance is 0 but totalsupply is not 0\n        // But May Happen，reserve >0 But totalSupply = 0\n        if (totalSupply == 0) {\n            // case 1. initial supply\n            require(quoteBalance > 0, \"ZERO_QUOTE_AMOUNT\");\n            // The shares will be minted to user\n            shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_)\n                ? DecimalMath.divFloor(quoteBalance, _I_)\n                : baseBalance;\n            // The target will be updated\n            _BASE_TARGET_ = uint112(shares);\n            _QUOTE_TARGET_ = uint112(DecimalMath.mulFloor(shares, _I_));\n            require(_QUOTE_TARGET_ > 0, \"QUOTE_TARGET_IS_ZERO\");\n            // Lock 1001 shares permanently in first deposit \n            require(shares > 2001, \"MINT_AMOUNT_NOT_ENOUGH\");\n            _mint(address(0), 1001);\n            shares -= 1001;\n        } else if (baseReserve > 0 && quoteReserve > 0) {\n            // case 2. normal case\n            uint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);\n            uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);\n            uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;\n            // The shares will be minted to user\n            shares = DecimalMath.mulFloor(totalSupply, mintRatio);\n\n            // The target will be updated\n            _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) + (DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)));\n            _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) + (DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)));\n        }\n        // The shares will be minted to user\n        // The reserve will be updated\n        _mint(to, shares);\n        _setReserve(baseBalance, quoteBalance);\n        emit BuyShares(to, shares, _SHARES_[to]);\n    }\n\n    /// @notice User burn their lp and withdraw their tokens, the result is rounded down\n    /// @dev User call sellShares, the calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n    /// @param shareAmount The amount of shares user want to sell\n    /// @param to The address will receive baseToken and quoteToken\n    /// @param baseMinAmount The minimum amount of baseToken user want to receive\n    /// @param quoteMinAmount The minimum amount of quoteToken user want to receive\n    /// @param data The data will be passed to callee contract\n    /// @param deadline The deadline of this transaction\n    function sellShares(\n        uint256 shareAmount,\n        address to,\n        uint256 baseMinAmount,\n        uint256 quoteMinAmount,\n        bytes calldata data,\n        uint256 deadline\n    ) external nonReentrant returns (uint256 baseAmount, uint256 quoteAmount) {\n        // The deadline should be greater than current timestamp\n        require(deadline >= block.timestamp, \"TIME_EXPIRED\");\n        // The amount of shares user want to sell should be less than user's balance\n        require(shareAmount <= _SHARES_[msg.sender], \"GLP_NOT_ENOUGH\");\n\n        // The balance of baseToken and quoteToken should be the balance minus the fee\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        // The total shares of GSP\n        uint256 totalShares = totalSupply;\n\n        // The amount of baseToken and quoteToken user will receive is calculated by the ratio of user's shares to total shares\n        baseAmount = baseBalance * shareAmount / totalShares;\n        quoteAmount = quoteBalance * shareAmount / totalShares;\n        \n        // The target will be updated\n        _BASE_TARGET_ = uint112(uint256(_BASE_TARGET_) - DecimalMath._divCeil((uint256(_BASE_TARGET_) * (shareAmount)), totalShares));\n        _QUOTE_TARGET_ = uint112(uint256(_QUOTE_TARGET_) - DecimalMath._divCeil((uint256(_QUOTE_TARGET_) * (shareAmount)), totalShares));\n        \n        // The calculated baseToken and quoteToken amount should geater than minBaseToken and minQuoteToken\n        require(\n            baseAmount >= baseMinAmount && quoteAmount >= quoteMinAmount,\n            \"WITHDRAW_NOT_ENOUGH\"\n        );\n\n        // The shares will be burned from user\n        // The baseToken and quoteToken will be transferred to user\n        // The reserve will be synced\n        _burn(msg.sender, shareAmount);\n        _transferBaseOut(to, baseAmount);\n        _transferQuoteOut(to, quoteAmount);\n        _sync();\n\n        // If the data is not empty, the callee contract will be called\n        if (data.length > 0) {\n            //Same as DVM \n            IDODOCallee(to).DVMSellShareCall(\n                msg.sender,\n                shareAmount,\n                baseAmount,\n                quoteAmount,\n                data\n            );\n        }\n\n        emit SellShares(msg.sender, to, shareAmount, _SHARES_[msg.sender]);\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/GasSavingPool/impl/GSPStorage.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport {DODOMath} from \"../../lib/DODOMath.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\n\n/// @notice this contract is used for store state and read state\ncontract GSPStorage is ReentrancyGuard {\n\n    // ============ Storage for Setup ============\n    // _GSP_INITIALIZED_ will be set to true when the init function is called\n    bool internal _GSP_INITIALIZED_;\n    // GSP does not open TWAP by default\n    // _IS_OPEN_TWAP_ can be set to true when the init function is called\n    bool public _IS_OPEN_TWAP_ = false;\n    \n    // ============ Core Address ============\n    // _MAINTAINER_ is the maintainer of GSP\n    address public _MAINTAINER_;\n    // _ADMIN_ can set price\n    address public _ADMIN_;\n    // _BASE_TOKEN_ and _QUOTE_TOKEN_ should be ERC20 token\n    IERC20 public _BASE_TOKEN_;\n    IERC20 public _QUOTE_TOKEN_;\n    // _BASE_RESERVE_ and _QUOTE_RESERVE_ are the current reserves of the GSP\n    uint112 public _BASE_RESERVE_;\n    uint112 public _QUOTE_RESERVE_;\n    // _BLOCK_TIMESTAMP_LAST_ is used when calculating TWAP\n    uint32 public _BLOCK_TIMESTAMP_LAST_;\n    // _BASE_PRICE_CUMULATIVE_LAST_ is used when calculating TWAP\n    uint256 public _BASE_PRICE_CUMULATIVE_LAST_;\n\n    // _BASE_TARGET_ and _QUOTE_TARGET_ are recalculated when the pool state changes\n    uint112 public _BASE_TARGET_;\n    uint112 public _QUOTE_TARGET_;\n    // _RState_ is the current R state of the GSP\n    uint32 public _RState_;\n\n    // ============ Shares (ERC20) ============\n    // symbol is the symbol of the shares\n    string public symbol;\n    // decimals is the decimals of the shares\n    uint8 public decimals;\n    // name is the name of the shares\n    string public name;\n    // totalSupply is the total supply of the shares\n    uint256 public totalSupply;\n    // _SHARES_ is the mapping from account to share balance, record the share balance of each account\n    mapping(address => uint256) internal _SHARES_;\n    mapping(address => mapping(address => uint256)) internal _ALLOWED_;\n\n    // ================= Permit ======================\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH =\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint256) public nonces;\n\n    // ============ Variables for Pricing ============\n    // _MT_FEE_RATE_ is the fee rate of mt fee\n    uint256 public _MT_FEE_RATE_;\n    // _LP_FEE_RATE_ is the fee rate of lp fee\n    uint256 public _LP_FEE_RATE_;\n    uint256 public _K_;\n    uint256 public _I_;\n    // _PRICE_LIMIT_ is used to limit the setting range of I\n    uint256 public _PRICE_LIMIT_;\n\n    // ============ Mt Fee ============\n    // _MT_FEE_BASE_ represents the mt fee in base token\n    uint256 public _MT_FEE_BASE_;\n    // _MT_FEE_QUOTE_ represents the mt fee in quote token\n    uint256 public _MT_FEE_QUOTE_;\n    // _MT_FEE_RATE_MODEL_ is useless, just for compatible with old version pool\n    address public _MT_FEE_RATE_MODEL_ = address(0);\n\n    // ============ Helper Functions ============\n\n    /// @notice Return the PMM state of the pool from inner or outside\n    /// @dev B0 and Q0 are calculated in adjustedTarget\n    /// @return state The current PMM state\n    function getPMMState() public view returns (PMMPricing.PMMState memory state) {\n        state.i = _I_;\n        state.K = _K_;\n        state.B = _BASE_RESERVE_;\n        state.Q = _QUOTE_RESERVE_;\n        state.B0 = _BASE_TARGET_; // will be calculated in adjustedTarget\n        state.Q0 = _QUOTE_TARGET_;\n        state.R = PMMPricing.RState(_RState_);\n        PMMPricing.adjustedTarget(state);\n    }\n\n    /// @notice Return the PMM state variables used for routeHelpers\n    /// @return i The price index\n    /// @return K The K value\n    /// @return B The base token reserve\n    /// @return Q The quote token reserve\n    /// @return B0 The base token target\n    /// @return Q0 The quote token target\n    /// @return R The R state of the pool\n    function getPMMStateForCall()\n        external\n        view\n        returns (\n            uint256 i,\n            uint256 K,\n            uint256 B,\n            uint256 Q,\n            uint256 B0,\n            uint256 Q0,\n            uint256 R\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        i = state.i;\n        K = state.K;\n        B = state.B;\n        Q = state.Q;\n        B0 = state.B0;\n        Q0 = state.Q0;\n        R = uint256(state.R);\n    }\n\n    /// @notice Return the adjusted mid price\n    /// @return midPrice The current mid price\n    function getMidPrice() public view returns (uint256 midPrice) {\n        return PMMPricing.getMidPrice(getPMMState());\n    }\n\n    /// @notice Return the total mt fee maintainer can claim\n    /// @dev The total mt fee is represented in two types: in base token and in quote token\n    /// @return mtFeeBase The total mt fee in base token\n    /// @return mtFeeQuote The total mt fee in quote token\n    function getMtFeeTotal() public view returns (uint256 mtFeeBase, uint256 mtFeeQuote) {\n        mtFeeBase = _MT_FEE_BASE_;\n        mtFeeQuote = _MT_FEE_QUOTE_;\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/GasSavingPool/impl/GSPTrader.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport {GSPVault} from \"./GSPVault.sol\";\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {IDODOCallee} from \"../../intf/IDODOCallee.sol\";\n\n/// @notice this contract deal with swap\ncontract GSPTrader is GSPVault {\n\n    // ============ Events ============\n\n    event DODOSwap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount,\n        uint256 toAmount,\n        address trader,\n        address receiver\n    );\n\n    event DODOFlashLoan(address borrower, address assetTo, uint256 baseAmount, uint256 quoteAmount);\n\n    event RChange(PMMPricing.RState newRState);\n\n    // ============ Trade Functions ============\n    /**\n     * @notice User sell base tokens, user pay tokens first. Must be used with a router\n     * @dev The base token balance is the actual balance minus the mt fee\n     * @param to The recipient of the output\n     * @return receiveQuoteAmount Amount of quote token received\n     */\n    function sellBase(address to) external nonReentrant returns (uint256 receiveQuoteAmount) {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n        uint256 mtFee;\n        uint256 newBaseTarget;\n        PMMPricing.RState newRState;\n        // calculate the amount of quote token to receive and mt fee\n        (receiveQuoteAmount, mtFee, newRState, newBaseTarget) = querySellBase(tx.origin, baseInput);\n        // transfer quote token to recipient\n        _transferQuoteOut(to, receiveQuoteAmount);\n        // update mt fee in quote token\n        _MT_FEE_QUOTE_ = _MT_FEE_QUOTE_ + mtFee;\n        \n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {    \n            require(newBaseTarget <= type(uint112).max, \"OVERFLOW\");\n            _BASE_TARGET_ = uint112(newBaseTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n        // update reserve\n        _setReserve(baseBalance, _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_);\n\n        emit DODOSwap(\n            address(_BASE_TOKEN_),\n            address(_QUOTE_TOKEN_),\n            baseInput,\n            receiveQuoteAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    /**\n     * @notice User sell quote tokens, user pay tokens first. Must be used with a router\n     * @param to The recipient of the output\n     * @return receiveBaseAmount Amount of base token received\n     */\n    function sellQuote(address to) external nonReentrant returns (uint256 receiveBaseAmount) {\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n        uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n        uint256 mtFee;\n        uint256 newQuoteTarget;\n        PMMPricing.RState newRState;\n        // calculate the amount of base token to receive and mt fee\n        (receiveBaseAmount, mtFee, newRState, newQuoteTarget) = querySellQuote(\n            tx.origin,\n            quoteInput\n        );\n        // transfer base token to recipient\n        _transferBaseOut(to, receiveBaseAmount);\n        // update mt fee in base token\n        _MT_FEE_BASE_ = _MT_FEE_BASE_ + mtFee;\n\n        // update TARGET\n        if (_RState_ != uint32(newRState)) {\n            require(newQuoteTarget <= type(uint112).max, \"OVERFLOW\");\n            _QUOTE_TARGET_ = uint112(newQuoteTarget);\n            _RState_ = uint32(newRState);\n            emit RChange(newRState);\n        }\n        // update reserve\n        _setReserve((_BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_), quoteBalance);\n\n        emit DODOSwap(\n            address(_QUOTE_TOKEN_),\n            address(_BASE_TOKEN_),\n            quoteInput,\n            receiveBaseAmount,\n            msg.sender,\n            to\n        );\n    }\n\n    /**\n     * @notice inner flashloan, pay tokens out first, call external contract and check tokens left\n     * @param baseAmount The base token amount user require\n     * @param quoteAmount The quote token amount user require\n     * @param assetTo The address who uses above tokens\n     * @param data The external contract's callData\n     */\n    function flashLoan(\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        address assetTo,\n        bytes calldata data\n    ) external nonReentrant {\n        _transferBaseOut(assetTo, baseAmount);\n        _transferQuoteOut(assetTo, quoteAmount);\n\n        if (data.length > 0)\n            IDODOCallee(assetTo).DSPFlashLoanCall(msg.sender, baseAmount, quoteAmount, data);\n\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - _MT_FEE_BASE_;\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - _MT_FEE_QUOTE_;\n\n        // no input -> pure loss\n        require(\n            baseBalance >= _BASE_RESERVE_ || quoteBalance >= _QUOTE_RESERVE_,\n            \"FLASH_LOAN_FAILED\"\n        );\n\n        // sell quote case\n        // quote input + base output\n        if (baseBalance < _BASE_RESERVE_) {\n            uint256 quoteInput = quoteBalance - uint256(_QUOTE_RESERVE_);\n            (\n                uint256 receiveBaseAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newQuoteTarget\n            ) = querySellQuote(tx.origin, quoteInput); // revert if quoteBalance<quoteReserve\n            require(\n                (uint256(_BASE_RESERVE_) - baseBalance) <= receiveBaseAmount,\n                \"FLASH_LOAN_FAILED\"\n            );\n            \n            _MT_FEE_BASE_ = _MT_FEE_BASE_ + mtFee;\n            \n            if (_RState_ != uint32(newRState)) {\n                require(newQuoteTarget <= type(uint112).max, \"OVERFLOW\");\n                _QUOTE_TARGET_ = uint112(newQuoteTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_QUOTE_TOKEN_),\n                address(_BASE_TOKEN_),\n                quoteInput,\n                receiveBaseAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        // sell base case\n        // base input + quote output\n        if (quoteBalance < _QUOTE_RESERVE_) {\n            uint256 baseInput = baseBalance - uint256(_BASE_RESERVE_);\n            (\n                uint256 receiveQuoteAmount,\n                uint256 mtFee,\n                PMMPricing.RState newRState,\n                uint256 newBaseTarget\n            ) = querySellBase(tx.origin, baseInput); // revert if baseBalance<baseReserve\n            require(\n                (uint256(_QUOTE_RESERVE_) - quoteBalance) <= receiveQuoteAmount,\n                \"FLASH_LOAN_FAILED\"\n            );\n\n            _MT_FEE_QUOTE_ = _MT_FEE_QUOTE_ + mtFee;\n            \n            if (_RState_ != uint32(newRState)) {\n                require(newBaseTarget <= type(uint112).max, \"OVERFLOW\");\n                _BASE_TARGET_ = uint112(newBaseTarget);\n                _RState_ = uint32(newRState);\n                emit RChange(newRState);\n            }\n            emit DODOSwap(\n                address(_BASE_TOKEN_),\n                address(_QUOTE_TOKEN_),\n                baseInput,\n                receiveQuoteAmount,\n                msg.sender,\n                assetTo\n            );\n        }\n\n        _sync();\n\n        emit DODOFlashLoan(msg.sender, assetTo, baseAmount, quoteAmount);\n    }\n\n    // ============ Query Functions ============\n    /**\n     * @notice Return swap result, for query, sellBase side. \n     * @param trader Useless, just to keep the same interface with old version pool\n     * @param payBaseAmount The amount of base token user want to sell\n     * @return receiveQuoteAmount The amount of quote token user will receive\n     * @return mtFee The amount of mt fee charged\n     * @return newRState The new RState after swap\n     * @return newBaseTarget The new base target after swap\n     */\n    function querySellBase(address trader, uint256 payBaseAmount)\n        public\n        view\n        returns (\n            uint256 receiveQuoteAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newBaseTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveQuoteAmount, newRState) = PMMPricing.sellBaseToken(state, payBaseAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_;\n        mtFee = DecimalMath.mulFloor(receiveQuoteAmount, mtFeeRate);\n        receiveQuoteAmount = receiveQuoteAmount\n            - DecimalMath.mulFloor(receiveQuoteAmount, lpFeeRate)\n            - mtFee;\n        newBaseTarget = state.B0;\n    }\n    /**\n     * @notice Return swap result, for query, sellQuote side\n     * @param trader Useless, just for keeping the same interface with old version pool\n     * @param payQuoteAmount The amount of quote token user want to sell\n     * @return receiveBaseAmount The amount of base token user will receive\n     * @return mtFee The amount of mt fee charged\n     * @return newRState The new RState after swap\n     * @return newQuoteTarget The new quote target after swap\n     */\n    function querySellQuote(address trader, uint256 payQuoteAmount)\n        public\n        view\n        returns (\n            uint256 receiveBaseAmount,\n            uint256 mtFee,\n            PMMPricing.RState newRState,\n            uint256 newQuoteTarget\n        )\n    {\n        PMMPricing.PMMState memory state = getPMMState();\n        (receiveBaseAmount, newRState) = PMMPricing.sellQuoteToken(state, payQuoteAmount);\n\n        uint256 lpFeeRate = _LP_FEE_RATE_;\n        uint256 mtFeeRate = _MT_FEE_RATE_;\n        mtFee = DecimalMath.mulFloor(receiveBaseAmount, mtFeeRate);\n        receiveBaseAmount = receiveBaseAmount\n            - DecimalMath.mulFloor(receiveBaseAmount, lpFeeRate)\n            - mtFee;\n        newQuoteTarget = state.Q0;\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/GasSavingPool/impl/GSPVault.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport {DecimalMath} from \"../../lib/DecimalMath.sol\";\nimport {PMMPricing} from \"../../lib/PMMPricing.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {GSPStorage} from \"./GSPStorage.sol\";\n\ncontract GSPVault is GSPStorage {\n    using SafeERC20 for IERC20;\n\n    // ============ Modifiers ============\n    /// @notice Check whether the caller is maintainer\n    modifier onlyMaintainer() {\n        require(msg.sender == _MAINTAINER_, \"ACCESS_DENIED\");\n        _;\n    }\n\n    /// @notice Check whether the caller is admin\n    modifier onlyAdmin() {\n        require(msg.sender == _ADMIN_, \"ADMIN_ACCESS_DENIED\");\n        _;\n    }\n\n    // ============ Events ============\n\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    event Mint(address indexed user, uint256 value);\n\n    event Burn(address indexed user, uint256 value);\n\n    event MtFeeRateChange(uint256 newMtFee);\n\n    event LpFeeRateChange(uint256 newLpFee);\n\n    event IChange(uint256 newI);\n\n    event KChange(uint256 newK);\n\n    event WithdrawMtFee(address indexed token, uint256 amount);\n\n    // ============ View Functions ============\n    /**\n     * @notice Get the reserves of the pool\n     * @return baseReserve The base token reserve\n     * @return quoteReserve The quote token reserve\n     */\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve) {\n        baseReserve = _BASE_RESERVE_;\n        quoteReserve = _QUOTE_RESERVE_;\n    }\n\n    /**\n     * @notice Get the fee rate of the pool\n     * @param user Useless, just keep the same interface with old version pool\n     * @return lpFeeRate The lp fee rate\n     * @return mtFeeRate The mt fee rate\n     */\n    function getUserFeeRate(address user) \n        external \n        view \n        returns (uint256 lpFeeRate, uint256 mtFeeRate) \n    {\n        lpFeeRate = _LP_FEE_RATE_;\n        mtFeeRate = _MT_FEE_RATE_;\n    }\n\n    // ============ Asset In ============\n    /**\n     * @notice Get the amount of base token transferred in\n     * @dev The amount of base token input should be the base token reserve minus the mt fee in base token\n     * @return input The amount of base token transferred in\n     */\n    function getBaseInput() public view returns (uint256 input) {\n        return _BASE_TOKEN_.balanceOf(address(this)) - uint256(_BASE_RESERVE_) - uint256(_MT_FEE_BASE_);\n    }\n\n    /**\n     * @notice Get the amount of quote token transferred in\n     * @dev The amount of quote token input should be the quote token reserve minus the mt fee in quote token\n     * @return input The amount of quote token transferred in\n     */\n    function getQuoteInput() public view returns (uint256 input) {\n        return _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_QUOTE_RESERVE_) - uint256(_MT_FEE_QUOTE_);\n    }\n\n    // ============ Set States ============\n    /**\n     * @notice Set the reserves of the pool, internal use only\n     * @param baseReserve The base token reserve\n     * @param quoteReserve The quote token reserve\n     */\n    function _setReserve(uint256 baseReserve, uint256 quoteReserve) internal {\n        // the reserves should be less than the max uint112\n        require(baseReserve <= type(uint112).max && quoteReserve <= type(uint112).max, \"OVERFLOW\");\n        _BASE_RESERVE_ = uint112(baseReserve);\n        _QUOTE_RESERVE_ = uint112(quoteReserve);\n    }\n\n    /**\n     * @notice Sync the reserves of the pool, internal use only\n     * @dev The balances of the pool should be actual balances minus the mt fee\n     */\n    function _sync() internal {\n        uint256 baseBalance = _BASE_TOKEN_.balanceOf(address(this)) - uint256(_MT_FEE_BASE_);\n        uint256 quoteBalance = _QUOTE_TOKEN_.balanceOf(address(this)) - uint256(_MT_FEE_QUOTE_);\n        // the reserves should be less than the max uint112\n        require(baseBalance <= type(uint112).max && quoteBalance <= type(uint112).max, \"OVERFLOW\");\n        if (baseBalance != _BASE_RESERVE_) {\n            _BASE_RESERVE_ = uint112(baseBalance);\n        }\n        if (quoteBalance != _QUOTE_RESERVE_) {\n            _QUOTE_RESERVE_ = uint112(quoteBalance);\n        }\n    }\n\n    /// @notice Sync the reserves of the pool\n    function sync() external nonReentrant {\n        _sync();\n    }\n\n    /// @notice Correct the rState of the pool, details in pmm algorithm\n    function correctRState() public {\n        if (_RState_ == uint32(PMMPricing.RState.BELOW_ONE) && _BASE_RESERVE_<_BASE_TARGET_) {\n          _RState_ = uint32(PMMPricing.RState.ONE);\n          _BASE_TARGET_ = _BASE_RESERVE_;\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n        if (_RState_ == uint32(PMMPricing.RState.ABOVE_ONE) && _QUOTE_RESERVE_<_QUOTE_TARGET_) {\n          _RState_ = uint32(PMMPricing.RState.ONE);\n          _BASE_TARGET_ = _BASE_RESERVE_;\n          _QUOTE_TARGET_ = _QUOTE_RESERVE_;\n        }\n    }\n\n    /**\n     * @notice PriceLimit is used for oracle change protection\n     * @notice It sets a ratio where the relative deviation between the new price and the old price cannot exceed this ratio.\n     * @dev The default priceLimit is 1e3, the decimals of priceLimit is 1e6\n     * @param priceLimit The new price limit\n     */\n    function adjustPriceLimit(uint256 priceLimit) external onlyAdmin {\n        // the default priceLimit is 1e3\n        require(priceLimit <= 1e6, \"INVALID_PRICE_LIMIT\");\n        _PRICE_LIMIT_ = priceLimit;\n    }\n\n    /**\n     * @notice Adjust oricle price i, only for admin\n     */\n    function adjustPrice(uint256 i) external onlyAdmin {\n        // the difference between i and _I_ should be less than priceLimit\n        uint256 offset = i > _I_ ? i - _I_ : _I_ - i;\n        require((offset * 1e6 / _I_) <= _PRICE_LIMIT_, \"EXCEED_PRICE_LIMIT\");\n        _I_ = i;\n        \n        emit IChange(i);\n    }\n\n    /**\n     * @notice Adjust mtFee rate, only for maintainer\n     * @dev The decimals of mtFee rate is 1e18\n     * @param mtFeeRate The new mtFee rate\n     */\n    function adjustMtFeeRate(uint256 mtFeeRate) external onlyMaintainer {\n        require(mtFeeRate <= 10**18, \"INVALID_MT_FEE_RATE\");\n        _MT_FEE_RATE_ = mtFeeRate;\n\n        emit MtFeeRateChange(mtFeeRate);\n    }\n\n    /**\n     * @notice Adjust lpFee rate, only for maintainer\n     * @dev The decimals of lpFee rate is 1e18\n     * @param lpFeeRate The new lpFee rate\n     */\n    function adjustLpFeeRate(uint256 lpFeeRate) external onlyMaintainer {\n        require(lpFeeRate <= 10**18, \"INVALID_LP_FEE_RATE\");\n        _LP_FEE_RATE_ = lpFeeRate;\n\n        emit LpFeeRateChange(lpFeeRate);\n    }\n\n    /**\n     * @notice Adjust swap curve parameter k, only for maintainer\n     * @dev The decimals of k is 1e18\n     * @param k The new swap curve parameter k\n     */\n    function adjustK(uint256 k) external onlyMaintainer {\n        require(k <= 10**18, \"INVALID_K\");\n        _K_ = k;\n\n        emit KChange(k);\n    }\n\n    // ============ Asset Out ============\n    /**\n     * @notice Transfer base token out, internal use only\n     * @param to The address of the receiver\n     * @param amount The amount of base token to transfer out\n     */\n    function _transferBaseOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _BASE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    /**\n     * @notice Transfer quote token out, internal use only\n     * @param to The address of the receiver\n     * @param amount The amount of quote token to transfer out\n     */\n    function _transferQuoteOut(address to, uint256 amount) internal {\n        if (amount > 0) {\n            _QUOTE_TOKEN_.safeTransfer(to, amount);\n        }\n    }\n\n    /// @notice Maintainer withdraw mtFee, only for maintainer\n    function withdrawMtFeeTotal() external nonReentrant onlyMaintainer {\n        uint256 mtFeeQuote = _MT_FEE_QUOTE_;\n        uint256 mtFeeBase = _MT_FEE_BASE_;\n        _MT_FEE_QUOTE_ = 0;\n        _transferQuoteOut(_MAINTAINER_, mtFeeQuote);\n        _MT_FEE_BASE_ = 0;\n        _transferBaseOut(_MAINTAINER_, mtFeeBase);\n\n        emit WithdrawMtFee(address(_QUOTE_TOKEN_), mtFeeQuote);\n        emit WithdrawMtFee(address(_BASE_TOKEN_), mtFeeBase);\n    }\n\n    // ============ Shares (ERC20) ============\n\n    /**\n     * @dev Transfer token for a specified address\n     * @param to The address to transfer to.\n     * @param amount The amount to be transferred.\n     */\n    function transfer(address to, uint256 amount) public returns (bool) {\n        require(amount <= _SHARES_[msg.sender], \"BALANCE_NOT_ENOUGH\");\n\n        _SHARES_[msg.sender] = _SHARES_[msg.sender] - (amount);\n        _SHARES_[to] = _SHARES_[to] + amount;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the the balance of.\n     * @return balance An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance) {\n        return _SHARES_[owner];\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param amount uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public returns (bool) {\n        require(amount <= _SHARES_[from], \"BALANCE_NOT_ENOUGH\");\n        require(amount <= _ALLOWED_[from][msg.sender], \"ALLOWANCE_NOT_ENOUGH\");\n\n        _SHARES_[from] = _SHARES_[from] - amount;\n        _SHARES_[to] = _SHARES_[to] + amount;\n        _ALLOWED_[from][msg.sender] = _ALLOWED_[from][msg.sender] - amount;\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * @param spender The address which will spend the funds.\n     * @param amount The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 amount) public returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) private {\n        _ALLOWED_[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner _ALLOWED_ to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _ALLOWED_[owner][spender];\n    }\n\n    function _mint(address user, uint256 value) internal {\n        require(value > 1000, \"MINT_AMOUNT_NOT_ENOUGH\");\n        _SHARES_[user] = _SHARES_[user] + value;\n        totalSupply = totalSupply + value;\n        emit Mint(user, value);\n        emit Transfer(address(0), user, value);\n    }\n\n    function _burn(address user, uint256 value) internal {\n        _SHARES_[user] = _SHARES_[user] - value;\n        totalSupply = totalSupply - value;\n        emit Burn(user, value);\n        emit Transfer(user, address(0), value);\n    }\n\n    // ============================ Permit ======================================\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external {\n        require(deadline >= block.timestamp, \"DODO_GSP_LP: EXPIRED\");\n        bytes32 digest =\n            keccak256(\n                abi.encodePacked(\n                    \"\\x19\\x01\",\n                    DOMAIN_SEPARATOR,\n                    keccak256(\n                        abi.encode(\n                            PERMIT_TYPEHASH,\n                            owner,\n                            spender,\n                            value,\n                            nonces[owner]++,\n                            deadline\n                        )\n                    )\n                )\n            );\n\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(\n            recoveredAddress != address(0) && recoveredAddress == owner,\n            \"DODO_GSP_LP: INVALID_SIGNATURE\"\n        );\n        _approve(owner, spender, value);\n    }\n}"
    },
    "contracts/DODOGasSavingPool/intf/IDODOCallee.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\ninterface IDODOCallee {\n    function DVMSellShareCall(\n        address sender,\n        uint256 burnShareAmount,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DVMFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DPPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function DSPFlashLoanCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function CPCancelCall(\n        address sender,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n\tfunction CPClaimBidCall(\n        address sender,\n        uint256 baseAmount,\n        uint256 quoteAmount,\n        bytes calldata data\n    ) external;\n\n    function NFTRedeemCall(\n        address payable assetTo,\n        uint256 quoteAmount,\n        bytes calldata\n    ) external;\n}\n"
    },
    "contracts/DODOGasSavingPool/lib/DecimalMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title DecimalMath\n * @author DODO Breeder\n *\n * @notice Functions for fixed point number with 18 decimals\n */\n\nlibrary DecimalMath {\n    uint256 internal constant ONE = 10 ** 18;\n    uint256 internal constant ONE2 = 10 ** 36;\n\n    function mul(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target * d / (10 ** 18);\n    }\n\n    function mulFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target * d / (10 ** 18);\n    }\n\n    function mulCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return _divCeil(target * d, 10 ** 18);\n    }\n\n    function div(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target * (10 ** 18) / d;\n    }\n\n    function divFloor(uint256 target, uint256 d) internal pure returns (uint256) {\n        return target * (10 ** 18) / d;\n    }\n\n    function divCeil(uint256 target, uint256 d) internal pure returns (uint256) {\n        return _divCeil(target * (10 ** 18), d);\n    }\n\n    function reciprocalFloor(uint256 target) internal pure returns (uint256) {\n        return uint256(10 ** 36) / target;\n    }\n\n    function reciprocalCeil(uint256 target) internal pure returns (uint256) {\n        return _divCeil(uint256(10 ** 36), target);\n    }\n\n    function sqrt(uint256 target) internal pure returns (uint256) {\n        return Math.sqrt(target * ONE);\n    }\n\n    function powFloor(uint256 target, uint256 e) internal pure returns (uint256) {\n        if (e == 0) {\n            return 10 ** 18;\n        } else if (e == 1) {\n            return target;\n        } else {\n            uint256 p = powFloor(target, e / 2);\n            p = p * p / (10 ** 18);\n            if (e % 2 == 1) {\n                p = p * target / (10 ** 18);\n            }\n            return p;\n        }\n    }\n\n    function _divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 quotient = a / b;\n        uint256 remainder = a - quotient * b;\n        if (remainder > 0) {\n            return quotient + 1;\n        } else {\n            return quotient;\n        }\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/lib/DODOMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport {DecimalMath} from \"./DecimalMath.sol\";\nimport {Math} from \"@openzeppelin/contracts/utils/math/Math.sol\";\n\n/**\n * @title DODOMath\n * @author DODO Breeder\n *\n * @notice Functions for complex calculating. Including ONE Integration and TWO Quadratic solutions\n */\nlibrary DODOMath {\n    using Math for uint256;\n    /*\n        Integrate dodo curve from V1 to V2\n        require V0>=V1>=V2>0\n        res = (1-k)i(V1-V2)+ikV0*V0(1/V2-1/V1)\n        let V1-V2=delta\n        res = i*delta*(1-k+k(V0^2/V1/V2))\n\n        i is the price of V-res trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _GeneralIntegrate(\n        uint256 V0,\n        uint256 V1,\n        uint256 V2,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        uint256 fairAmount = i * (V1 - V2); // i*delta\n        if (k == 0) {\n            return fairAmount / DecimalMath.ONE;\n        }\n        uint256 V0V0V1V2 = DecimalMath.divFloor(V0 * V0 / V1, V2);\n        uint256 penalty = DecimalMath.mulFloor(k, V0V0V1V2); // k(V0^2/V1/V2)\n        return (DecimalMath.ONE - k + penalty) * fairAmount / DecimalMath.ONE2;\n    }\n\n    /*\n        Follow the integration function above\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Assume Q2=Q0, Given Q1 and deltaB, solve Q0\n\n        i is the price of delta-V trading pair\n        give out target of V\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTarget(\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        if (k == 0) {\n            return V1 + DecimalMath.mulFloor(i, delta);\n        }\n        // V0 = V1*(1+(sqrt-1)/2k)\n        // sqrt = √(1+4kidelta/V1)\n        // premium = 1+(sqrt-1)/2k\n        // uint256 sqrt = (4 * k).mul(i).mul(delta).div(V1).add(DecimalMath.ONE2).sqrt();\n\n        if (V1 == 0) {\n            return 0;\n        }\n        uint256 sqrt;\n        uint256 ki = 4 * k * i;\n\n        if (ki == 0) {\n            sqrt = DecimalMath.ONE;\n        } else if ((ki * delta) / ki == delta) {\n            sqrt =((ki * delta) / V1  + DecimalMath.ONE2).sqrt();\n        } else {\n            sqrt = (ki / V1 * delta + DecimalMath.ONE2).sqrt();\n        }\n        uint256 premium =\n            DecimalMath.divFloor(sqrt - DecimalMath.ONE, k * 2) + DecimalMath.ONE;\n        // V0 is greater than or equal to V1 according to the solution\n        return DecimalMath.mulFloor(V1, premium);\n    }\n\n    /*\n        Follow the integration expression above, we have:\n        i*deltaB = (Q2-Q1)*(1-k+kQ0^2/Q1/Q2)\n        Given Q1 and deltaB, solve Q2\n        This is a quadratic function and the standard version is\n        aQ2^2 + bQ2 + c = 0, where\n        a=1-k\n        -b=(1-k)Q1-kQ0^2/Q1+i*deltaB\n        c=-kQ0^2 \n        and Q2=(-b+sqrt(b^2+4(1-k)kQ0^2))/2(1-k)\n        note: another root is negative, abondan\n\n        if deltaBSig=true, then Q2>Q1, user sell Q and receive B\n        if deltaBSig=false, then Q2<Q1, user sell B and receive Q\n        return |Q1-Q2|\n\n        as we only support sell amount as delta, the deltaB is always negative\n        the input ideltaB is actually -ideltaB in the equation\n\n        i is the price of delta-V trading pair\n\n        support k=1 & k=0 case\n\n        [round down]\n    */\n    function _SolveQuadraticFunctionForTrade(\n        uint256 V0,\n        uint256 V1,\n        uint256 delta,\n        uint256 i,\n        uint256 k\n    ) internal pure returns (uint256) {\n        require(V0 > 0, \"TARGET_IS_ZERO\");\n        if (delta == 0) {\n            return 0;\n        }\n\n        if (k == 0) {\n            // why v1\n            return DecimalMath.mulFloor(i, delta) > V1 ? V1 : DecimalMath.mulFloor(i, delta);\n        }\n\n        if (k == DecimalMath.ONE) {\n            // if k==1\n            // Q2=Q1/(1+ideltaBQ1/Q0/Q0)\n            // temp = ideltaBQ1/Q0/Q0\n            // Q2 = Q1/(1+temp)\n            // Q1-Q2 = Q1*(1-1/(1+temp)) = Q1*(temp/(1+temp))\n            // uint256 temp = i.mul(delta).mul(V1).div(V0.mul(V0));\n            uint256 temp;\n            uint256 idelta = i * (delta);\n            if (idelta == 0) {\n                temp = 0;\n            } else if ((idelta * V1) / idelta == V1) {\n                temp = (idelta * V1) / (V0 * V0);\n            } else {\n                temp = delta * (V1) / (V0) * (i) / (V0);\n            }\n            return V1 * (temp) / (temp + (DecimalMath.ONE));\n        }\n\n        // calculate -b value and sig\n        // b = kQ0^2/Q1-i*deltaB-(1-k)Q1\n        // part1 = (1-k)Q1 >=0\n        // part2 = kQ0^2/Q1-i*deltaB >=0\n        // bAbs = abs(part1-part2)\n        // if part1>part2 => b is negative => bSig is false\n        // if part2>part1 => b is positive => bSig is true\n        uint256 part2 = k * (V0) / (V1) * (V0) + (i * (delta)); // kQ0^2/Q1-i*deltaB\n        uint256 bAbs = (DecimalMath.ONE - k) * (V1); // (1-k)Q1\n\n        bool bSig;\n        if (bAbs >= part2) {\n            bAbs = bAbs - part2;\n            bSig = false;\n        } else {\n            bAbs = part2 - bAbs;\n            bSig = true;\n        }\n        bAbs = bAbs / (DecimalMath.ONE);\n\n        // calculate sqrt\n        uint256 squareRoot = DecimalMath.mulFloor((DecimalMath.ONE - k) * (4), DecimalMath.mulFloor(k, V0) * (V0)); // 4(1-k)kQ0^2\n        squareRoot = Math.sqrt((bAbs * bAbs) + squareRoot); // sqrt(b*b+4(1-k)kQ0*Q0)\n\n        // final res\n        uint256 denominator = (DecimalMath.ONE - k) * 2; // 2(1-k)\n        uint256 numerator;\n        if (bSig) {\n            numerator = squareRoot - bAbs;\n            if (numerator == 0) {\n                revert(\"DODOMath: should not be 0\");\n            }\n        } else {\n            numerator = bAbs + squareRoot;\n        }\n\n        uint256 V2 = DecimalMath.divCeil(numerator, denominator);\n        if (V2 > V1) {\n            return 0;\n        } else {\n            return V1 - V2;\n        }\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/lib/InitializableOwnable.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\n/**\n * @title Ownable\n * @author DODO Breeder\n *\n * @notice Ownership related functions\n */\ncontract InitializableOwnable {\n    address public _OWNER_;\n    address public _NEW_OWNER_;\n    bool internal _INITIALIZED_;\n\n    // ============ Events ============\n\n    event OwnershipTransferPrepared(address indexed previousOwner, address indexed newOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    // ============ Modifiers ============\n\n    modifier notInitialized() {\n        require(!_INITIALIZED_, \"DODO_INITIALIZED\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == _OWNER_, \"NOT_OWNER\");\n        _;\n    }\n\n    // ============ Functions ============\n\n    function initOwner(address newOwner) public notInitialized {\n        _INITIALIZED_ = true;\n        _OWNER_ = newOwner;\n    }\n\n    function transferOwnership(address newOwner) public onlyOwner {\n        emit OwnershipTransferPrepared(_OWNER_, newOwner);\n        _NEW_OWNER_ = newOwner;\n    }\n\n    function claimOwnership() public {\n        require(msg.sender == _NEW_OWNER_, \"INVALID_CLAIM\");\n        emit OwnershipTransferred(_OWNER_, _NEW_OWNER_);\n        _OWNER_ = _NEW_OWNER_;\n        _NEW_OWNER_ = address(0);\n    }\n}\n"
    },
    "contracts/DODOGasSavingPool/lib/PMMPricing.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\npragma experimental ABIEncoderV2;\n\nimport {DecimalMath} from \"../lib/DecimalMath.sol\";\nimport {DODOMath} from \"../lib/DODOMath.sol\";\n\n/**\n * @title Pricing\n * @author DODO Breeder\n *\n * @notice DODO Pricing model\n */\n\nlibrary PMMPricing {\n\n    enum RState {ONE, ABOVE_ONE, BELOW_ONE}\n\n    struct PMMState {\n        uint256 i;\n        uint256 K;\n        uint256 B;\n        uint256 Q;\n        uint256 B0;\n        uint256 Q0;\n        RState R;\n    }\n\n    // ============ buy & sell ============\n    /**\n     * @notice Inner calculation based on pmm algorithm, sell base\n     * @param state The current PMM state\n     * @param payBaseAmount The amount of base token user want to sell\n     * @return receiveQuoteAmount The amount of quote token user will receive\n     * @return newR The new R status after swap\n     */\n    function sellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (uint256 receiveQuoteAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            // case 1: R=1\n            // R falls below one\n            receiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            uint256 backToOnePayBase = state.B0 - state.B;\n            uint256 backToOneReceiveQuote = state.Q - state.Q0;\n            // case 2: R>1\n            // complex case, R status depends on trading amount\n            if (payBaseAmount < backToOnePayBase) {\n                // case 2.1: R status do not change\n                receiveQuoteAmount = _RAboveSellBaseToken(state, payBaseAmount);\n                newR = RState.ABOVE_ONE;\n                if (receiveQuoteAmount > backToOneReceiveQuote) {\n                    // [Important corner case!] may enter this branch when some precision problem happens. And consequently contribute to negative spare quote amount\n                    // to make sure spare quote>=0, mannually set receiveQuote=backToOneReceiveQuote\n                    receiveQuoteAmount = backToOneReceiveQuote;\n                }\n            } else if (payBaseAmount == backToOnePayBase) {\n                // case 2.2: R status changes to ONE\n                receiveQuoteAmount = backToOneReceiveQuote;\n                newR = RState.ONE;\n            } else {\n                // case 2.3: R status changes to BELOW_ONE\n                receiveQuoteAmount = backToOneReceiveQuote + (\n                    _ROneSellBaseToken(state, (payBaseAmount - backToOnePayBase))\n                );\n                newR = RState.BELOW_ONE;\n            }\n        } else {\n            // state.R == RState.BELOW_ONE\n            // case 3: R<1\n            receiveQuoteAmount = _RBelowSellBaseToken(state, payBaseAmount);\n            newR = RState.BELOW_ONE;\n        }\n    }\n\n    /**\n     * @notice Inner calculation based on pmm algorithm, sell quote\n     * @param state The current PMM state\n     * @param payQuoteAmount The amount of quote token user want to sell\n     * @return receiveBaseAmount The amount of base token user will receive\n     * @return newR The new R status after swap\n     */\n    function sellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (uint256 receiveBaseAmount, RState newR)\n    {\n        if (state.R == RState.ONE) {\n            receiveBaseAmount = _ROneSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else if (state.R == RState.ABOVE_ONE) {\n            receiveBaseAmount = _RAboveSellQuoteToken(state, payQuoteAmount);\n            newR = RState.ABOVE_ONE;\n        } else {\n            uint256 backToOnePayQuote = state.Q0 - state.Q;\n            uint256 backToOneReceiveBase = state.B - state.B0;\n            if (payQuoteAmount < backToOnePayQuote) {\n                receiveBaseAmount = _RBelowSellQuoteToken(state, payQuoteAmount); \n                newR = RState.BELOW_ONE;\n                if (receiveBaseAmount > backToOneReceiveBase) {\n                    receiveBaseAmount = backToOneReceiveBase;\n                }\n            } else if (payQuoteAmount == backToOnePayQuote) {\n                receiveBaseAmount = backToOneReceiveBase;\n                newR = RState.ONE;\n            } else {\n                receiveBaseAmount = backToOneReceiveBase + (\n                    _ROneSellQuoteToken(state, payQuoteAmount - backToOnePayQuote) \n                );\n                newR = RState.ABOVE_ONE;\n            }\n        }\n    }\n\n    // ============ R = 1 cases ============\n\n    function _ROneSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        // in theory Q2 <= targetQuoteTokenAmount\n        // however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmount\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.Q0,\n                state.Q0,\n                payBaseAmount,\n                state.i,\n                state.K\n            );\n    }\n\n    function _ROneSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B0,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ R < 1 cases ============\n\n    function _RBelowSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._GeneralIntegrate(\n                state.Q0,\n                state.Q + payQuoteAmount,\n                state.Q,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    function _RBelowSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.Q0,\n                state.Q,\n                payBaseAmount,\n                state.i,\n                state.K\n            );\n    }\n\n    // ============ R > 1 cases ============\n\n    function _RAboveSellBaseToken(PMMState memory state, uint256 payBaseAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveQuoteToken\n        )\n    {\n        return\n            DODOMath._GeneralIntegrate(\n                state.B0,\n                state.B + payBaseAmount,\n                state.B,\n                state.i,\n                state.K\n            );\n    }\n\n    function _RAboveSellQuoteToken(PMMState memory state, uint256 payQuoteAmount)\n        internal\n        pure\n        returns (\n            uint256 // receiveBaseToken\n        )\n    {\n        return\n            DODOMath._SolveQuadraticFunctionForTrade(\n                state.B0,\n                state.B,\n                payQuoteAmount,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n    }\n\n    // ============ Helper functions ============\n\n    function adjustedTarget(PMMState memory state) internal pure {\n        if (state.R == RState.BELOW_ONE) {\n            state.Q0 = DODOMath._SolveQuadraticFunctionForTarget(\n                state.Q,\n                state.B - state.B0,\n                state.i,\n                state.K\n            );\n        } else if (state.R == RState.ABOVE_ONE) {\n            state.B0 = DODOMath._SolveQuadraticFunctionForTarget(\n                state.B,\n                state.Q - state.Q0,\n                DecimalMath.reciprocalFloor(state.i),\n                state.K\n            );\n        }\n    }\n\n    function getMidPrice(PMMState memory state) internal pure returns (uint256) {\n        if (state.R == RState.BELOW_ONE) {\n            uint256 R = DecimalMath.divFloor(state.Q0 * state.Q0 / state.Q, state.Q);\n            R = DecimalMath.ONE - state.K + (DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.divFloor(state.i, R);\n        } else {\n            uint256 R = DecimalMath.divFloor(state.B0 * state.B0 / state.B, state.B);\n            R = DecimalMath.ONE - state.K + (DecimalMath.mulFloor(state.K, R));\n            return DecimalMath.mulFloor(state.i, R);\n        }\n    }\n}\n"
    },
    "contracts/Factory/GSPFactory.sol": {
      "content": "/*\n\n    Copyright 2020 DODO ZOO.\n    SPDX-License-Identifier: Apache-2.0\n\n*/\n\npragma solidity 0.8.16;\n\nimport {InitializableOwnable} from \"../DODOGasSavingPool/lib/InitializableOwnable.sol\";\n// import {ICloneFactory} from \"../lib/CloneFactory.sol\";\nimport {GSP} from \"../DODOGasSavingPool/GasSavingPool/impl/GSP.sol\";\n\ninterface IGSP {\n    function init(\n        address maintainer,\n        address admin,\n        address baseTokenAddress,\n        address quoteTokenAddress,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 i,\n        uint256 k,\n        uint256 priceLimit,\n        bool isOpenTWAP\n    ) external;\n\n    function _BASE_TOKEN_() external view returns (address);\n\n    function _QUOTE_TOKEN_() external view returns (address);\n\n    function _I_() external view returns (uint256);\n\n    function _MT_FEE_RATE_MODEL_() external view returns (address); // Useless, just for compatibility\n\n    function getVaultReserve() external view returns (uint256 baseReserve, uint256 quoteReserve);\n\n    function getUserFeeRate(address user) external view returns (uint256 lpFeeRate, uint256 mtFeeRate);\n\n    function getMtFeeTotal() external view returns (uint256 mtFeeBase, uint256 mtFeeQuote);\n\n    function sellBase(address to) external returns (uint256);\n\n    function sellQuote(address to) external returns (uint256);\n\n    function buyShares(address to) external returns (uint256 shares, uint256 baseInput, uint256 quoteInput);\n\n    function sellShares(uint256 shareAmount, address to, uint256 baseMinAmount, uint256 quoteMinAmount, bytes calldata data, uint256 deadline) external returns (uint256 baseAmount, uint256 quoteAmount);\n}\n\ninterface IGSPFactory {\n    function createDODOGasSavingPool(\n        address admin,\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 i,\n        uint256 k,\n        uint256 priceLimit,\n        bool isOpenTWAP\n    ) external returns (address newGasSavingPool);\n}\n\n/**\n * @title DODO GasSavingPool Factory\n * @author DODO Breeder\n *\n * @notice Create And Register GSP Pools\n */\ncontract GSPFactory is InitializableOwnable {\n    // ============ Templates ============\n\n    address public immutable _CLONE_FACTORY_;\n    address public _DEFAULT_MAINTAINER_;\n    address public _GSP_TEMPLATE_;\n\n    // ============ Registry ============\n\n    // base -> quote -> GSP address list\n    mapping(address => mapping(address => address[])) public _REGISTRY_;\n    // creator -> GSP address list\n    mapping(address => address[]) public _USER_REGISTRY_;\n\n    // ============ Events ============\n\n    event NewGSP(address baseToken, address quoteToken, address creator, address GSP);\n\n    event RemoveGSP(address GSP);\n\n    // ============ Functions ============\n\n    constructor(\n        address cloneFactory,\n        address GSPTemplate,\n        address defaultMaintainer\n    ) {\n        _CLONE_FACTORY_ = cloneFactory;\n        _GSP_TEMPLATE_ = GSPTemplate;\n        _DEFAULT_MAINTAINER_ = defaultMaintainer;\n    }\n\n    function createDODOGasSavingPool(\n        address admin,\n        address baseToken,\n        address quoteToken,\n        uint256 lpFeeRate,\n        uint256 mtFeeRate,\n        uint256 i,\n        uint256 k,\n        uint256 priceLimit,\n        bool isOpenTWAP\n    ) external returns (address newGasSavingPool) {\n        GSP newPool = new GSP();\n        newGasSavingPool = address(newPool);\n        {\n            IGSP(newGasSavingPool).init(\n                _DEFAULT_MAINTAINER_,\n                admin,\n                baseToken,\n                quoteToken,\n                lpFeeRate,\n                mtFeeRate,\n                i,\n                k,\n                priceLimit,\n                isOpenTWAP\n            );\n        }\n        _REGISTRY_[baseToken][quoteToken].push(newGasSavingPool);\n        _USER_REGISTRY_[tx.origin].push(newGasSavingPool);\n        emit NewGSP(baseToken, quoteToken, tx.origin, newGasSavingPool);\n    }\n\n    // ============ Admin Operation Functions ============\n\n    function updateGSPTemplate(address _newGSPTemplate) external onlyOwner {\n        _GSP_TEMPLATE_ = _newGSPTemplate;\n    }\n\n    function updateDefaultMaintainer(address _newMaintainer) external onlyOwner {\n        _DEFAULT_MAINTAINER_ = _newMaintainer;\n    }\n\n    function addPoolByAdmin(\n        address creator,\n        address baseToken,\n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        _REGISTRY_[baseToken][quoteToken].push(pool);\n        _USER_REGISTRY_[creator].push(pool);\n        emit NewGSP(baseToken, quoteToken, creator, pool);\n    }\n\n    function removePoolByAdmin(\n        address creator,\n        address baseToken,\n        address quoteToken,\n        address pool\n    ) external onlyOwner {\n        address[] memory registryList = _REGISTRY_[baseToken][quoteToken];\n        for (uint256 i = 0; i < registryList.length; i++) {\n            if (registryList[i] == pool) {\n                registryList[i] = registryList[registryList.length - 1];\n                break;\n            }\n        }\n        _REGISTRY_[baseToken][quoteToken] = registryList;\n        _REGISTRY_[baseToken][quoteToken].pop();\n        address[] memory userRegistryList = _USER_REGISTRY_[creator];\n        for (uint256 i = 0; i < userRegistryList.length; i++) {\n            if (userRegistryList[i] == pool) {\n                userRegistryList[i] = userRegistryList[userRegistryList.length - 1];\n                break;\n            }\n        }\n        _USER_REGISTRY_[creator] = userRegistryList;\n        _USER_REGISTRY_[creator].pop();\n        emit RemoveGSP(pool);\n    }\n\n    // ============ View Functions ============\n\n    function getDODOPool(address baseToken, address quoteToken)\n        external\n        view\n        returns (address[] memory machines)\n    {\n        return _REGISTRY_[baseToken][quoteToken];\n    }\n\n    function getDODOPoolBidirection(address token0, address token1)\n        external\n        view\n        returns (address[] memory baseToken0Machines, address[] memory baseToken1Machines)\n    {\n        return (_REGISTRY_[token0][token1], _REGISTRY_[token1][token0]);\n    }\n\n    function getDODOPoolByUser(address user) external view returns (address[] memory machines) {\n        return _USER_REGISTRY_[user];\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "mode": "3"
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "detectMissingLibraries": false,
    "forceEVMLA": false,
    "enableEraVMExtensions": false,
    "libraries": {}
  }
}